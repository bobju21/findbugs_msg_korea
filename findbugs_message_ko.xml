<? xml version = "1.0"encoding = "UTF-8"?>

<MessageCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="messagecollection.xsd">

  <! -
  *********************************************************************
  Plugin information
  *********************************************************************
  ->
  <Plugin>
    <ShortDescription> 코어 FindBugs 플러그인 </ ShortDescription>
    <Details>
<! [CDATA [
<p>
이 플러그인은 모든 표준 FindBugs 검출기 있습니다.
</ p>
]]>
    </ Details>
  </ Plugin>

  <FindBugsMain cmd="addMessages" class="edu.umd.cs.findbugs.AddMessages">
    <Description> add msgs (eg, textual descriptions of bugs) to analysis results </ Description>
  </ FindBugsMain>
  <FindBugsMain cmd="analyze" class="edu.umd.cs.findbugs.FindBugs2">
    <Description> Perform FindBugs Analysis </ Description>
  </ FindBugsMain>
  <FindBugsMain cmd="gui" class="edu.umd.cs.findbugs.gui2.Driver">
    <Description> Launch FindBugs GUI </ Description>
  </ FindBugsMain>
  <FindBugsMain cmd="list" class="edu.umd.cs.findbugs.PrintingBugReporter">
    <Description> Convert analysis results to textual form </ Description>
  </ FindBugsMain>
  <FindBugsMain cmd="help" class="edu.umd.cs.findbugs.ShowHelp">
    <Description> Provide help for commands </ Description>
  </ FindBugsMain>
  <FindBugsMain cmd="version" class="edu.umd.cs.findbugs.Version">
    <Description> List FindBugs version </ Description>
  </ FindBugsMain>
  <FindBugsMain cmd="filter" class="edu.umd.cs.findbugs.workflow.Filter">
    <Description> Filter analysis results </ Description>
  </ FindBugsMain>
  <FindBugsMain cmd="set" class="edu.umd.cs.findbugs.workflow.SetBugDatabaseInfo">
    <Description> Set project configuration / options </ Description>
  </ FindBugsMain>
  <FindBugsMain cmd="history" class="edu.umd.cs.findbugs.workflow.MineBugHistory">
    <Description> List details from multi-version analysis results </ Description>
  </ FindBugsMain>
  <FindBugsMain cmd="union" class="edu.umd.cs.findbugs.workflow.UnionResults">
    <Description> Merge analysis results from disjoint components </ Description>
  </ FindBugsMain>
  <FindBugsMain cmd="merge" class="edu.umd.cs.findbugs.workflow.Update">
    <Description> Combine analysis results from different versions of software to produce multi-version analysis results </ Description>
  </ FindBugsMain>
  <FindBugsMain cmd="dis" class="edu.umd.cs.findbugs.workflow.PrintClass">
    <Description> Disassemble a class file </ Description>
  </ FindBugsMain>
  
  <! - 이것을 바꾸면 FindbugsPlugin 기본 ID를 업데이트하십시오 ->
  <Cloud id="edu.umd.cs.findbugs.cloud.doNothingCloud">
    <Description> (클라우드 해제) </ Description>
    <Details>이 플러그인을 사용하면 버그 리뷰 비활성화됩니다. </ Details>
  </ Cloud>

  <PluginComponent
    id = "edu.umd.cs.findbugs.bugReporter.SuppressMultithreaded">
    <Description> 멀티 스레드의 정확성 문제를 억제하는 </ Description>
    <Details> 모든 멀티 스레드의 정확성 문제를 억제합니다 </ Details>
    </ PluginComponent>

  <PluginComponent
    id = "edu.umd.cs.findbugs.bugReporter.SuppressI18N">
    <Description> 국제화 문제를 억제하는 </ Description>
    <Details> 모든 국제화 문제를 억제합니다 </ Details>
    </ PluginComponent>
  
  <PluginComponent
    id = "edu.umd.cs.findbugs.bugReporter.SelectivelySuppressI18N">
    <Description> 선택한 패키지를 제외한 모든 국제화 문제를 억제하는 </ Description>
    <Details> i18n.properties 자원에 지정된 이외의 모든 국제화 문제를 억제합니다 </ Details>
  </ PluginComponent>

  <PluginComponent
    id = "edu.umd.cs.findbugs.bugReporter.MaxRank14">
    <Description> 순위 14 저쪽에 모든 문제를 억제하는 </ Description>
    <Details> 순위 14 저쪽에 모든 문제를 억제합니다 </ Details>
  </ PluginComponent>

  <PluginComponent
    id = "edu.umd.cs.findbugs.bugReporter.SuppressMalicious">
    <Description> 악성 코드 취약점 경고를 억제하는 </ Description>
    <Details> 악성 코드 취약점 경고를 억제합니다 </ Details>
    </ PluginComponent>
    
  <! -
  ************************************************** ********************
  Categories (replacing the BugCategoryDe​​scriptions.properties file)
  ************************************************** ********************
  ->

  <BugCategory category="CORRECTNESS">
    <Description> 정확성 </ Description>
    <Abbreviation> C </ Abbreviation>
    <Details> 버그의 가능성 - 아마도 개발자가 의도하지 않은 코드가있는 명백한 코딩 실수.
      우리는 낮은 오 탐지율을 위해 노력합니다.
    </ Details>
  </ BugCategory>

  <BugCategory category="NOISE">
    <Description> 가짜 랜덤 노이즈 </ Description>
    <Abbreviation> N </ Abbreviation>
    <Details> 가짜 랜덤 노이즈 : 소프트웨어 실제 버그를 발견하는 것이 아니라, 데이터 마이닝 실험의 컨트롤로 유용 할 의도했습니다.
    </ Details>
  </ BugCategory>

  <BugCategory category="SECURITY">
    <Description> 보안 </ Description>
    <Abbreviation> S </ Abbreviation>
    <Details> 원격에서 사용할 수있는 보안 취약점을 만들 수 신뢰할 수없는 입력을 사용하고 있습니다.
    </ Details>
  </ BugCategory>

  <BugCategory category="BAD_PRACTICE">
    <Description> 배드 사례 </ Description>
    <Abbreviation> B </ Abbreviation>
    <Details> 권장 또는 필수 코딩 사례 위반입니다. 예를 들어, hashCode 및 equals 문제 cloneable 관용구 버려진 예외 Serializable 문제, finalize의 오용 등.
      일부 그룹은 배드 사례를 걱정하지 않을지도 모르지만, 우리는 정확한 해석을하려고 노력합니다.
    </ Details>
  </ BugCategory>

  <BugCategory category="STYLE">
    <Description> 위험한 코드 </ Description>
    <Abbreviation> D </ Abbreviation>
    <Details> 혼란 코드, 변칙적 인 코드 자체를 오류로 인도하는 방법으로 작성된 코드.
      예를 들어, 로컬 변수에 잘못된 할당 switch 구문의 폴 통해 확인되지 않은 캐스트, null로 알고있는 값의 중복 null 검사 등입니다.
      더 고장을 받아 들였습니다.
  FindBugs의 이전 버전에서는이 범주 Style로 알려져있었습니다.
</ Details>
  </ BugCategory>

  <BugCategory category="PERFORMANCE">
    <Description> 성능 </ Description>
    <Abbreviation> P </ Abbreviation>
    <Details> 반드시 잘못되었다는 것은 아니고, 효율이 나쁠지도 모른다 코드 </ Details>
  </ BugCategory>

  <BugCategory category="MALICIOUS_CODE">
    <Description> 악성 코드 취약점 </ Description>
    <Abbreviation> V </ Abbreviation>
    <Details> 신뢰할 수없는 코드로부터의 공격에 취약 코드 </ Details>
  </ BugCategory>

  <BugCategory category="MT_CORRECTNESS">
    <Description> 멀티 스레드의 정확성 </ Description>
    <Abbreviation> M </ Abbreviation>
    <Details> 스레드, 잠금, volatile에 관련 코드의 결함 </ Details>
  </ BugCategory>

  <BugCategory category="I18N">
    <Description> 국제화 </ Description>
    <Abbreviation> I </ Abbreviation>
    <Details> 국제화 및 지역에 관계가있는 코드의 결함 </ Details>
    <! - DM_CONVERT_CASE is the only core bug pattern in this category ->
  </ BugCategory>

  <BugCategory category="EXPERIMENTAL">
    <Description> 실험용 </ Description>
    <Abbreviation> X </ Abbreviation>
    <Details> 실험용으로 완전히 조사되지 않은 버그 패턴 </ Details>
    <! - DM_CONVERT_CASE is the only core bug pattern in this category ->
  </ BugCategory>


  <! -
  ************************************************** ********************
  Detectors
  ************************************************** ********************
   ->
  <Detector class="edu.umd.cs.findbugs.detect.InitializeNonnullFieldsInConstructor">
    <Details>
<! [CDATA [
<p> Finds nonnull fields that are not written to in constructors.
이 검출기는 생성자에서 기록되지 않는 비 null 필드를 발행합니다.
</ p>
]]>
     </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IntCast2LongAsInstant">
    <Details>
<! [CDATA [
<p>
이 검출기는 신기원으로부터 밀리 초를 설명하는 32 비트 값의 사용법을 발견합니다.
</ p>
]]>
     </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.TrainLongInstantfParams">
    <Details>
<! [CDATA [
<p>
이 검출기는 신기원으로부터 밀리 초를 설명하는 64 비트 값 매개 변수의 데이터베이스를 구축합니다.
</ p>
]]>
     </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.InconsistentAnnotations">
    <Details>
<! [CDATA [
<p>
이 검출기는 형식 한정자가 직접 적용되는 메소드 매개 변수와 그 메서드 매개 변수의 사용 사이에서 모순을 발견합니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.AtomicityProblem">
    <Details>
<! [CDATA [
<p>
이 검출기는 원자 적으로 실행되지 않는 병행 추상화에 대해 연산 (예를 들어, get / put) 시퀀스를 발견합니다.
</ p>
]]>
     </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.SynchronizationOnSharedBuiltinConstant">
    <Details>
<! [CDATA [
<p>
이 검출기는 공유 된 임베디드 상수 (예 : String)의 동기화를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.SynchronizeAndNullCheckField">
    <Details>
<! [CDATA [
<p>
이 검출기는 동기화 된 필드를 null 체크하는 코드 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>


  <Detector class="edu.umd.cs.findbugs.detect.CheckImmutableAnnotation">
    <Details>
<! [CDATA [
<p>
이 검출기는 net.jcip.annotations.Immutable로 어노테이션 된 클래스의 규칙 위반을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.VarArgsProblems">
    <Details>
<! [CDATA [
<p>
이 검출기는 J2SE 5.0의 가변 인자에 기인하는 문제를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteJCIPAnnotation">
    <Details>
<! [CDATA [
<p>
이 검출기는 net.jcip.annotations 패키지에서 주석을 기록합니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteDirectlyRelevantTypeQualifiers">
    <Details>
<! [CDATA [
<p>
이 검출기는 방법을 분석 할 관련 형식 한정자에주의합니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.BuildInterproceduralCallGraph">
    <Details>
<! [CDATA [
<p>
이 검출기는 프로 시저 간 호출 그래프를 구축합니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.BuildObligationPolicyDatabase">
    <Details>
<! [CDATA [
<p>
이 검출기는 FindUnsatisfiedObligation 탐지기에 의해 사용되는 의무의 종류와 방법의 데이터베이스를 구축합니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.NoteSuppressedWarnings">
    <Details>
<! [CDATA [
<p>
이 검출기는 edu.umd.cs.findbugs.annotations.NoteSuppressWarnings 주석의 사용법에 따라 경고를 억제합니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteAnnotationRetention">
    <Details>
<! [CDATA [
<p>
이 검출기는 Retention 주석을 기록합니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteSyntheticElements">
    <Details>
<! [CDATA [
<p>
이 검출기는 합성 클래스, 메소드, 필드 등을 기록합니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Methods">
    <Details>
<! [CDATA [
<p>
이 검출기는 다른 검출기 사용하기 위해 분석 된 클래스에 정의 된 모든 메소드의 데이터베이스를 구축합니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReflectiveClasses">
    <Details>
<! [CDATA [
<p>
이 검출기는 어떤 클래스가. class 개체에 대한 상수 참조를 가지고 있는지 확인하려고 시도합니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CalledMethods">
    <Details>
<! [CDATA [
<p>
이 검출기는 다른 검출기 사용하기 위해 분석 된 클래스에서 호출되는 모든 메서드의 데이터베이스를 구축합니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FunctionsThatMightBeMistakenForProcedures">
    <Details>
<! [CDATA [
<p>
이 검출기는 클래스의 새로운 인스턴스를 반환하는 방법이 불변 클래스를 찾습니다.
그 메소드가 불려가는 곳 인스턴스를 변화 시키면 사고가 일어날지도 모릅니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ConfusionBetweenInheritedAndOuterMethod">
    <Details>
<! [CDATA [
<p>
이 검출기는 상속 된 메소드와 외부의 메소드와의 잠재적 혼동을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteCheckReturnValueAnnotations">
    <Details>
<! [CDATA [
<p>
이 검출기는 메소드의 반환 값을 확인하기 위해 주석을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizeOnClassLiteralNotGetClass">
    <Details>
<! [CDATA [
<p>
이 검출기는 클래스 리터럴 대신 getClass 결과 동기화하는 코드를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FieldItemSummary">
    <Details>
<! [CDATA [
<p>
이 검출기는 무엇이 필드에 저장되었는지에 대한 요약 정보를 생성합니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteNonNullAnnotations">
    <Details>
<! [CDATA [
<p>
이 검출기는 메서드, 필드, 매개 변수 @ NonNull 주석을 찾습니다.
null지도 모른다 값이 null이 아닌 값 만 사용되어야 문맥에서 사용 된 때 FindNullDeref 검출기 경고를 생성하는 데 사용됩니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.NoteUnconditionalParamDerefs">
    <Details>
<! [CDATA [
<p>
이 검출기는 무조건 매개 변수의 null 값이 사용되는지 확인하기 위해 응용 프로그램의 모든 메소드를 분석합니다.
이 정보는 null 값이 메소드에 전달 될지도 모른다 호출 장소를 발견하기 위해 후 분석 경로로 사용됩니다.
</ p>
<p>
저속 탐지기입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.NoteNonnullReturnValues​​">
    <Details>
<! [CDATA [
<p>
이 검출기는 어떤 메소드가 항상 비 null 값을 반환 있는지 확인하려면 응용 프로그램에서 모든 방법을 분석합니다.
</ p>
]]>
    </ Details>
  </ Detector>


  <Detector class="edu.umd.cs.findbugs.detect.BooleanReturnNull">
    <Details>
<! [CDATA [
<p>
이 검출기는 명시 적으로 null 값을 반환 반환 형식이 Boolean 방법을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.BadUseOfReturnValue">
    <Details>
<! [CDATA [
<p>
이 검출기는 메소드의 반환 값이 null 아닌가 확인 된 후 버려지는 사례를 찾습니다.
</ p>

]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InheritanceUnsafeGetResource">
    <Details>
<! [CDATA [
<p>
이 검출기는 클래스가 다른 패키지의 클래스가 확장된다면 의외의 결과를 가져올 수있는 <code> this.getClass (). getResource (...) </ code>의 사용을 찾고 있습니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InfiniteRecursiveLoop">
    <Details>
<! [CDATA [
<p>
이 검출기는 무한 재귀 루프를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InfiniteLoop">
    <Details>
<! [CDATA [
<p>
이 검출기는 무한 루프를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.VolatileUsage">
    <Details>
<! [CDATA [
<p>
이 검출기는 volatile 필드의 사용법 버그 패턴을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.EmptyZipFileEntry">
<Details>
<! [CDATA [
<p>
이 검출기는 빈 zip 파일 항목 작성을 찾습니다.
</ p>
<p>
중속 탐지기입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.UncallableMethodOfAnonymousClass">
    <Details>
<! [CDATA [
<p>
이 검출기는 무명 내부 클래스에 정의 된 메소드에서 슈퍼 클래스의 메서드를 재정의하는 것을 의도하고 있지만 실제로는 재정이없는 방법을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.DontUseEnum">
    <Details>
<! [CDATA [
<p>
이 검출기는 필드와 메소드가 J2SE 5.0의 키워드 인 assert와 enum을 이름으로 사용하지 않는 것을 확인합니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.URLProblems">
    <Details>
<! [CDATA [
<p>
<code> java.net.URL </ code>의 equals 및 hashCode 메소드는 도메인 이름을 확인합니다.
그 결과, 이러한 연산은 매우 비쌀 수 있습니다. 이 검출기는 메소드가 호출 될 수없는 위치를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FinalizerNullsFields">
    <Details>
<! [CDATA [
<p>
이 검출기는 클래스의 필드를 null로 종료자를 찾습니다.
어떤 방법으로도 필드를 null하는 것은 효과가없고, 가비지 컬렉터의 도움이되지 않습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.CrossSiteScripting">
    <Details>
<! [CDATA [
<p>
이 검출기는 XSS 취약점 자명으로 노골적인 사례를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.RepeatedConditionals">
    <Details>
<! [CDATA [
<p>
이 검출기는 <code> (x == 5 | | x == 5) </ code>와 같은 반복되는 조건 테스트를 포함하는 코드를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.CallToUnsupportedMethod">
    <Details>
<! [CDATA [
<p>
이 검출기는 지원되지 않는 메서드 호출을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FormatStringChecker">
    <Details>
<! [CDATA [
<p>
이 검출기는 잘못된 형식 문자열을 확인합니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EqualsOperandShouldHaveClassCompatibleWithThis">
    <Details>
<! [CDATA [
<p>
이 검출기는 <code> equals </ code> 메소드를 정의하고있는 클래스와 호환되지 않는 클래스의 인스턴스를 피연산자하고 확인 <code> equals </ code> 메소드를 체크합니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.TestingGround">
    <Details>
<! [CDATA [
<p>
이 검출기는 새로운 탐지기를 테스트하기위한 훅입니다. 일반적으로이 검출기는 아무것도하지 않습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.TestingGround2">
    <Details>
<! [CDATA [
<p>
이 검출기는 새로운 탐지기를 테스트하기위한 훅입니다. 일반적으로이 검출기는 아무것도하지 않습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.LostLoggerDueToWeakReference">
    <Details>
<! [CDATA [
<p>
이 검출기는 OpenJDK 1.6에서 다르게 동작하는 코드를 찾습니다. OpenJDK 1.6에서는 <code> Logger </ code>를 유지하는 데 약 참조가 사용됩니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.TestingGround2">
    <Details>
<! [CDATA [
<p>
이 검출기는 새로운 탐지기를 테스트하기위한 훅입니다. 일반적으로이 검출기는 아무것도하지 않습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.Noise">
    <Details>
<! [CDATA [
<p>
이 검출기는 임의의 신호를 생성합니다. 메소드에 의해 실행되는 연산의 해시 값을 기준으로 경고합니다.
이러한 경고는 소프트웨어에서 실제 버그를 발견하는 것이 아니라, 데이터 마이닝 실험의 컨트롤로 유용 할 목적으로 가짜 랜덤 노이즈입니다.
</ p>
<p>
이 검출기는 새로운 탐지기를 테스트하기위한 훅입니다. 일반적으로이 검출기는 아무것도하지 않습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.NoiseNullDeref">
    <Details>
<! [CDATA [
<p>
null 참조 해제를위한 노이즈가 탐지기입니다. 코드의 문제를 찾아내는 방법으로 사용하기 때문에 신는 경고의 타당성 또는 예측 능력의 실험에서 컨트롤로 유용 할 의도했습니다.
</ p>
]]>
    </ Details>
  </ Detector>


  <Detector class="edu.umd.cs.findbugs.detect.HugeSharedStringConstants">
    <Details>
<! [CDATA [
<p>
이 검출기는 여러 클래스 파일에 복제 된 문자열 상수를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.DoInsideDoPrivileged">
    <Details>
<! [CDATA [
<p>
이 검출기는 doPrivileged 블록 안에서 실행해야 코드를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.ResolveAllReferences">
    <Details>
<! [CDATA [
<p>
이 검출기는 모든 참조 호출이 해결되는 것을 확인합니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.SwitchFallthrough">
    <Details>
<! [CDATA [
<p>
이 검출기는 폴 스루가 switch 문을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindFieldSelfAssignment">
    <Details>
<! [CDATA [
<p>
이 검출기는 필드가 동일한 필드의 값을 읽어 할당되는 위치를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindSelfComparison">
    <Details>
<! [CDATA [
<p>
이 검출기는 값이 자체적으로 비교되는 위치를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindSelfComparison2">
    <Details>
<! [CDATA [
<p>
이 검출기는 값이 자체적으로 비교되는 위치를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindNonShortCircuit">
    <Details>
<! [CDATA [
<p>
이 검출기는 비 단락 논리 연산자의 추정 사용을 찾습니다 (<code> | | </ code>와 <code> && </ code> 대신 <code> | </ code>와 < code> & </ code>).
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.DontCatchIllegalMonitorStateException">
    <Details>
<! [CDATA [
<p>
이 검출기는 IllegalMonitorStateException을 잡을 try-catch 블록을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindFloatMath">
    <Details>
<! [CDATA [
<p>
이 검출기는 부동 소수점 연산의 사용을 찾습니다.
</ p>
<p>
중속 탐지기입니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CloneIdiom">
    <Details>
<! [CDATA [
<p>
이 검출기는 Cloneable 클래스를 쓰는 관용구 위반 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ComparatorIdiom">
    <Details>
<! [CDATA [
<p>
이 검출기는 <code> Comparator </ code>를 구현하는 클래스를 작성하기위한 관용구 위반 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DroppedException">
    <Details>
<! [CDATA [
<p>
이 검출기는 예외를 캐치하고 있는데 아무것도하지 않는 코드를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.LoadOfKnownNullValue">
    <Details>
<! [CDATA [
<p>
이 검출기는 null로 알고있는 값의 판독을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.DumbMethodInvocations">
    <Details>
<! [CDATA [
<p>
이 검출기는 방법 (예 : <code> substring (0) </ code>)에 전달되는 잘못된 인수를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DumbMethods">
    <Details>
<! [CDATA [
<p>
이 검출기는 인수가없는 String 생성자 같은 무의미한 메서드 호출을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.NumberConstructor">
    <Details>
<! [CDATA [
<p>
이 검출기는 Number 생성자의 원시 형의 인수 호출을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindDoubleCheck">
    <Details>
<! [CDATA [
<p>
이 검출기는 더블 체크 락의 인스턴스를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindFinalizeInvocations">
    <Details>
<! [CDATA [
<p>
이 검출기는 <code> finalize </ code> 메서드 호출과 다른 종료 자 관련 문제를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindHEmismatch">
    <Details>
<! [CDATA [
<p>
이 검출기는 <code> hashCode </ code> 메소드와 <code> equals </ code> 메서드 정의의 문제를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.OverridingEqualsNotSymmetrical">
    <Details>
<! [CDATA [
<p>
이 검출기는 동치 관계가 대칭이지 않을지도 모른다 슈퍼 클래스의 <code> equals </ code> 메서드를 재정의 <code> equals </ code> 메서드를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindNakedNotify">
    <Details>
<! [CDATA [
<p>
이 검출기는 가변 객체의 상태를 변경하는 것 같다하지 <code> notify </ code> 메서드 호출을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindReturnRef">
    <Details>
<! [CDATA [
<p>
이 검출기는 가변 정적 데이터를 반환하는 방법을 찾고 있습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindRunInvocations">
    <Details>
<! [CDATA [
<p>
이 검출기는 <code> Thread.run () </ code>의 호출을 찾습니다.
</ p>
<p>
고속 탐지기입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindSpinLoop">
    <Details>
<! [CDATA [
<p>
이 검출기는 조건식이나 루프에서 호출되지 <code> wait </ code> 메서드를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindTwoLockWait">
    <Details>
<! [CDATA [
<p>
이 검출기는 두 개 이상의 잠금을 보유하고있는 상태에서 <code> wait </ code> 메서드 호출을 찾습니다.
</ p>
<p>
저속 탐지기입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUnconditionalWait">
    <Details>
<! [CDATA [
<p>
이 검출기는 조건문이나 루프없는 <code> wait </ code> 메서드 호출을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUninitializedGet">
    <Details>
<! [CDATA [
<p>
이 검출기는 생성자에서 초기화되지 않은 필드의 읽기를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUnsyncGet">
    <Details>
<! [CDATA [
<p>
이 검출기는 set 메소드는 동기화하고 get 메소드는 동기화하지 get 및 set 메서드를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.InitializationChain">
    <Details>
<! [CDATA [
<p>
이 검출기는 잠재적 순환 클래스 초기화 종속성을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.IteratorIdioms">
    <Details>
<! [CDATA [
<p>
이 검출기는 반복자 클래스 정의에 대한 문제를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.LockedFields">
    <Details>
<! [CDATA [
<p>
이 검출기는 잠금 대해 일관성없는 방식으로 액세스되는 필드를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.EqStringTest">
    <Details>
<! [CDATA [
<p>
이 검출기는 ==와! = 연산자를 사용하는 String 객체의 비교를 찾습니다.
</ p>
]]>
</ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.MutableLock">
    <Details>
<! [CDATA [
<p>
이 검출기는 변경된 필드로부터 읽어 들인 객체 동기화를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.SynchronizingOnContentsOfFieldToProtectField">
    <Details>
<! [CDATA [
<p>
이 검출기는 필드 업데이트를 가드하는 필드를 동기화하는 것 같다 코드를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.MutableStaticFields">
    <Details>
<! [CDATA [
<p>
이 검출기는 악의적 인 코드가 변경 될지도 모른다 static 필드를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.Naming">
    <Details>
<! [CDATA [
<p>
이 검출기는 의심;있게 명명 된 메서드를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.ReadReturnShouldBeChecked">
    <Details>
<! [CDATA [
<p>
이 검출기는 반환 값이 무시되는 <code> InputStream.read () </ code> 또는 <code> InputStream.skip () </ code>의 호출을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.SerializableIdiom">
    <Details>
<! [CDATA [
<p>
이 검출기는 Serializable 클래스의 구현에 잠재적 인 문제를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.StartInConstructor">
    <Details>
<! [CDATA [
<p>
이 검출기는 스레드를 시작하는 생성자를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindBadForLoop">
    <Details>
<! [CDATA [
<p>
이 검출기는 잘못된 for 루프를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ExplicitSerialization">
    <Details>
<! [CDATA [
<p>
이 검출기는이 클래스가 정말 직렬화된다는 증거로 readObject와 writeObject 통해 명시 적 직렬화를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UnreadFields">
    <Details>
<! [CDATA [
<p>
이 검출기는 값이 결코 읽히지 않은 필드를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.WaitInLoop">
    <Details>
<! [CDATA [
<p>
이 검출기는 루프없는 <code> wait </ code> 메서드 호출을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.BCPMethodReturnCheck">
    <Details>
<! [CDATA [
<p>
이 검출기는 반환 값이 의심;있게 무시하는 메서드 호출을 찾습니다.
</ p>
<p>
저속 탐지기입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindNullDeref">
    <Details>
<! [CDATA [
<p>
이 검출기는 NullPointerException가 발생할지도 모른다 위치를 찾습니다.
또한 null에 대한 참조 값의 중복 비교를 찾습니다.
</ p>
<p>
저속 탐지기입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindNullDerefsInvolvingNonShortCircuitEvaluation">
    <Details>
<! [CDATA [
<p>
이 검출기는 NullPointerException가 발생할지도 모른다 위치를 찾습니다.
비 단락 평가의 사용은 흔한 기법 실패의 원인이됩니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindOpenStream">
    <Details>
<! [CDATA [
<p>
이 검출기는 메서드에서 탈출하지 않고 메서드에서 모든 경로에서 청산되도록 보이지 않는 IO 스트림 개체를 찾습니다.
<p>
저속 탐지기입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.PreferZeroLengthArrays">
    <Details>
<! [CDATA [
<p>
이 검출기는 배열 또는 명시 적으로 null 참조를 반환하는 방법을 찾고 있습니다.
길이가 0 인 배열을 반환하는 것은 이런 맥락에서 null 참조를 반환하는 것보다 바람직합니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUselessControlFlow">
    <Details>
<! [CDATA [
<p>
이 검출기는 효과가 제어 흐름 문을 ​​찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUnreleasedLock">
    <Details>
<! [CDATA [
<p>
이 검출기는 JSR-166 (<code> java.util.concurrent </ code>)의 락을 획득했는데 메서드에서 모든 경로에서 해제되지 않는 잠금을 찾습니다.
</ p>
<p>
중속 탐지기입니다.
</ p>
<p>
이 탐지기를 사용하기 위해 보조 클래스 경로에 <code> java.util.concurrent </ code> 패키지 (또는 패키지 자체를 분석하고있다)이 필요하다는 것을주의하십시오.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindRefComparison">
    <Details>
<! [CDATA [
<p>
이 검출기는 2 개의 참조 값을 ==와! = 연산자 비교하여 위치를 찾습니다.
<code> java.lang.String </ code>와 같은 형식의 클래스에서 참조 값을 비교하는 것은 일반적 잘못입니다.
</ p>
</ p>
저속 탐지기입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindMismatchedWaitOrNotify">
    <Details>
<! [CDATA [
<p>
이 검출기는 현재 잠겨있는 개체에서 생성되도록 보이지 않는 <code> wait </ code> 메서드 <code> notify </ code> 메서드 <code> notifyAll </ code> 메서드 호출 찾습니다.
</ p>
</ p>
중속 탐지기입니다.
<p>
이 검출기는 아직 개발 중이며, 너무 많은 오류 검출이 발생하므로 비활성화되어 있습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindEmptySynchronizedBlock">
    <Details>
<! [CDATA [
<p>
이 검출기는 빈 synchronized 블록을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindInconsistentSync2">
    <Details>
<! [CDATA [
<p>
이 검출기는 잠금 대해 일관성없는 방식으로 액세스되는 필드를 찾습니다.
</ p>
<p>
저속 탐지기입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindLocalSelfAssignment2">
    <Details>
<! [CDATA [
<p>
이 검출기는 로컬 변수의 자기 대입을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.IncompatMask">
    <Details>
<! [CDATA [
<p>
이 검출기는 의심 비트 논리 식을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.LazyInit">
    <Details>
<! [CDATA [
<p>
이 검출기는 필드가 volatile 않은 게으른 필드의 초기화를 찾습니다.
</ p>
<p>
중속 탐지기입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindJSR166LockMonitorenter">
    <Details>
<! [CDATA [
<p>
이 검출기는 JSR-166의 잠금에서 실행되는 일반 동기화를 찾습니다.
</ p>
<p>
중속 탐지기입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUncalledPrivateMethods">
    <Details>
<! [CDATA [
<p>
이 검출기는 호출되지 않는 private 메서드를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.StringConcatenation">
    <Details>
<! [CDATA [
<p>
이 검출기는 +를 사용한 루프의 문자열 연결을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.InefficientToArray">
    <Details>
<! [CDATA [
<p>
이 검출기는 <code> toArray (T [] a) </ code> 메서드에 길이가 0의 배열을 전달하여 컬렉션을 배열로 변환하는 코드를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.InvalidJUnitTest">
    <Details>
<! [CDATA [
<p>
이 검출기는 잘못된 JUnit 테스트를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.BadlyOverriddenAdapter">
    <Details>
<! [CDATA [
<p>
이 검출기는 <code> Adapter </ code> 클래스를 확장하여 잘못된 서명으로 <code> Listener </ code> 메서드를 재정의하는 코드를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.BadResultSetAccess">
    <Details>
<! [CDATA [
<p>
이 검출기는 열 인덱스는 0의 <code> ResultSet </ code>의 ge​​tXXX 또는 setXXX 메소드의 호출을 찾습니다.
<code> ResultSet </ code>의 열 인덱스 번호는 1에서 시작하기 때문에 이것은 항상 실수입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.SuperfluousInstanceOf">
    <Details>
<! [CDATA [
<p>
이 검출기는 판정이 정적으로 수행 될 수있는 instanceof 연산자를 사용하는 형식 검사를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.BadAppletConstructor">
    <Details>
<! [CDATA [
<p>
이 검출기는 Applet 스텁에 의존하는 부모 Applet 메서드를 호출 Applet 생성자를 찾습니다.
이 스텁은 <code> init </ code> 메서드 전에 초기화되지 않기 때문에 이러한 방법은 생성자에서 실패합니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.SuspiciousThreadInterrupted">
    <Details>
<! [CDATA [
<p>
이 검출기는 비 정적 맥락에서 <code> Thread.interrupted () </ code>의 호출을 찾습니다.
그것이 <code> Thread.currentThread (). interrupted () </ code>에서 호출된다면 소용없는 일이므로 <code> Thread.interrupted () </ code>를 사용합니다.
그러나 <code> interrupted </ code> 메소드는 항상 현재 스레드에서 호출되기 때문에 모든 스레드 개체에서 호출하는 것은 거의 틀림없이 잘못된 것입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindSqlInjection">
    <Details>
<! [CDATA [
<p>
이 검출기는 switch 문에서 상수 문자열이 아닌 무언가가 인수로 전달되는 SQL 문장 <code> execute </ code> 메서드 호출을 찾기 위해 데이터 흐름 분석을 사용합니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindDeadLocalStores">
    <Details>
<! [CDATA [
<p>
이 검출기는 이후 결코 읽히지 않는 로컬 변수에 대입을 찾습니다.
</ p>
<p>
중속 탐지기입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindMaskedFields">
    <Details>
<! [CDATA [
<p>
이 검출기는 메소드로 정의 된 지역 변수에 의해 숨겨진 필드를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.WrongMapIterator">
    <Details>
<! [CDATA [
<p>
이 검출기는 <code> keySet </ code> 반복자로부터 추출 된 키를 사용하여 <code> Map </ code> 항목의 값에 액세스하는 코드를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.InstantiateStaticClass">
    <Details>
<! [CDATA [
<p>
이 검출기는 static 메서드 만 정의되지 않은 클래스의 객체를 생성하는 코드를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.RuntimeExceptionCapture">
    <Details>
<! [CDATA [
<p>
이 검출기는 블록의 코드에서 예외가 발생하지 않는데 예외 catch catch 절을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindFloatEquality">
    <Details>
<! [CDATA [
<p>
이 검출기는 부동 소수점 해당 식을 찾습니다.
</ p>
<p>
고속 탐지기입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUnsatisfiedObligation">
    <Details>
<! [CDATA [
<p>
이 검출기는 메서드에서 모든 경로에서 정리되지 않은 입출력 스트림과 데이터베이스 자원을 찾습니다.
</ p>
<p>
저속 탐지기입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.UnnecessaryMath">
    <Details>
<! [CDATA [
<p>
이 검출기는 계산 결과가 정적에 알려진 값을 계산하기 위해 <code> java.lang.Math </ code>의 static 메소드를 호출하는 코드를 찾습니다.
대신 상수를 사용하는 것이 더 빠르고, 때로는보다 정확합니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindCircularDependencies">
    <Details>
<! [CDATA [
<p>
이 검출기는 클래스 간의 순환 종속성을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>
<Detector class="edu.umd.cs.findbugs.detect.RedundantInterfaces">
    <Details>
<! [CDATA [
<p>
이 검출기는 슈퍼 클래스와 동일한 인터페이스를 구현한다고 선언하는 서브 클래스를 찾습니다.
슈퍼 클래스에서 인터페이스를 구현하므로, 서브 클래스에서 같은 일을하는 것은 불필요하다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.MultithreadedInstanceAccess">
    <Details>
<! [CDATA [
<p>
이 검출기는 Struts 프레임 워크를 구현하기위한 잠재적 인 문제를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.PublicSemaphores">
    <Details>
<! [CDATA [
<p>
이 검출기는 동기화하고 <em> this </ em>에 <code> wait </ code> 메서드 <code> notify </ code> 메서드 <code> notifyAll </ code> 메소드를 사용하는 public 클래스를 찾습니다.
이것은 public 클래스의 동기화 구현을 폭로하는 것입니다. public 클래스의 이용자는 이용자의 클래스에서 public 클래스의 인스턴스를 동기화 개체로 사용 될 수 있습니다.
이것은 기반 구현에 재앙을 가져온다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.MethodReturnCheck">
    <Details>
<! [CDATA [
<p>
이 검출기는 반환 값이 의심;있게 무시하는 메서드 호출을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.IDivResultCastToDouble">
    <Details>
<! [CDATA [
<p>
이 검출기는 정수 나누기의 결과가 double로 캐스팅 된 위치를 찾습니다.
종종 의미 된 것은 정수 피연산자를 double로 캐스팅하고 나누기를 수행하는 것이 었습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindBadCast2">
    <Details>
<! [CDATA [
<p>
이 검출기는 데이터 흐름 분석을 사용하여 객체 참조의 잘못된 캐스팅을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindNonSerializableStoreIntoSession">
    <Details>
<! [CDATA [
<p>
이 검출기는 HTTP 세션에 직렬화 된 객체의 저장을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>
  
  <Detector class="edu.umd.cs.findbugs.detect.FindUseOfNonSerializableValue">
    <Details>
<! [CDATA [
<p>
이 검출기는 그들이 직렬화 가능한지를 요구하는 문맥에서 비 Serializable 개체의 사용 방법을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>
  
  <Detector class="edu.umd.cs.findbugs.detect.FindNonSerializableValuePassedToWriteObject">
    <Details>
<! [CDATA [
<p>
이 검출기는 <code> ObjectOutput </ code>의 <code> writeObject </ code> 메서드에 전달 된 직렬화 된 객체를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.BadSyntaxForRegularExpression">
    <Details>
<! [CDATA [
<p>
이 검출기는 잘못된 구문이 정규 표현식을 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindPuzzlers">
    <Details>
<! [CDATA [
<p>
이 검출기는 Joshua Bloch와 Neal Gafter가 "Java Puzzlers"에서 언급 한 다방면에 걸친 사소한 오류를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindSleepWithLockHeld">
    <Details>
<! [CDATA [
<p>
이 검출기는 잠금을 보유하고있는 상태에서 <code> Thread.sleep () </ code>의 호출을 찾습니다.
</ p>
<p>
저속 탐지기입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.DuplicateBranches">
    <Details>
<! [CDATA [
<p>
이 검출기는 두 분기에 같은 코드로 인해 분기가 해제 된 if / else 또는 switch 문을 찾습니다.
이것은 두 분기에 동일한 코드를 복사 및 붙여 넣기하는 것이 한쪽 분기의 잘못된 논리의 원인이됩니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.InefficientMemberAccess">
    <Details>
<! [CDATA [
<p>
이 검출기는 소유 클래스의 private 필드에 기록하는 내부 클래스를 찾습니다.
이 경우, 컴파일러는 반드시이 필드에 쓸 사용되는 액세서 자 메서드를 생성합니다.
가시성을 protected로 완화하는 것은 직접 쓸 수 있도록합니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.XMLFactoryBypass">
    <Details>
<! [CDATA [
<p>
이 검출기는 XML 인터페이스를 구현 한 클래스의 인스턴스를 생성하는 코드를 찾습니다.
이러한 개체를 만드는 데 제공된 팩토리 패턴을 사용하는 것이 아니라, 특정 구현에 코드를 연결합니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.UselessSubclassMethod">
    <Details>
<! [CDATA [
<p>
이 검출기는 수퍼 클래스에 정의 된 메소드를 구현하여 슈퍼 클래스의 메소드에 파라미터를 그​​대로 전달하는만큼의 서브 클래스를 찾습니다.
이러한 방법은 삭제할 수 있습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.ConfusedInheritance">
    <Details>
<! [CDATA [
<p>
이 검출기는 protected 멤버를 선언하는 final 클래스를 찾습니다.
이 클래스는 파생시킬 수 없기 때문에, protected 멤버의 사용은 올바르지 않습니다.
권한은 구성원의 올바른 의도를 표현하기 위해 public 또는 private으로 변경해야합니다.
</ p>
<p>
아마도 새로운 패러다임에 클래스 모두를 완전히 변경하는 것이 아니라, 클래스의 사용의 변화가 원인이되었습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.QuestionableBooleanAssignment">
    <Details>
<! [CDATA [
<p>
이 검출기는 조건식 변수에 리터럴 부울 단순한 대입을 찾습니다.
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.TrainNullReturnValues​​">
    <Details>
<! [CDATA [
<p>
이 검출기는 어느 메소드가 null을 반환 여부를 결정하여 파일에 저장합니다.
결과 파일은 null 참조 해제 탐지기의 정확성을 향상시키기 위해 후속 경로로 사용되는지도 모릅니다.
이것은 교육 경로이므로 경고가보고되지 않습니다.
</ p>
<p>
저속 탐지기입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.TrainUnconditionalDerefParams">
    <Details>
<! [CDATA [
<p>
이 검출기는 어느 메소드가 null 값의 매개 변수를 무조건 사용할지 결정하여 파일에 저장합니다.
결과 파일은 null 참조 해제 탐지기의 정확성을 향상시키기 위해 후속 경로로 사용되는지도 모릅니다.
이것은 교육 경로이므로 경고가보고되지 않습니다.
</ p>
<p>
저속 탐지기입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.TrainFieldStoreTypes">
    <Details>
<! [CDATA [
<p>
이 검출기는 필드에 저장되는 형태를 분석하여 데이터베이스에 저장합니다.
데이터베이스는 형 분석을보다 정확하게하기 위해 후속 경로로 사용되는지도 모릅니다.
</ p>
<p>
저속 탐지기입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.TrainNonNullAnnotations">
    <Details>
<! [CDATA [
<p>
이 검출기는 @ NonNull와 @ PossiblyNull 주석을 모아 데이터베이스에 저장합니다.
</ p>
<p>
고속 탐지기입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.CheckCalls">
    <Details>
<! [CDATA [
<p>
이 검출기는 FindBugs에서 메서드 호출의 해​​결을 디버깅하는 데 있습니다.
</ p>
<p>
사용하지 마십시오.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindBugsSummaryStats">
    <Details>
<! [CDATA [
<p>
  이 검출기는 분석 과정의 요약 통계 정보를 수집합니다.
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.TestASM">
    <Details>
<! [CDATA [
<p>
이 검출기는 ASM 바이트 코드 분석 프레임 워크를 사용한 FindBugs 탐지기를 쓰는 방법을 보여준다 예제입니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUnrelatedTypesInGenericContainer">
    <Details>
<! [CDATA [
<p>
이 검출기는 인수의 형태가 컬렉션의 매개 변수에 관련되어 있는지 확인하기 위해 <code> java.lang.Object </ code>을받을 총칭 형 컬렉션 메서드 호출의 인수를 봅니다.
무관 한 클래스 형으로 인수 결코 컬렉션에 포함되는 것은 아닙니다.
예를 들어, <code> foo </ code>가 <code> List <String> </ code>에서 <code> bar </ code>가 <code> StringBuffer </ code>이라면 <code> foo.contains (bar ) </ code>의 호출은 항상 false를 반환하게됩니다.
</ p>
고속 탐지기입니다.
</ p>
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.StaticCalendarDetector">
    <Details>
<! [CDATA [
<p>
<code> Calendar </ code>는 멀티 스레드에서의 사용은 본질적으로 안전하지 않기 때문에,이 검출기는 <code> java.util.Calendar </ code> 나 <code> java.text.DateFormat < / code> (서브 클래스도)의 static 필드에 대해 경고합니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.TestDataflowAnalysis">
    <Details>
<! [CDATA [
<p>
이것은 데이터 흐름 분석을 테스트하는 데에만 사용되는 내부 탐지기입니다.
</ p>
<p>
기본적으로 활성화되지 않습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.CheckTypeQualifiers">
    <Details>
<! [CDATA [
<p>
이 검출기는 JSR-305의 형식 한정자 주석에서 특정 된 속성의 위반을 확인합니다.
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.AppendingToAnObjectOutputStream">
    <Details>
<! [CDATA [
<p>
이 검출기는 객체 출력 스트림에 추가하려는 시도를 찾습니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.CheckExpectedWarnings">
    <Details>
<! [CDATA [
<p>
이 검출기는 @ ExpectedWarning와 @ NoWarning 주석을 확인합니다.
이 검출기는 FindBugs를 테스트하기 위해 사용됩니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.DontIgnoreResultOfPutIfAbsent">
    <Details>
<! [CDATA [
<p>
이 검출기는 <code> ConcurrentMap </ code>의 <code> putIfAbsent </ code> 메소드의 결과가 무시된다면, 두 번째 인수로 전달 된 값이 재사용되지 않도록해야합니다 .
</ p>
]]>
    </ Details>
  </ Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReadOfInstanceFieldInMethodInvokedByConstructorInSuperclass">
    <Details>
<! [CDATA [
<p>
  이 검출기는 슈퍼 클래스에 대한 생성자에서 호출하는 방법을 확인합니다.
</ p>
]]>
    </ Details>
  </ Detector>

  <Detector class="edu.umd.cs.findbugs.detect.DefaultEncodingDetector">
    <Details>
<! [CDATA [
<p>
이 검출기는 사용자의 기본 플랫폼 인코딩을 사용하여 바이트 String (또는 String로부터 바이트)로 변환하는 메서드 호출을 확인합니다.
이것은 응용 프로그램의 동작이 플랫폼 사이에서 다른 원인이됩니다.
 </ p>
]]>
    </ Details>
  </ Detector>
  
  <! -
  ************************************************** ********************
  BugPatterns
  ************************************************** ********************
  ->

  <BugPattern type="SKIPPED_CLASS_TOO_BIG">
    <ShortDescription> 분석하려면 너무 큰 클래스 </ ShortDescription>
    <LongDescription> {0}는 분석하려면 너무 큽니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 유효 처리 할 수​​ 없을만큼 큽니다. 또한 오류로 인해 완전히 분석되지 않았습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NOISE_NULL_DEREFERENCE">
    <ShortDescription> null 값 사용에 대한 거짓 경고 </ ShortDescription>
    <LongDescription> null 값 사용에 대한 거짓 경고입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
가짜 경고입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NOISE_METHOD_CALL">
    <ShortDescription> 메서드 호출에 대한 거짓 경고 </ ShortDescription>
    <LongDescription> 메서드 호출 {2}에 대한 거짓 경고입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
가짜 경고입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NOISE_FIELD_REFERENCE">
    <ShortDescription> 필드 참조에 대한 거짓 경고 </ ShortDescription>
    <LongDescription> 필드 참조 {2}에 대한 거짓 경고입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
가짜 경고입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NOISE_OPERATION">
    <ShortDescription> 연산에 대한 거짓 경고 </ ShortDescription>
    <LongDescription> 연산 {2}에 대한 거짓 경고입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
가짜 경고입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE">
    <ShortDescription> 정확하게 표시되지 않는 double에서 구축 된 BigDecimal </ ShortDescription>
    <LongDescription> {4}에서 BigDecimal이 구축되어 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 10 진수 숫자로 잘 변환되지 double 값에서 BigDecimal을 만들고 있습니다.
예를 들어, Java에서 new BigDecimal (0.1)라고 쓰면 0.1으로 정확하게 동일한 BigDecimal (스케일 1, 스케일 없음의 값이 1)가 작성된다고 생각할지도 모르지만
실제로 0.1000000000000000055511151231257827021181583404541015625과 같습니다.
</ p>
<p>
아마 BigDecimal.valueOf (double d) 메소드의 사용이 바람직하다. BigDecimal (예 BigDecimal.valueOf (0.1)는 0.1을줍니다)을 작성하기 위해서는 double 문자열 표현을 사용합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_DOH">
    <ShortDescription> D' oh! 무의미한 메서드 호출 </ ShortDescription>
    <LongDescription> D' oh! {2.nameAndSignature} 무의미한 메서드 호출. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 실용적인 메서드 호출은 검사에서 명백한 이유에서 의미가 없습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD">
    <ShortDescription> EasyMock 방법에 쓸모없는 / 무의미한 호출 </ ShortDescription>
    <LongDescription> EasyMock 메소드 {2}의 호출은 쓸모없는 / 무의미합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 호출은 어떤 개체도 EasyMock 메서드에 전달하지 않으므로 아무것도하지 않습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS">
    <ShortDescription> 코어 풀 사이즈가 0 ScheduledThreadPoolExecutor 만들기 </ ShortDescription>
    <LongDescription> 코어 풀 사이즈가 0 ScheduledThreadPoolExecutor를 작성하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
코어 풀 사이즈가 0 <code> ScheduledThreadPoolExecutor </ code>는 결코 아무것도 실행하지 않습니다.
최대 풀 크기 변경은 무시됩니다. <br>
(<a href="http://java.sun.com/javase/ja/6/docs/ja/api/java/util/concurrent/ScheduledThreadPoolExecutor.html#ScheduledThreadPoolExecutor(int)"> Javadoc </ a>)
</ p>
]]>
</ Details>
  </ BugPattern>

  <BugPattern type="DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR">
    <ShortDescription> ScheduledThreadPoolExecutor의 최대 풀 크기를 바꾸려는 헛된 시도 </ ShortDescription>
    <LongDescription> ScheduledThreadPoolExecutor의 최대 풀 크기를 바꾸려고하는 것은 헛된 시도입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> ScheduledThreadPoolExecutor </ code>는 <code> ThreadPoolExecutor </ code>에서 상속됩니다 만, 상속 된 튜닝 메소드의 일부는 유용하지 않습니다.
특히 corePoolSize thread와 안 바운드 형식의 큐를 사용하는 고정 사이즈 풀로서 동작하기 때문에, maximumPoolSize 조정은 유용한 효과가 없습니다. <br>
(<a href="http://java.sun.com/javase/ja/6/docs/ja/api/java/util/concurrent/ScheduledThreadPoolExecutor.html"> Javadoc </ a>)
</ p>

]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_UNSUPPORTED_METHOD">
    <ShortDescription> 지원되지 않는 메서드 호출 </ ShortDescription>
    <LongDescription> 지원되지 않는 메서드 {2}를 호출합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메소드 호출의 모든 대상이 <code> UnsupportedOperationException </ code>가 발생합니다.
</ p>

]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_EMPTY_DB_PASSWORD">
    <ShortDescription> 빈 데이터베이스 암​​호 </ ShortDescription>
    <LongDescription> 빈 데이터베이스 경로 조치 단어입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 공백 또는 빈 암호를 사용하여 데이터베이스 연결을 만들 수 있습니다.
이것은 데이터베이스가 암호로 보호되어 있지 않음을 보여줍니다.
</ p>

]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="DMI_CONSTANT_DB_PASSWORD">
    <ShortDescription> 하드 코드 된 상수 데이터베이스 암​​호 </ ShortDescription>
    <LongDescription> 하드 코드 된 상수 데이터베이스 암​​호입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 하드 코드 된 상수 암호를 사용하여 데이터베이스 연결을 만들 수 있습니다.
소스 코드 또는 컴파일 된 코드에 액세스 할 수있는 사람이라면 누구나 쉽게 암호를 알 수 버립니다.
</ p>

]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="HRS_REQUEST_PARAMETER_TO_COOKIE">
    <ShortDescription> 신뢰할 수없는 입력에서 형성된 HTTP cookie </ ShortDescription>
    <LongDescription> HTTP cookie는 신뢰할 수없는 입력에서 형성되었습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 신뢰할 수없는 HTTP 매개 변수를 사용하여 HTTP 쿠키를 구축하고 있습니다.
이 쿠키가 HTTP 응답에 추가된다면, HRS (HTTP 응답 스뿌릿팅구) 취약점을 가능하게합니다. <br>
자세한 내용은 <a href="http://en.wikipedia.org/wiki/HTTP_response_splitting"> http://en.wikipedia.org/wiki/HTTP_response_splitting </ a>를 참조하십시오.
</ p>
<p>
FindBugs는 HRS의 가장 노골적이고 사소한 경우 만 찾습니다.
FindBugs 뭔가를 발견했다면 거의 틀림없이 FindBugs보고하지 더 취약 것이다.
HRS를 걱정한다면, 상용 정적 분석 도구 또는 침투 테스트 도구의 사용을 심각하게 고려해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="HRS_REQUEST_PARAMETER_TO_HTTP_HEADER">
    <ShortDescription> HTTP 응답 스뿌릿팅구 취약점 </ ShortDescription>
    <LongDescription> HTTP 헤더 출력 HTTP 매개 변수를 그대로 씁니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 HTTP 헤더에 HTTP 매개 변수를 그대로 씁니다. 이것은 HRS (HTTP 응답 스뿌릿팅구) 취약점을 가능하게합니다. <br>
자세한 내용은 <a href="http://en.wikipedia.org/wiki/HTTP_response_splitting"> http://en.wikipedia.org/wiki/HTTP_response_splitting </ a>를 참조하십시오.
</ p>
<p>
FindBugs는 HRS의 가장 노골적이고 사소한 경우 만 찾습니다.
FindBugs 뭔가를 발견했다면 거의 틀림없이 FindBugs보고하지 더 취약 것이다.
HRS를 걱정한다면, 상용 정적 분석 도구 또는 침투 테스트 도구의 사용을 심각하게 고려해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="PT_RELATIVE_PATH_TRAVERSAL">
    <ShortDescription> 서블릿의 상대 경로 탐색 </ ShortDescription>
    <LongDescription> 상대 경로 탐색. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
소프트웨어는 제한된 디렉토리에 있어야 경로를 구축하기 위해 HTTP 요청 매개 변수를 사용하지만, 매개 변수는 디렉토리 외부에있는 위치에 해결할 수있다 ".."와 같은 시퀀스를 적절히 해제하지 않습니다.
자세한 내용은 <a href="http://cwe.mitre.org/data/definitions/23.html"> http://cwe.mitre.org/data/definitions/23.html </ a>를 참조 하십시오.
</ p>
<p>
FindBugs는 상대 경로 탐색의 가장 노골적이고 사소한 경우 만 찾습니다.
FindBugs 뭔가를 발견했다면 거의 틀림없이 FindBugs보고하지 더 취약 것이다.
상대 경로 탐색을 고려한다면, 상용 정적 분석 도구 또는 침투 테스트 도구의 사용을 심각하게 고려해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="PT_ABSOLUTE_PATH_TRAVERSAL">
    <ShortDescription> 서블릿의 절대 경로 탐색 </ ShortDescription>
    <LongDescription> 절대 경로 탐색. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
소프트웨어는 제한된 디렉토리에 있어야 경로를 구축하기 위해 HTTP 요청 매개 변수를 사용하지만, 매개 변수는 디렉토리 외부에있는 위치에 해결할 수있다 "/ abs / path"와 같은 절대 경로 순서를 제대로 해제하지 않습니다.
자세한 내용은 <a href="http://cwe.mitre.org/data/definitions/36.html"> http://cwe.mitre.org/data/definitions/36.html </ a>를 참조 하십시오.
</ p>
<p>
FindBugs는 상대 경로 탐색의 가장 노골적이고 사소한 경우 만 찾습니다.
FindBugs 뭔가를 발견했다면 거의 틀림없이 FindBugs보고하지 더 취약 것이다.
상대 경로 탐색을 고려한다면, 상용 정적 분석 도구 또는 침투 테스트 도구의 사용을 심각하게 고려해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER">
    <ShortDescription> 반사 형 크로스 사이트 스크립팅 취약점 서블릿 </ ShortDescription>
    <LongDescription> 서블릿의 출력에 HTTP 매개 변수를 그대로 씁니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 서블릿의 출력에 HTTP 매개 변수를 그대로 씁니다. 이것은 반사 형 XSS (크로스 사이트 스크립팅) 취약점을 가능하게합니다. <br>
자세한 내용은 <a href="http://en.wikipedia.org/wiki/Cross-site_scripting"> http://en.wikipedia.org/wiki/Cross-site_scripting </ a>를 참조하십시오.
</ p>
<p>
FindBugs는 XSS의 가장 노골적이고 사소한 경우 만 찾습니다.
FindBugs 뭔가를 발견했다면 거의 틀림없이 FindBugs보고하지 더 취약 것이다.
XSS를 걱정한다면, 상용 정적 분석 도구 또는 침투 테스트 도구의 사용을 심각하게 고려해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="XSS_REQUEST_PARAMETER_TO_SEND_ERROR">
    <ShortDescription> 반사 형 크로스 사이트 스크립팅 취약점이 오류 페이지에있는 서블릿 </ ShortDescription>
    <LongDescription> 서블릿 오류 페이지에 HTTP 매개 변수를 그대로 씁니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 서블릿 오류 페이지에 <code> HttpServletResponse.sendError </ code>를 사용하여 HTTP 매개 변수를 그대로 씁니다.
신뢰할 수없는 입력을 반환 반사 형 XSS (크로스 사이트 스크립팅) 취약점을 가능하게합니다. <br>
자세한 내용은 <a href="http://en.wikipedia.org/wiki/Cross-site_scripting"> http://en.wikipedia.org/wiki/Cross-site_scripting </ a>를 참조하십시오.
</ p>
<p>
FindBugs는 XSS의 가장 노골적이고 사소한 경우 만 찾습니다.
FindBugs 뭔가를 발견했다면 거의 틀림없이 FindBugs보고하지 더 취약 것이다.
XSS를 걱정한다면, 상용 정적 분석 도구 또는 침투 테스트 도구의 사용을 심각하게 고려해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="XSS_REQUEST_PARAMETER_TO_JSP_WRITER">
    <ShortDescription> 반사 형 크로스 사이트 스크립팅 취약점 JSP </ ShortDescription>
    <LongDescription> JSP의 출력에 HTTP 매개 변수를 그대로 씁니다. {1.class} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 JSP의 출력에 HTTP 매개 변수를 그대로 씁니다. 이것은 XSS (크로스 사이트 스크립팅) 취약점을 가능하게합니다. <br>
자세한 내용은 <a href="http://en.wikipedia.org/wiki/Cross-site_scripting"> http://en.wikipedia.org/wiki/Cross-site_scripting </ a>를 참조하십시오.
</ p>
<p>
FindBugs는 XSS의 가장 노골적이고 사소한 경우 만 찾습니다.
FindBugs 뭔가를 발견했다면 거의 틀림없이 FindBugs보고하지 더 취약 것이다.
XSS에 대해 걱정하고 있다면 상용 정적 분석 도구 또는 침투 테스트 도구의 사용을 심각하게 고려해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SW_SWING_METHODS_INVOKED_IN_SWING_THREAD">
    <ShortDescription> Swing 메소드는 AWT 이벤트 디스패치 스레드에서 호출해야 </ ShortDescription>
    <LongDescription> Swing 메서드 호출 AWT 이벤트 디스패치 스레드에서 실행되어야합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
(<a href="http://web.archive.org/web/20090526170426/http://java.sun.com/developer/JDCTechTips/2003/tt1208.html"> From JDC Tech Tip </ a>) <br>
에 설명 된대로 Swing 방법, <code> show </ code> 메서드 <code> setVisible </ code> 메서드 <code> pack </ code> 메서드는 구조를 위해 관련 피어 만듭니다.
피어 만들기에서 시스템 이벤트 디스패치 스레드를 만듭니다.
이것이 문제가 될 수 있습니다. 왜냐하면 <code> pack </ code> 메소드와 <code> validate </ code> 메소드가 아직 처리 중에도 이벤트 디스패치 스레드가 수신기에 통보 할 수 있기 때문입니다.
이 상황은 두 개의 스레드가 Swing 구성 요소에 액세스 할 수 있습니다, 교착 상태 및 기타 스레딩 문제가 될 가능성이있는 심각한 결함입니다.
<code> pack </ code> 메서드 호출 구성 요소를 구체화시킨다. 실체화 때 이벤트 디스패치 스레드가 리스​​너에게 통지를 시작할 수 있습니다.
</ p>

]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="IL_INFINITE_LOOP">
    <ShortDescription> 명백한 무한 루프 </ ShortDescription>
    <LongDescription> 명백한 무한 루프입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 루프는 예외를 throw하는 이외의 방법으로 종료 할 수 없다고 생각합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="IL_INFINITE_RECURSIVE_LOOP">
    <ShortDescription> 명백한 무한 재귀 루프 </ ShortDescription>
    <LongDescription> 명백한 무한 재귀 루프입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 무조건 자신을 호출합니다. 이것은 스택 오버플로되는 무한 재귀 루프를 보여줍니다.
</ p>
]]>
    </ Details>
  </ BugPattern>


  <BugPattern type="IL_C​​ONTAINER_ADDED_TO_ITSELF">
    <ShortDescription> 컬렉션은 자신을 추가하고 </ ShortDescription>
    <LongDescription> 컬렉션은 자신을 추가합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
컬렉션은 자신을 추가합니다. 그 결과, hashCode를 계산하면 <code> StackOverflowException </ code>가 발생합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="VO_VOLATILE_REFERENCE_TO_ARRAY">
    <ShortDescription> 배열에 volatile 참조는 배열 요소를 volatile로 취급하지 </ ShortDescription>
    <LongDescription> {1}은 배열에 volatile 참조입니다. 배열 요소는 volatile로 간주되지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이것은 배열에 volatile 참조를 선언합니다. 그것은 당신이 원하는 것이 아닐지도 모릅니다.
배열에 volatile 참조는 배열에 대한 참조 읽기, 쓰기는 volatile로 취급되지만, 배열 요소는 volatile로 간주되지 않습니다.
배열 요소를 volatile로 처리하고자한다면, J2SE 5.0에서 제공되는 <code> java.util.concurrent </ code> 패키지 원자 배열 클래스를 사용해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="VO_VOLATILE_INCREMENT">
    <ShortDescription> volatile 필드에 증가는 원자가 아닌 </ ShortDescription>
    <LongDescription> volatile 필드 {2}을 증가하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 volatile 필드를 증가하고 있습니다.
volatile 필드의 증가는 원자는 없습니다.
여러 스레드가 동시에 필드를 증가하면 증가가 손실 될 수 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="UI_INHERITANCE_UNSAFE_GETRESOURCE">
    <ShortDescription> 클래스가 확장된다면 getResource 사용은 안전하지 않을지도 모른다 </ ShortDescription>
    <LongDescription> 클래스가 확장된다면 getResource 사용은 안전하지 않을지도 모릅니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스가 다른 패키지로 확장된다면 <code> this.getClass (). getResource (...) </ code>의 호출은 의외의 결과를 가져올 수 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_BOOLEAN_RETURN_NULL">
    <ShortDescription> 반환 형식이 Boolean 메서드를 명시 적으로 null을 반환하는 </ ShortDescription>
    <LongDescription> {1}는 반환 형식이 Boolean인데 명시 적으로 null을 반환합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
Boolean.TRUE, Boolean.FALSE, null을 반환하는 방법은 언제 사고가 일어나도 이상하지 않다입니다.
마치 부울 값을 반환 것처럼,이 메소드는 호출 될 수 있습니다.
그리고 컴파일러는 Boolean 값의 오토 언 박싱을 삽입합니다.
null 값이 반환된다면 NullPointerException이 발생하게됩니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

<BugPattern type="NP_NONNULL_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR">
    <ShortDescription> 비 null 필드는 초기화되지 않은 </ ShortDescription>
    <LongDescription> 비 null 필드 {2.name}는 {1}에 의해 초기화되지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
필드가 아닌 null로 표시되어 있지만, 생성자에서 기록되지 않습니다.
필드는 생성자 사이 다른 위치에서 초기화하거나 사용하기 전에 항상 초기화 될지도 모릅니다.
</ p>
]]>
       </ Details>
  </ BugPattern>

  <BugPattern type="NP_SYNC_AND_NULL_CHECK_FIELD">
    <ShortDescription> 같은 분야에서의 동기화와 null 체크 </ ShortDescription>
    <LongDescription> 필드 {2.givenClass}는 동기화하고 null 체크하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
필드는 동기화하고 있기 때문에 아마도 null이 아니라고 생각됩니다.
null 필드를 동기화하면 NullPointerException이 발생하며, null 체크는 의미가됩니다.
다른 필드에서 동기화하는 것이 좋습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RpC_REPEATED_CONDITIONAL_TEST">
    <ShortDescription> 조건 검사를 반복 </ ShortDescription>
    <LongDescription> 조건 테스트를 반복하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 조건 테스트가 두 번, 즉, 첫 번째 조건 테스트가 올바른 경우 두 번째 조건 테스트가 실행됩니다 (예 <code> x == 0 | | x == 0 </ code> ).
아마 두 번째 조건 테스트는 다른 의도 있습니다 (예 <code> x == 0 | | y == 0 </ code>).
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="TESTING">
    <ShortDescription> 테스트 </ ShortDescription>
    <LongDescription> 생성 된 테스트 경고입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 버그 패턴, 새로운, 가난하게 구현 된 버그 탐지기에 의해 생성 될뿐입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>


  <BugPattern type="TESTING1">
    <ShortDescription> 테스트 1 </ ShortDescription>
    <LongDescription> 생성 된 테스트 경고 1입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 버그 패턴, 새로운, 가난하게 구현 된 버그 탐지기에 의해 생성 될뿐입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>


  <BugPattern type="TESTING2">
    <ShortDescription> 테스트 2 </ ShortDescription>
    <LongDescription> 생성 된 테스트 경고 2입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 버그 패턴, 새로운, 가난하게 구현 된 버그 탐지기에 의해 생성 될뿐입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="TESTING3">
    <ShortDescription> 테스트 3 </ ShortDescription>
    <LongDescription> 생성 된 테스트 경고 3입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 버그 패턴, 새로운, 가난하게 구현 된 버그 탐지기에 의해 생성 될뿐입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="UNKNOWN">
    <ShortDescription> 알 수없는 버그 패턴 </ ShortDescription>
    <LongDescription> 알 수없는 버그 패턴입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
경고가 기록 된 데 FindBugs이 버그 패턴에 대한 설명을 찾을 수 없었기 때문에 경고를 설명 할 수 없습니다.
이것은 FindBugs 또는 그 설정 버그의 경우 만 발생시켜야합니다.
또는 분석 플러그인을 사용하여 생성된다면, 플러그인은 현재로드되지 않습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="AM_CREATES_EMPTY_ZIP_FILE_ENTRY">
    <ShortDescription> 빈 ZIP 파일 엔트리 만들기 </ ShortDescription>
    <LongDescription> 빈 ZIP 파일을 만들 수 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 <code> putNextEntry </ code> 메소드를 호출하여 <code> closeEntry </ code> 메서드를 바로 호출합니다.
이것은 빈 ZIP 파일 항목입니다.
항목 데이터는 <code> putNextEntry </ code> 메소드와 <code> closeEntry </ code> 메서드 호출 사이에서 ZIP 파일에 기록한다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="AM_CREATES_EMPTY_JAR_FILE_ENTRY">
    <ShortDescription> 빈 JAR 파일 엔트리 만들기 </ ShortDescription>
    <LongDescription> 빈 JAR 파일을 만들 수 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 <code> putNextEntry </ code> 메소드를 호출하여 <code> closeEntry </ code> 메서드를 바로 호출합니다.
이것은 하늘의 JAR 파일 엔트리가됩니다.
항목 데이터는 <code> putNextEntry </ code> 메소드와 <code> closeEntry </ code> 메서드 호출 사이에서 JAR 파일에 기록한다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="IMSE_DONT_CATCH_IMSE">
    <ShortDescription> 의심 IllegalMonitorStateException 잡기 </ ShortDescription>
    <LongDescription> IllegalMonitorStateException의 캐치 의심입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> IllegalMonitorStateException </ code>는 보통 설계 결함 (잠금을 보유하지 않는 개체에 <code> wait </ code> 메소드 또는 <code> notify </ code> 메소드를 호출)의 경우에만 슬로우됩니다.
</ p>
]]>
    </ Details>
  </ BugPattern>


  <BugPattern type="FL_MATH_USING_FLOAT_PRECISION">
    <ShortDescription> 부동 소수점 정밀도를 사용하여 계산을하고있다 </ ShortDescription>
    <LongDescription> 부동 소수점 정밀도를 사용하여 계산을하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 부동 소수점 정밀도를 사용하여 계산을하고 있습니다. 부동 소수점 정밀도는 매우 정확합니다.
예를 들어, <code> 16777216.0f + 1.0f = 16777216.0f </ code>.
대신 double의 사용을 고려하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="CN_IDIOM">
    <ShortDescription> Cloneable를 구현 한 클래스가 clone 메소드를 정의하지 않거나 사용하지 않는 </ ShortDescription>
    <LongDescription> 클래스 {0}은 Cloneable를 구현하고 있는데 clone 메소드를 정의하지 않거나 사용하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 <code> Cloneable </ code>를 구현하고 있는데 <code> clone </ code> 메소드를 정의하지 않거나 사용하지 않습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE">
    <ShortDescription> Cloneable을 구현하지 않는 클래스가 clone 메소드를 정의하고있다 </ ShortDescription>
    <LongDescription> {0}는 Cloneable을 구현하지 않았는데 clone 메소드를 정의하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 <code> Cloneable </ code>를 구현하고 있지 않는데 <code> clone </ code> 메소드를 정의하고 있습니다.
이것이 OK (예를 들어, 서브 클래스의 복제 구현을 스스로 제어하고 싶은 경우입니다) 상황도 있지만, 의도 한 것인지 확인하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="CN_IDIOM_NO_SUPER_CALL">
    <ShortDescription> clone 메소드가 super.clone ()를 호출하지 않은 </ ShortDescription>
    <LongDescription> {1}는 super.clone ()을 호출하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 비 final 클래스는 <code> super.clone () </ code>를 호출하지 <code> clone </ code> 메소드를 정의하고 있습니다.
클래스 <i> A </ i>이 서브 클래스 <i> B </ i>에 의해 확장되어 하위 <i> B </ i>이 <code> super.clone () </ code>을 호출한다면 클래스 <i> B </ i>의 <code> clone </ code> 메서드는 형식 <i> A </ i> 개체를 반환 할 가능성이 높습니다.
이것은 <code> clone </ code>을위한 범용 규약에 위반합니다.
</ p>
<p>
모든 <code> clone </ code> 메소드가 <code> super.clone () </ code>을 호출한다면 <code> Object.clone () </ code>가 호출되는 것이 보장되어 항상 올바른 형식 개체가 반환됩니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER">
    <ShortDescription> Java 이후 버전의 키워드 인 식별자를 사용하는 </ ShortDescription>
    <LongDescription> {1}은 변수 이름에 {2}을 사용하고 있지만, Java 이후 버전의 키워드입니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
식별자는 Java 이후 버전의 키워드로 예약되어있는 단어입니다.
코드는 Java 이후 버전에서 컴파일로 변경해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER">
    <ShortDescription> Java 이후 버전의 키워드 인 식별자를 사용하는 </ ShortDescription>
    <LongDescription> {1}은 Java보다 최신 버전의 키워드와 충돌합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 식별자는 Java 이후 버전의 키워드로 사용됩니다.
이 코드와 API를 참조하는 어떤 코드도 Java 이후 버전에서 컴파일로 변경해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DE_MIGHT_DROP">
    <ShortDescription> 예외를 버리고 있을지도 모른다 방법 </ ShortDescription>
    <LongDescription> {1} {2}을 버리고 있을지도 모릅니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 예외를 버리고 있을지도 모릅니다.
일반적으로 캐치 한 예외는 어떠한 방법으로 처리 또는보고해야한다, 또는 메소드로부터 throw해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DE_MIGHT_IGNORE">
    <ShortDescription> 예외를 무시하고 있을지도 모른다 방법 </ ShortDescription>
    <LongDescription> {1} {2}을 무시하고 있을지도 모릅니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메소드는 예외를 무시하고 있을지도 모릅니다.
일반적으로 예외는 어떠한 방법으로 처리 또는보고해야한다, 또는 메소드로부터 throw해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DP_DO_INSIDE_DO_PRIVILEGED">
    <ShortDescription> doPrivileged 블록에서 호출 할 메소드 </ ShortDescription>
    <LongDescription> {2}의 호출 doPrivileged 블록에서 호출해야합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 보안 권한 검사가 필요한 메서드를 호출합니다.
이 코드에 보안 권한이 부여하더라도 보안 권한이없는 코드에서 호출된다면 doPrivileged 블록 내에서 수행해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DP_DO_INSIDE_DO_PRIVILEDGED"> <! - misspelled for backward compatibility ->
    <ShortDescription> Method invoked that should be only be invoked inside a doPrivileged block </ ShortDescription>
    <LongDescription> invocation of {2}, which should be invoked from within a doPrivileged block, in {1} </ LongDescription>
    <Details>
<! [CDATA [
<p> This code invokes a method that requires a security permission check.
  If this code will be granted security permissions, but might be invoked by code that does not
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED">
    <ShortDescription> doPrivileged 블록 내에서 생성 될 클래스 로더 </ ShortDescription>
    <LongDescription> {1}은 doPrivileged 블록 내에서 클래스 로더 {2}을 작성해야합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 클래스 로더를 작성하고 있지만, 보안 관리자가 설치되어 있다면 권한이 있어야합니다.
이 코드가 보안 권한이없는 코드에서 호출된다면, 클래스 로더의 작성은 doPrivileged 블록 내에서 수행해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS">
    <ShortDescription> 불변 클래스의 필드는 final이 될 </ ShortDescription>
    <LongDescription> {0}는 불변으로 표시되어 있기 때문에 {1.givenClass}는 final로해야합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
클래스는 net.jcip.annotations.Immutable에서 어노테이션되어 있습니다.
Immutable 주석 규칙은 모든 필드를 final로하도록 의무화합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED">
    <ShortDescription> Thread 객체가 Runnable이 기대되는 곳에 전달되는 </ ShortDescription>
    <LongDescription> Thread 객체가 Runnable이 기대되는 곳에 전달되어 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
Thread 개체가 Runnable이 기대되는 메서드에 매개 변수로 전달됩니다.
이것은 매우 특별하고 논리적 오류를 보여 주거나, 의외의 행동의 원인이 될지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_COLLECTION_OF_URLS">
    <ShortDescription> URL의 Map 및 Set 끔찍한 성능이 될 수있는 </ ShortDescription>
    <LongDescription> {1}는 URL의 Map 또는 Set를 사용하고 있기 때문에, 심한 성능이 될 수 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메소드 또는 필드는 URL의 <code> Map </ code> 또는 <code> Set </ code>를 사용하고 있습니다.
URL의 <code> equals </ code>와 <code> hashCode </ code>은 도메인 이름의 해결을하며, 심한 성능이 될 수 있습니다. <br>
자세한 내용은 <a href="http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html"> http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and -hashcode-make.html </ a>를 참조하십시오. <br>
대신 <code> java.net.URI </ code>를 사용하는 것을 고려하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_BLOCKING_METHODS_ON_URL">
    <ShortDescription> URL의 equals 메소드와 hashCode 메소드는 차단 </ ShortDescription>
    <LongDescription> {2}의 호출은 도메인 이름 확인을 위해 차단합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
URL의 <code> equals </ code> 메소드와 <code> hashCode </ code> 메서드는 도메인 이름의 해결을하며, 심한 성능이 될 수 있습니다. <br>
자세한 내용은 <a href="http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html"> http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and -hashcode-make.html </ a>를 참조하십시오. <br>
대신 <code> java.net.URI </ code>를 사용하는 것이 좋습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION">
    <ShortDescription> 런타임 보유없이, 주석의 존재를 확인하기 위해 리플렉션을 사용할 수 없다 </ ShortDescription>
    <LongDescription> 런타임 보존이없는 주석 {3}의 존재를 확인하기 위해 리플렉션을 사용하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
주석은 <code> @ Retention (RetentionPolicy.RUNTIME) </ code>에서 어노테이션되어야 리플렉션 (예 <code> isAnnotationPresent (...) </ code> 메소드)를 사용하여 관찰 할 수 수 없습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DM_EXIT">
    <ShortDescription> System.exit (...)를 호출하는 방법 </ ShortDescription>
    <LongDescription> {1}는 System.exit (...)를 호출합니다. 이것은 Java 가상 머신 전체를 종료시켜 버립니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> System.exit (...) </ code>를 호출하는 것은 Java 가상 머신 전체를 종료시켜 버립니다.
그것이 적절한 경우에만 사용해야합니다.
<code> System.exit (...) </ code>의 호출 코드가 다른 코드에 의해 호출되는 것을 어렵거나 불가능합니다.
대신 RuntimeException을 던질 것을 고려하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DM_RUN_FINALIZERS_ON_EXIT">
    <ShortDescription> 위험한 방법 runFinalizersOnExit를 호출하는 방법 </ ShortDescription>
    <LongDescription> {1}은 위험한 방법 runFinalizersOnExit를 호출합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
어떤 이유가 있다고해도 결코 <code> System.runFinalizersOnExit </ code>와 <code> Runtime.runFinalizersOnExit </ code>를 호출하지 마십시오.
Java 라이브러리에서 가장 위험한 방법 중 하나입니다. - Joshua Bloch
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DM_STRING_CTOR">
    <ShortDescription> 비효율적 new String (String) 생성자를 호출하는 방법 </ ShortDescription>
    <LongDescription> {1}은 비효율적 new String (String) 생성자를 호출합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> java.lang.String (String) </ code> 생성자의 사용은 메모리를 낭비합니다.
그렇게 구축 된 객체와 매개 변수로 전달 된 <code> String </ code>는 기능적으로 구별 할 수 있기 때문입니다.
인수 <code> String </ code>를 그대로 사용하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DM_STRING_VOID_CTOR">
    <ShortDescription> 비효율적 new String () 생성자를 호출하는 방법 </ ShortDescription>
    <LongDescription> {1}은 비효율적 new String () 생성자를 호출합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
인수가없는 생성자를 사용하여 새 <code> java.lang.String () </ code> 개체를 만들 때 메모리를 낭비합니다.
그렇게하여 만들어진 개체 및 빈 문자열 상수 <code> ""</ code>는 기능적으로 구별 할 수 있기 때문입니다.
Java는 동일한 문자열 상수가 같은 <code> String </ code> 개체가 나타내는 것을 보증합니다.
따라서 직접 빈 문자열 상수를 사용해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DM_STRING_TOSTRING">
    <ShortDescription> String의 toString 메서드를 호출하는 방법 </ ShortDescription>
    <LongDescription> {1}는 String의 toString 메서드를 호출합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> String.toString () </ code>를 호출하는 것은 중복입니다. <code> String </ code>를 사용하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DM_GC">
    <ShortDescription> 명시적인 가비지 컬렉션 </ ShortDescription>
    <LongDescription> {1}은 가비지 수집을 강제하고 있습니다. 벤치 마크 코드를 제외하고 매우 의심 스럽습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 명시 적으로 가비지 컬렉션을 호출합니다. 벤치 마크의 특정 용도를 제외하고 매우 의심 스럽습니다.
</ p>
<p>
과거에 <code> close </ code> 메소드 나 <code> finalize </ code> 메서드 가비지 컬렉터를 명시 적으로 호출 상황은 거대한 성능 블랙홀의 원인이되었습니다.
가비지 컬렉션은 비싸게 수 있습니다. 수백, 수천의 가비지 수집을 강제하는 상황은 시스템의 정체를 가져올 것이다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DM_BOOLEAN_CTOR">
    <ShortDescription> 비효율적 Boolean 생성자를 호출하는 방법 </ ShortDescription>
    <LongDescription> {1}은 비효율적 Boolean 생성자를 호출합니다. 대신 Boolean.valueOf (...)를 사용하십시오. </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> java.lang.Boolean </ code>의 새로운 인스턴스를 만들 때 메모리를 낭비합니다.
<code> Boolean </ code> 객체는 불변, 2 개의 유용한 값 (<code> Boolean.TRUE </ code>와 <code> Boolean.FALSE </ code>)이 있습니다.
대신 <code> Boolean </ code> 객체를 생성하기 위해 <code> Boolean.valueOf </ code> 메서드 (또는 J2SE 5.0의 autoboxing)을 사용하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DM_NUMBER_CTOR">
    <ShortDescription> 비효율적 Number 생성자를 호출하는 방법 </ ShortDescription>
    <LongDescription> {1}은 비효율적 {2} 생성자를 호출합니다. 대신 {3}을 사용하십시오. </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> new Integer (int) </ code>의 사용은 항상 새로운 객체가 될 수 보장되어 있습니다.
이에 대해 <code> Integer.valueOf (int) </ code>는 컴파일러, 클래스 라이브러리, Java 가상 머신에서 값이 캐시됩니다.
캐시에 저장된 값을 사용하는 것은 인스턴스의 생성을 방지하고 코드는 더 빨라집니다.
</ p>
<p>
-128에서 127까지의 값은 해당 캐시 된 인스턴스를 가지게되어 있습니다.
그리고 <code> valueOf </ code> 메소드의 사용은 생성자를 사용하는 것보다 약 3.5 배 빠르다.
상수 범위를 벗어나는 값은 두 스타일의 성능은 동일합니다.
</ p>
<p>
클래스가 J2SE 5.0 이전의 Java 가상 머신과의 호환성이 필요하지 않다면, <code> Long </ code>, <code> Integer </ code>, <code> Short </ code>, <code> Character < / code>, <code> Byte </ code>의 인스턴스를 만들 때, 오토 박싱 또는 <code> valueOf </ code> 메서드를 사용하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="DM_FP_NUMBER_CTOR">
    <ShortDescription> 비효율적 부동 소수점 Number 생성자를 호출하는 방법 </ ShortDescription>
    <LongDescription> {1}은 비효율적 {2} 생성자를 호출합니다. 대신 {3}을 사용하십시오. </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> new Double (double) </ code>의 사용은 항상 새로운 객체가 될 수 보장되어 있습니다.
이에 대해 <code> Double.valueOf (double) </ code>는 컴파일러, 클래스 라이브러리, Java 가상 머신에서 값이 캐시됩니다.
캐시에 저장된 값을 사용하는 것은 인스턴스 생성을 방지하고 코드는 더 빨라집니다.
</ p>
<p>
클래스가 J2SE 5.0 이전의 Java 가상 머신과의 호환성이 필요하지 않다면, 자동 권투 또는 <code> Double </ code>, <code> Float </ code>의 <code> valueOf </ code> 메소드를 사용 하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DM_CONVERT_CASE">
    <ShortDescription> 호출 메서드 Locale 매개 변수의 사용을 검토하는 </ ShortDescription>
    <LongDescription> 지역화되지 않은 String.toUpperCase () 또는 String.toLowerCase ()를 사용하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
문자열이 플랫폼의 기본 인코딩을 사용하여 대소 문자로 변환됩니다.
국제 문자 사용하면 잘못된 변환이 될지도 모릅니다.
</ p>
</ p>
  <ul>
    <li> String.toUpperCase (Locale l) </ li>
    <li> String.toLowerCase (Locale l) </ li>
  </ ul>
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR">
    <ShortDescription> 원시 값이 3 항 연산자를 위해 언 박싱되어 변환되는 </ ShortDescription>
    <LongDescription> 원시적 형의 값이 3 항 연산자를 위해 언 박싱되어 변환됩니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
래핑 된 기본 값은 3 항 연산자 (<code> b? e1 : e2 </ code>)의 평가의 일환으로 다른 원시적 형에 언 박싱되어 변환됩니다.
Java 언어 사양에서는 <code> e1 </ code>와 <code> e2 </ code>가 래핑 된 수치라면 값은 언 박싱 된 공용 형식으로 변환 / 변환됩니다
(예를 들어, <code> e1 </ code>가 <code> Integer </ code>에서 <code> e2 </ code>가 <code> Float </ code>이라면 <code> e1 </ code>는 제거 권투 (<code> int </ code>로 변환)되어 <code> float </ code>로 변환, 복싱 (<code> Float </ code>로 변환)됩니다).
JLS 섹션 15.25을 참조하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BX_BOXING_IMMEDIATELY_UNBOXED">
    <ShortDescription> 기본 값이 권투되어 즉시 언 박싱되는 </ ShortDescription>
    <LongDescription> 기본 값이 권투되어 즉시 언 박싱됩니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
기본 값이 권투되어 즉시 언 박싱됩니다.
아마도 언 박싱 된 값이 필요한 곳​​에 수동으로 복싱을하고 있기 때문입니다.
그 결과, 컴파일러에 권투 기능을 취소하도록 강요하고 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BX_UNBOXING_IMMEDIATELY_REBOXED">
    <ShortDescription> 박싱 된 값을 언 박싱되어 즉시 다시 권투되는 </ ShortDescription>
    <LongDescription> 박싱 된 값을 언 박싱되어 즉시 다시 복싱됩니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
박싱 된 값을 언 박싱되어 즉시 다시 복싱됩니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION">
    <ShortDescription> 기본 값이 원시적 형의 변환을 위해 권투되고, 언 박싱되는 </ ShortDescription>
    <LongDescription> 기본 값이 원시적 형의 변환을 위해 권투되고, 언 박싱됩니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
기본 값이 생성자 복싱되어 즉시 다른 원시적 형태로 변환됩니다 (예 <code> new Double (d). intValue () </ code>).
원시 타입의 변환을 실행하십시오 (예 <code> (int) d </ code>).
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="DM_BOXED_PRIMITIVE_TOSTRING">
    <ShortDescription> toString 메소드를 호출하기 위해 원시 형의 래퍼 클래스의 인스턴스를 생성하고 </ ShortDescription>
    <LongDescription> toString 메소드를 호출하기 위해 원시 형의 래퍼 클래스의 인스턴스를 생성합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> toString </ code> 메소드를 호출하기 위해 원시 형의 래퍼 클래스의 인스턴스를 생성합니다.
보다 원시적 치를 인수에 취하는 static 인 <code> toString </ code> 메소드를 사용하는 것이 효율적입니다.
</ p>
  <table>
     <tr> <th> 바꾸기 전에 </ th> <th> 바꿀 </ th> </ tr>
     <tr> <td> new Integer (1). toString () </ td> <td> Integer.toString (1) </ td> </ tr>
     <tr> <td> new Long (1). toString () </ td> <td> Long.toString (1) </ td> </ tr>
     <tr> <td> new Float (1.0). toString () </ td> <td> Float.toString (1.0) </ td> </ tr>
     <tr> <td> new Double (1.0). toString () </ td> <td> Double.toString (1.0) </ td> </ tr>
     <tr> <td> new Byte (1). toString () </ td> <td> Byte.toString (1) </ td> </ tr>
     <tr> <td> new Short (1). toString () </ td> <td> Short.toString (1) </ td> </ tr>
     <tr> <td> new Boolean (true). toString () </ td> <td> Boolean.toString (true) </ td> </ tr>
  </ table>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DM_NEW_FOR_GETCLASS">
    <ShortDescription> 클래스 개체를 얻을만큼 인스턴스를 생성하는 방법 </ ShortDescription>
    <LongDescription> {1}는 클래스 객체를 얻기 위해서만 인스턴스를 생성합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
메서드는 클래스 객체를 얻기 위해 인스턴스를 생성하고 <code> getClass </ code> 메소드를 호출합니다.
클래스 리터럴 (<code> Foo.class </ code>)를 사용하는 것이 쉽습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DM_MONITOR_WAIT_ON_CONDITION">
    <ShortDescription> Condition에서 wait 메소드를 호출하는 </ ShortDescription>
    <LongDescription> Condition에서 wait 메소드를 호출합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 <code> java.util.concurrent.locks.Condition </ code> 개체 <code> wait </ code> 메소드를 호출합니다.
<code> Condition </ code> 개체를 대기시키기 위해서는 <code> Condition </ code> 인터페이스로 정의 된 <code> await </ code> 메서드를 사용해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RV_01_TO_INT">
    <ShortDescription> 0-1 난수 값은 정수 0으로 반올림 </ ShortDescription>
    <LongDescription> {1}은 0에서 1의 난수를 생성하지만, 정수 값 0으로 반올림됩니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
0에서 1의 난수 값은 정수 0으로 반올림됩니다.
아마 정수로 반올림 전에 다른하여 난수를 배수하고 싶었거나 <code> Random.nextInt (n) </ code> 메소드를 사용하고 싶었 지요.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DM_NEXTINT_VIA_NEXTDOUBLE">
    <ShortDescription> 정수 난수를 생성하기 위해서는 nextDouble 메소드는 아니고 nextInt 메소드를 사용하는 </ ShortDescription>
    <LongDescription> {1}은 정수 난수를 생성하기 위해 nextDouble 메소드를 사용하고 있습니다. nextInt 메소드를 사용하는 것이 효율적입니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> java.util.Random </ code>의 인스턴스 <code> r </ code>에서 <code> 0 </ code>에서 <code> n-1 </ code>의 난수를 생성 원한다면 경우 <code> (int) (r.nextDouble () * n) </ code> 대신 <code> r.nextInt (n) </ code>를 사용합니다.
</ p>
<p>
<code> nextInt </ code> 메소드의 인수는 정수가 아니면 안됩니다.
예를 들어, -99에서 0까지의 난수를 생성하고 싶다면, <code>-r.nextInt (100) </ code>를 사용하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE">
    <ShortDescription> SQL의 Statement의 execute 메소드에 정수가 아닌 문자열을 전달하는 </ ShortDescription>
    <LongDescription> {1}은 SQL의 Statement의 execute 메소드에 정수가 아닌 문자열을 전달합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 동적으로 생성되는 것 같다 문자열에서 SQL의 <code> Statement </ code>의 <code> execute </ code> 메소드를 호출합니다.
대신 <code> PreparedStatement </ code>를 사용하는 것이 좋습니다.
효율적이고, SQL 인젝션 공격에 강하다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING">
    <ShortDescription> PreparedStatement가 정수가 아닌 문자열에서 생성 된 </ ShortDescription>
    <LongDescription> PreparedStatement가 정수가 아닌 문자열에서 생성되고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 정수가 아닌 문자열에서 SQL의 <code> PreparedStatement </ code>를 작성하고 있습니다.
사용자의 확인되지 않은 오염 된 데이터가이 문자열을 만들 때 사용될 경우, PreparedStatement에서 예상 외로 원하지 않는 무언가를하기 위해 SQL 인젝션이 사용될 가능성이 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DM_USELESS_THREAD">
    <ShortDescription> 기본 빈 run 메소드를 사용하여 생성 된 스레드 </ ShortDescription>
    <LongDescription> {1} 기본 빈 run 메소드를 사용하여 스레드를 생성합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 스레드를 생성하고 있는데 <code> Thread </ code> 클래스에서 파생 된 <code> run </ code> 메소드도 지정하지 않으며 <code> Runnable </ code> 객체도 전달 하지 않습니다.
이 스레드는 시간 낭비입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DC_DOUBLECHECK">
    <ShortDescription> 필드의 더블 체크 가능성 </ ShortDescription>
    <LongDescription> 필드 {2} 번 확인을하고있을 가능성이 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 한 번 확인 잠금 인스턴스가 있을지도 모릅니다.
이 관용구는 Java의 메모리 모델은 올바르지 않습니다. <br>
자세한 내용은 <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html"> http://www.cs.umd.edu/ ~ pugh / java / memoryModel / DoubleCheckedLocking.html </ a>를 참조하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="FI_FINALIZER_NULLS_FIELDS">
    <ShortDescription> 종료자는 필드를 null로 </ ShortDescription>
    <LongDescription> {3}는 finalize 메소드에서 null을 설정합니다. {1.class} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 종료자는 필드를 null로하고 있습니다.
이것은 보통 실수로 가비지 컬렉터를 돕고 없습니다. 개체 어쨌든 가비지됩니다.
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="FI_FINALIZER_ONLY_NULLS_FIELDS">
    <ShortDescription> 종료자는 필드를 null로하면 </ ShortDescription>
    <LongDescription> {1} 필드를 null로하면됩니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 종료자는 필드를 null에하는 것 외에는 아무것도 없습니다.
이것은 완전히 무의미하고, 개체가 가비지되어 마무리되어 다시 가비지되는 것을 요구하고 있습니다.
<code> finalize </ code> 메소드를 제거해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="FI_PUBLIC_SHOULD_BE_PROTECTED">
    <ShortDescription> 종료자는 public이 아닌 protected로해야 </ ShortDescription>
    <LongDescription> {1}는 public입니다. protected하여야합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스의 <code> finalize </ code> 메소드는 public이 아닌 protected하여야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="FI_EMPTY">
    <ShortDescription> 빈 종료자는 제거해야 </ ShortDescription>
    <LongDescription> {1}은 비어 있기 때문에 제거해야합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
빈 <code> finalize </ code> 메소드는 쓸모가 없으니 삭제해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="FI_NULLIFY_SUPER">
    <ShortDescription> 종료자는 슈퍼 클래스의 finalizer를 해제하고 </ ShortDescription>
    <LongDescription> {1} {2}. finalize ()를 비활성화합니다. 이것은 의도 된 것입니까? </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 빈 <code> finalize </ code> 메서드는 명시 적으로 슈퍼 클래스에 정의 된 어떤 종료 자 효과도 해제합니다.
슈퍼 클래스에 정의 된 어떤 종료 자 작업도 수행되지 않습니다.
이것이 의도 한 것이 아닌 경우,이 메소드를 제거하십시오.
  </ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="FI_USELESS">
    <ShortDescription> 종료자는 슈퍼 클래스 종료자를 호출하는 만 </ ShortDescription>
    <LongDescription> {1}은 super.finalize ()를 호출 이외에 아무것도하지 않기 때문에 삭제하십시오. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 <code> finalize </ code> 메소드는 슈퍼 클래스의 <code> finalize </ code> 메소드를 호출 할뿐입니다.
중복이므로 삭제하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="FI_MISSING_SUPER_CALL">
    <ShortDescription> 종료자는 슈퍼 클래스 종료자를 호출하지 </ ShortDescription>
    <LongDescription> {1}은 super.finalize ()에 대한 호출이 발견되지 않기 때문에, {2}. finalize ()가 호출되지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 <code> finalize </ code> 메소드는 슈퍼 클래스의 <code> finalize </ code> 메소드를 호출하지 않습니다.
따라서 슈퍼 클래스에 정의 된 어떤 종료 자 작업도 수행되지 않습니다.
<code> super.finalize () </ code>의 호출을 추가하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="FI_EXPLICIT_INVOCATION">
    <ShortDescription> 종료자를 명시 적으로 호출 </ ShortDescription>
    <LongDescription> {1}은 명시 적으로 {2}를 호출합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메소드는 명시 적으로 개체 <code> finalize </ code> 메서드 호출이 있습니다.
종료자는 Java 가상 머신에 의해 한 번만 실행되게되어 있으므로, 이것은 잘못된 생각입니다.
</ p>
<p>
참조로 이어졌다 여러 개체를 종료 가능하게되면, Java 가상 머신은 모든 개체 <code> finalize </ code> 메소드를 호출합니다.
아마 다른 스레드에서 동시에입니다.
따라서 클래스 <i> X </ i>의 <code> finalize </ code> 메소드에서 <i> X </ i>에 의해 참조 된 개체의 <code> finalize </ code> 메소드를 호출 는 특히 잘못된 생각입니다.
왜냐하면 객체가 이미 다른 스레드에 의해 종료되는지도 모르기 때문입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS">
    <ShortDescription> equals 메소드는 호환되지 않는 피연산자를 체크하고있는 </ ShortDescription>
    <LongDescription> {1} {2.givenClass} 인 피연산자를 확인하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 <code> equals </ code> 메서드는 인수가 호환되지 않는 형식 (즉, 슈퍼 타입도 아니고, <code> equals </ code> 메소드를 정의하고있는 클래스의 슈퍼 타입도 서브 타입도 아니 클래스)인지 확인합니다.
예를 들어, <code> Foo </ code> 클래스의 <code> equals </ code> 메소드는 그렇게 보일지 모릅니다.
</ p>
<blockquote> <pre>
public boolean equals (Object o) {
    if (o instanceof Foo)
        return name.equals (((Foo) o). name);
    else if (o instanceof String)
        return name.equals (o);
    else return false;
}
</ pre> </ blockquote>
<p>
이것은 대칭적이고 추이이다 <code> equals </ code> 메소드를 구현하는 것은 매우 어렵 기 때문에 잘못된 관행으로 간주됩니다.
속성이 없으면 전혀 예상하지 못한 동작이 발생할 수 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="EQ_DONT_DEFINE_EQUALS_FOR_ENUM">
    <ShortDescription> 열거 공변 한 equals 메소드를 정의하고있다 </ ShortDescription>
    <LongDescription> 열거 {0}는 equals ({0.givenClass})를 정의하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 열거를 정의하고, 열거 동등한 개체 동일성을 사용하여 정의되어 있습니다.
열거 값을 위해 모두 이상한 <code> equals </ code> 메소드를 정의하는 것은 매우 잘못된 방법입니다.
두 가지 열거 값이 정상적인 <code> equals </ code> 메소드에서는 "등가 없다"고 판정되어 공변 인 <code> equals </ code> 메소드에서는 "등가"판정되기 때문입니다.
공변 인 <code> equals </ code> 메소드를 정의하지 마십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="EQ_SELF_USE_OBJECT">
    <ShortDescription> 공변 한 equals 메소드를 정의하고, Object.equals (Object)를 계승하고있다 </ ShortDescription>
    <LongDescription> {0}는 equals ({0.givenClass}) 메소드를 정의하고, Object.equals (Object)를 사용하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 모두 이상한 <code> equals </ code> 메소드를 정의하고 있습니다 만, <code> equals (Object) </ code> 메소드는 <code> java.lang.Object </ code> 클래스에서 상속합니다.
클래스는 <code> boolean equals (Object) </ code> 메소드를 정의해야한다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="EQ_OTHER_USE_OBJECT">
    <ShortDescription> Object.equals (Object)를 재정의하지 않는 equals 메소드의 정의 </ ShortDescription>
    <LongDescription> {0} {1.givenClass} 메소드를 정의하고, Object.equals (Object)를 사용하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 <code> equals </ code> 메소드를 정의하고 있습니다 만, <code> java.lang.Object </ code> 클래스의 <code> equals (Object) </ code> 메서드를 재정의하고 없습니다.
클래스는 <code> boolean equals (Object) </ code> 메소드를 정의해야한다.
  </ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="EQ_OTHER_NO_OBJECT">
    <ShortDescription> equals (Object) 메서드를 재정의하지 않는 equals 메소드의 정의 </ ShortDescription>
    <LongDescription> {0}는 equals (Object) 메서드를 재정의하지 {1.givenClass}을 정의합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 <code> equals </ code> 메소드를 정의하고 있습니다 만, <code> java.lang.Object </ code> 클래스의 <code> equals (Object) </ code> 메서드를 재정의하고 없습니다.
대신 수퍼 클래스에서 <code> equals (Object) </ code> 메소드를 상속하여 <code> boolean equals (Object) </ code> 메소드를 정의해야한다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="EQ_DOESNT_OVERRIDE_EQUALS">
    <ShortDescription> 슈퍼 클래스의 equals 메서드를 재정의하지 않는 클래스 </ ShortDescription>
    <LongDescription> {0} {1.givenClass}을 무시하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 <code> equals </ code> 메소드를 정의하고있는 클래스를 확장하여 필드를 추가하고 있는데 <code> equals </ code> 메소드를 정의하지 않습니다.
따라서이 클래스의 인스턴스의 등가성은 서브 클래스와 추가 된 필드의 정체성을 무시합니다.
이것이 의도 한 것으로, 게다가 <code> equals </ code> 메서드를 재정의해야 없는지 확인합니다.
비록 <code> equals </ code> 메서드를 재정의해야 아니더라도 서브위한 <code> equals </ code> 메소드가 <code> super.equals (o) </ code>을 호출 결과 반환 사실을 입증하기 위해, 어쨌든, <code> equals </ code> 메서드를 재정의하는 것을 고려하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="EQ_SELF_NO_OBJECT">
    <ShortDescription> 공변 인 equals 메소드의 정의 </ ShortDescription>
    <LongDescription> {0}는 equals ({0.givenClass}) 메소드를 정의하고 있는데 equals (Object)를 정의하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 모두 이상한 <code> equals </ code> 메소드를 정의하고 있습니다.
<code> java.lang.Object </ code>의 <code> equals </ code> 메서드를 올바르게 재정의하기 위해서는 <code> equals </ code> 메서드의 매개 변수 형식은 <code> java.lang . Object </ code>이어야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC">
    <ShortDescription> equals 메소드는 슈퍼 클래스의 equals 메서드를 재정의하고 있지만, 대칭이지 않을지도 모른다 </ ShortDescription>
    <LongDescription> {1.class}는 {2.class.givenClass}에서 equals 메소드를 오버 라드하고 있지만 대칭이지 않을지도 모릅니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 슈퍼 클래스의 <code> equals </ code> 메서드를 재정의 <code> equals </ code> 메소드를 정의하고 있습니다.
두 <code> equals </ code> 메서드는 두 개체가 동일한 지 여부의 판정에서 <code> instanceof </ code>를 사용하고 있습니다.
<code> equals </ code> 메소드는 대칭 적 (<code> a.equals (b) == b.equals (a) </ code>) 인 것이 중요하기 때문에 이것은 위험을 수반합니다.
<i> B </ i>이 <i> A </ i>의 하위 유형 인 <i> A </ i>의 <code> equals </ code> 메소드는 인수가 <code> instanceof A </ code >인지 확인합니다.
그리고 <i> B </ i>의 <code> equals </ code> 메소드는 인수가 <code> instanceof B </ code>인지 확인합니다.
이러한 메소드에 의해 정의 된 동치 관계가 대칭이 아닌 것입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="EQ_GETCLASS_AND_CLASS_CONSTANT">
    <ShortDescription> equals 메소드는 하위 유형에 실패 </ ShortDescription>
    <LongDescription> {1}은 하위 유형에 실패합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 서브 클래스에 의해 상속된다면 손상 <code> equlas </ code> 메소드가 있습니다.
<code> equals </ code> 메서드는 클래스 리터럴을 인수 클래스와 비교하고 있습니다 (예 <code> Foo </ code> 클래스에서 <code> Foo.class == o.getClass () < / code>와 같은 판정을하고 있습니다).
그것은 <code> this.getClass () == o.getClass () </ code>이 더 좋습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="EQ_UNUSUAL">
    <ShortDescription> 특별한 equals 메소드 </ ShortDescription>
    <LongDescription> {1}은 특별한 equals 메소드입니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스의 <code> equals </ code> 메서드는 인수의 형태가 <code> this </ code> 객체의 형식과 호환이 있음을 확인하기 위해, 우리가 알고있는 패턴 아무것도 하지 않습니다.
이 코드는 아무것도 잘못하지 않을지도 모르지만, 검토 가치가 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="EQ_COMPARING_CLASS_NAMES">
    <ShortDescription> equals 메소드는 클래스 객체가 아니라 클래스 이름을 비교하는 </ ShortDescription>
    <LongDescription> {1}는 클래스 객체가 아니라 클래스 이름을 비교하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 클래스 이름을 비교하여 두 개체가 동일한 클래스인지 확인합니다.
다른 클래스 로더에 의해로드 된 클래스라면 같은 이름으로 다른 클래스가있을 수 있습니다.
클래스 객체가 같은인지 확인하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="EQ_ALWAYS_TRUE">
    <ShortDescription> equals 메서드는 항상 true를 반환 </ ShortDescription>
    <LongDescription> {1}는 항상 true를 반환합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 항상 true를 반환 <code> equals </ code> 메소드를 정의하고 있습니다.
이것은 기발한하지만 그다지 좋은 방법이 아닙니다. 또한 <code> equals </ code> 메소드가 대칭 적이 지 않은 것을 의미합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="EQ_ALWAYS_FALSE">
    <ShortDescription> equals 메소드는 항상 false를 리턴 </ ShortDescription>
    <LongDescription> {1}는 항상 false를 돌려줍니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 항상 false를 반환 <code> equlas </ code> 메소드를 정의하고 있습니다.
이는 개체가 자신과 등가가 아닌 것을 의미하고,이 클래스의 유용한 Map과 Set을 만들 수 없습니다.
보다 근본적으로, <code> equals </ code> 메소드의 요구 사항 중 하나 인 사성을 충족하지 수 있습니다.
</ p>
<p>
아마 의도 된 것은 개체는 자신과 동일하다라는 개체 정체성입니다.
이것은 <code> Object </ code> 클래스에서 상속되는 동작입니다.
다른 슈퍼 클래스에서 상속되는 <code> equals </ code> 메서드를 재정의 할 필요가 있다면 다음과 같은 코드를 사용할 수 있습니다.
</ p>
<blockquote> <pre>
public boolean equals (Object o) {
    return this == o;
}
</ pre> </ blockquote>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="HSC_HUGE_SHARED_STRING_CONSTANT">
    <ShortDescription> 여러 클래스 파일에 복제 된 거대한 문자열 상수 </ ShortDescription>
    <LongDescription> 길이가 {2} 문자열 상수 {1} {3} 개의 클래스 파일에 복제되고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
거대한 문자열 상수가 여러 클래스 파일에 복제되고 있습니다.
final 필드가 문자열 상수로 초기화되고 Java 언어에 따라 다른 클래스에서 final 필드에 대한 모든 참조가 클래스 파일에 인라인되기 때문입니다.
</ p>
<p>
JDK는이 버그를 해결하고 크기를 1MB 줄일 수있었습니다. <br>
자세한 내용은 <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6447475"> JDK bug 6447475 </ a>를 참조하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_ARGUMENT_MIGHT_BE_NULL">
    <ShortDescription> null 인수를 확인하지 않는 방법 </ ShortDescription>
    <LongDescription> {1}는 null 인수를 확인하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메소드에 매개 변수가 null인지 확인하기 위하여 항상 확인되는 값으로 특정되었습니다.
하지만 null 체크를하지 않고 null 값이 이용되고 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT">
    <ShortDescription> equals 메서드는 null 인수를 확인하지 않은 </ ShortDescription>
    <LongDescription> {1}는 null 인수를 확인하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 <code> equals (Object) </ code> 메소드의 구현은 인수로 전달되는 null을 체크하고 있지 않기 때문에, <code> java.lang.Object.equals () </ code>에서 정의 된 약관을 위반하고 있습니다.
모든 <code> equals </ code> 메소드는 인수에 null이 전달 된 경우 false를 반환해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RV_NEGATING_RESULT_OF_COMPARETO">
    <ShortDescription> compareTo () / compare ()의 결과를 무효화하는 </ ShortDescription>
    <LongDescription> {1} {2}의 반환 값을 비활성화합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 compareTo 또는 compare 메소드의 반환 값을 비활성화합니다.
이것은 의심하거나 틀린 프로그래밍 방법입니다, 반환 값이 Integer.MIN_VALUE이므로 반환 값을 무효화하는 것은 결과의 부호를 사용하지 않습니다.
결과를 무효화하는 것이 아니라 피연산자의 순서를 반대로하여 같은 의도 한 결과를 얻을 수 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="CO_COMPARETO_RESULTS_MIN_VALUE">
    <ShortDescription> compareTo () / compare ()는 Integer.MIN_VALUE을 반환 </ ShortDescription>
    <LongDescription> {1}는 Integer.MIN_VALUE을 반환합니다. 반환 값을 해제 할 수 없습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
경우에 따라이 compareTo 또는 compare 메소드는 Integer.MIN_VALUE을 반환합니다. 그것은 매우 잘못된 방법입니다.
compareTo 메소드의 반환 값은 결과의 부호 만 중요합니다.
그러나 compareTo 메소드의 반환 값을 무효화 할 수 있습니다. 이것이 결과의 부호를 해제 할 것으로 예상합니다.
반환 값이 Integer.MIN_VALUE 인 경우를 제외하고 그렇게됩니다. Integer.MIN_VALUE보다 -1하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>
  
  <BugPattern type="CO_SELF_NO_OBJECT">
    <ShortDescription> 공변 인 compareTo 메소드의 정의 </ ShortDescription>
    <LongDescription> {0}은 compareTo (Object) 대신 compareTo ({0.givenClass}) 메소드를 정의하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 모두 이상한 <code> compareTo </ code> 메소드를 정의하고 있습니다.
<code> Comparable </ code> 인터페이스 <code> compareTo </ code> 메서드를 제대로 구현하기 위해서는 <code> compareTo </ code> 메서드의 매개 변수 형식은 <code> java.lang.Object < / code>이어야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS">
    <ShortDescription> 해시 된 맥락에서 해시 할 수없는 클래스를 사용하는 시그니처에 선언 된 </ ShortDescription>
    <LongDescription> {2}는 hashCode 메소드를 정의하고 있지 않는데 해시 된 맥락에서 사용되고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
메소드, 필드, 클래스는 해시 가능한 클래스가 필요한 문맥에서 해시 할 수없는 클래스가 사용되는 범용적인 서명을 선언합니다.
클래스는 <code> equals </ code> 메소드를 선언하고 있습니다 만, <code> hashCode </ code> 메소드는 <code> java.lang.Object </ code>에서 상속합니다.
이것은 "등가 인 오브젝트는 등가 인 해시 코드를 보관 유지할 필요가있다"는 <code> hashCode </ code> 메소드의 범용 규약을 따르지 않기 때문에 해시 할 수 없습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="HE_USE_OF_UNHASHABLE_CLASS">
    <ShortDescription> 해시 데이터 구조 hashCode 메소드가없는 클래스를 사용하는 </ ShortDescription>
    <LongDescription> {2}는 hashCode 메소드를 정의하고 있지 않는데 해시 데이터 구조에서 사용되고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 <code> equals (Object) </ code> 메소드를 정의하고 있는데 <code> hashCode </ code> 메소드를 정의하지 않습니다.
이것은 "등가 인 오브젝트는 등가 인 해시 코드를 보관 유지할 필요가있다"는 <code> hashCode </ code> 메소드의 범용 규약을 따르지 않습니다.
이 클래스의 인스턴스는 해시 데이터 구조에서 사용되고 있습니다. 가장 중요한 문제를 해결해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="HE_HASHCODE_USE_OBJECT_EQUALS">
    <ShortDescription> hashCode 메소드를 정의하고 Object.equals ()를 사용하는 클래스 </ ShortDescription>
    <LongDescription> {0}는 hashCode 메소드를 정의하고, Object.equals ()를 사용하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 <code> hashCode </ code> 메소드를 정의하고 있습니다 만, <code> equals </ code> 메소드는 <code> java.lang.Object </ code>에서 상속합니다 (개체 참조 비교 동등성을 판정합니다).
이것은 "등가 인 오브젝트는 등가 인 해시 코드를 보관 유지할 필요가있다"는 <code> hashCode </ code> 메소드의 범용 규약을 준수하는지도 모릅니다 만,
아마도 <code> hashCode </ code> 메서드를 재정의함으로써 의도 한 것은 아니라고 생각합니다
(<code> hashCode </ code> 메서드를 재정의하는 것은 개체의 정체성이 단순한 참조 등가성보다 복잡한 약관에 근거하는 것을 의미합니다).
</ p>
<p>
이 클래스의 인스턴스가 HashMap / HashTable에 결코 대체 될 것이라고 생각하지 않는다면,
권장 <code> hashCode </ code> 메소드의 구현은 다음과 같습니다.
</ p>
<blockquote> <pre>
public int hashCode () {
    assert false : "hashCode가 불려 갈 것은 예상하지 않습니다.";
    return 42; / / 적당한 값
}
</ pre> </ blockquote>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="EQ_COMPARETO_USE_OBJECT_EQUALS">
    <ShortDescription> compareTo (...) 메소드를 정의하고 Object.equals ()를 사용하는 클래스 </ ShortDescription>
    <LongDescription> {0} {1.givenClass}을 정의하여 Object.equals ()를 사용하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 <code> compareTo (...) </ code> 메소드를 정의하고 있습니다 만, <code> equals </ code> 메소드는 <code> java.lang.Object </ code>에서 상속 있습니다.
일반적으로 <code> equals </ code> 메소드가 true를 돌려주는 경우에만 <code> compareTo </ code> 메서드는 0을 반환해야합니다.
이것이 위반된다면 이상한 예측할 수없는 실패가 PriorityQueue 등의 클래스에서 발생합니다.
J2SE 5.0에서는 <code> PriorityQueue.remove () </ code>는 <code> compareTo </ code> 메소드를 사용하지만, Java SE 6에서는 <code> equals </ code> 메서드를 사용합니다 .
<p>
Comparable 인터페이스의 compareTo 메소드의 JavaDoc를 아래에 인용합니다.
</ p>
<blockquote> <p>
필수라는 것은 없지만, <code> (x.compareTo (y) == 0) == (x.equals (y)) </ code> 인 것이 권장됩니다.
일반적으로 <code> Comparable </ code> 인터페이스를 구현하는 클래스로,이 조건에 위반하는 클래스는 명확하게이 사실을 보여줄 필요가 있습니다.
"참고 :이 클래스는 <code> equals </ code>와 일관성이없는 자연 순서 부를가집니다"등이라고 명시하는 것이 좋습니다.
</ p> </ blockquote>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="HE_HASHCODE_NO_EQUALS">
    <ShortDescription> hashCode 메소드를 정의하고 있는데 equals 메소드는 정의하지 않는 클래스 </ ShortDescription>
    <LongDescription> {0}는 hashCode 메소드를 정의하고 있는데 equals 메소드는 정의하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 <code> hashCode </ code> 메소드를 정의하고 있는데 <code> equals </ code> 메소드는 정의하지 않습니다.
이것은 "등가 인 오브젝트는 등가 인 해시 코드를 보관 유지할 필요가있다"는 <code> hashCode </ code> 메소드의 범용 규약을 위반 할지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="HE_EQUALS_USE_HASHCODE">
    <ShortDescription> equals 메소드를 정의하고 Object.hashCode ()를 사용하는 클래스 </ ShortDescription>
    <LongDescription> {0}는 equals 메소드를 정의하고, Object.hashCode ()를 사용하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 <code> equals (Object) </ code>를 재정의하고 있는데 <code> hashCode </ code> 메소드는 <code> java.lang.Object </ code>에서 상속합니다 ( 정체성 해시 코드 (Java 가상 머신에 의해 개체에 할당 된 임의의 값)을 반환합니다).
따라서, "등가 인 오브젝트는 등가 인 해시 코드를 보관 유지할 필요가있다"는 <code> hashCode </ code> 메소드의 범용 규약을 위반 할지도 모릅니다.
</ p>
<p>
이 클래스의 인스턴스가 HashMap / HashTable에 결코 대체 될 것이라고 생각하지 않는다면, 권장 <code> hashCode </ code> 메소드의 구현은 다음과 같습니다.
</ p>
<blockquote> <pre>
public int hashCode () {
    assert false : "hashCode가 불려 갈 것은 예상하지 않습니다.";
    return 42; / / 적당한 값
}
</ pre> </ blockquote>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="HE_INHERITS_EQUALS_USE_HASHCODE">
    <ShortDescription> equals 메소드를 상속하고 Object.hashCode ()를 사용하는 클래스 </ ShortDescription>
    <LongDescription> {0}는 equals 메소드를 상속하여 Object.hashCode ()를 사용하고 있습니다. </ LongDescription>
    <Details>
	<! [CDATA [
<p>
이 클래스는 추상 슈퍼 클래스에서 <code> equals (Object) </ code> 메소드를 상속하여 <code> java.lang.Object </ code>에서 <code> hashCode </ code> 메소드를 상속 있습니다 (정체성 해시 코드 (Java 가상 머신에 의해 개체에 할당 된 임의의 값)을 반환합니다).
따라서, "등가 인 오브젝트는 등가 인 해시 코드를 보관 유지할 필요가있다"는 <code> hashCode </ code> 메소드의 범용 규약을 위반 할지도 모릅니다.
</ p>
<p>
<code> hashCode </ code> 메소드를 정의하고 싶지 않거나 객체가 HashMap / Hashtable에 결코 포함되지 않을 것이라고 생각한다면 <code> UnsupportedOperationException </ code>를 던져 <code> hashCode () </ code> 메소드를 정의합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="HE_EQUALS_NO_HASHCODE">
    <ShortDescription> equals 메소드는 정의하고 있는데 hashCode 메소드는 정의하지 않는 클래스 </ ShortDescription>
    <LongDescription> {0}는 equals 메소드를 정의하고 있는데 hashCode 메소드는 정의하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 <code> equals (Object) </ code> 메서드를 재정의하고 있는데 <code> hashCode </ code> 메서드를 재정의하지 않습니다.
따라서, "등가 인 오브젝트는 등가 인 해시 코드를 보관 유지할 필요가있다"는 <code> hashCode </ code> 메소드의 범용 규약을 위반 할지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="EQ_ABSTRACT_SELF">
    <ShortDescription> 추상 클래스는 모두 이상한 equals 메소드를 선언하는 </ ShortDescription>
    <LongDescription> 추상 클래스 {0}은 모두 이상한 equals ({0.givenClass}) 메소드를 정의하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 모두 이상한 <code> equals </ code> 메소드를 정의하고 있습니다.
<code> java.lang.Object </ code>의 <code> equals </ code> 메서드를 올바르게 재정의하기 위해서는 <code> equals </ code> 메서드의 매개 변수 형식은 <code> java.lang . Object </ code>이어야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="ES_COMPARING_STRINGS_WITH_EQ">
    <ShortDescription> String 객체를 ==와! =를 사용하여 비교하​​고있다 </ ShortDescription>
    <LongDescription> String 객체를 ==와! =를 사용하여 비교합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 참조 등가성을 위해 ==와! =를 사용하여 <code> java.lang.String </ code> 개체를 비교합니다.
두 문자열이 소스 파일의 상수 또는 <code> String.intern () </ code>를 사용하여 정 준 화되지 않는 한 동일한 문자열은 두 개의 다른 String 객체에 의해 대표 될지도 없습니다.
대신 <code> equals (Object) </ code> 메소드를 사용하는 것을 고려하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="ES_COMPARING_PARAMETER_STRING_WITH_EQ">
    <ShortDescription> String 매개 변수를 ==와! =를 사용하여 비교하​​고있다 </ ShortDescription>
    <LongDescription> String 매개 변수를 ==와! =를 사용하여 비교합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 참조 등가성을 위해 ==와! =를 사용하여 <code> java.lang.String </ code> 매개 변수를 비교합니다.
문자열 상수 또는 정 준 화 된 문자열 만 메서드에 전달을 호출자에게 요구하는 것은 필요 이상으로 취약, 측정 가능한 성능의 향상을 가져 오지 않습니다.
대신 <code> equals (Object) </ code> 메소드를 사용하는 것을 고려하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="CO_ABSTRACT_SELF">
    <ShortDescription> 추상 클래스는 공변 인 compareTo 메소드를 정의하고있다 </ ShortDescription>
    <LongDescription> 추상 클래스 {0}은 compareTo ({0.givenClass}) 메소드를 정의하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 모두 이상한 <code> compareTo </ code> 메소드를 정의하고 있습니다.
<code> Comparable </ code> 인터페이스 <code> compareTo </ code> 메서드를 제대로 구현하기 위해서는 <code> compareTo </ code> 메서드의 매개 변수 형식은 <code> java.lang.Object < / code>이어야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>


  <BugPattern type="IS_FIELD_NOT_GUARDED">
    <ShortDescription> 병행 액세스에 대비되어 있지 않은 필드 </ ShortDescription>
    <LongDescription> {1.givenClass}는 병행 액세스에 대비되어 있지 않습니다. {2} %의 시간을 잠금 </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 필드는 <code> net.jcip.annotations.GuardedBy </ code>에 주석을 달 수 있지만, 주석을 위반한다고 생각되는 방법으로 액세스 할 수 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="MSF_MUTABLE_SERVLET_FIELD">
    <ShortDescription> 가변 서블릿 필드 </ ShortDescription>
    <LongDescription> {1}은 가변 서블릿 필드입니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
Web 서버는 일반적 서블릿과 JSP 클래스의 인스턴스를 하나 만듭니다 (즉, 단일 항목으로 취급합니다).
여러 스레드가 여러 동시 요청을 처리하기 위해 인스턴스의 메소드를 호출합니다.
따라서 가변 인스턴스 필드는 일반적 경합 상태를 만듭니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="IS2_INCONSISTENT_SYNC">
    <ShortDescription> 일관성없는 동기화 </ ShortDescription>
    <LongDescription> {1}의 일관성이 동기화입니다. {2} %의 시간을 잠금 </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스의 필드는 동기화에 대해 일관성없이 사용되는 것 같습니다.
이 버그는 버그 패턴 검출기 다음과 같이 판단했다는 것을 보여줍니다.
</ p>
<ul>
  <li> 클래스는 잠긴 액세스 및 잠금 해제 된 액세스가 혼재하고 있고, </ li>
  <li> 하나의 잠긴 액세스가 클래스 자신의 방법 중 하나에 의해 실행되고 </ li>
  <li> 읽기의 2 배의 가중치를 한 글에서 비동기 필드의 액세스 (읽기 및 쓰기) 수가 모든 액세스의 1 / 3 </ li>
</ ul>
<p>
이 버그 패턴에 맞는 전형적인 버그는 스레드로부터 안전을 의도 한 클래스에서 메소드를 동기화하는 것을 잊는 것입니다.
</ p>
<p>
검출기 어디에 필드가 동기화없이 액세스된다고 믿었다 여부를 나타내는 코드 위치에 "비동기 액세스"라는 라벨을 붙일 수 있습니다.
</ p>
<p>
부정확 한 여러가지 원인이 탐지기에 유의하십시오.
예를 들어, 검출기는 잠금되는 모든 상황을 정적으로 검출 할 수 있다는 뜻이 아닙니다.
또한 검출기 잠긴 액세스 및 잠금 해제 된 액세스를 구분 정확한 경우에도 문제의 코드는 여전히 올바른지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NN_NAKED_NOTIFY">
    <ShortDescription> 알몸 notify 메소드 </ ShortDescription>
    <LongDescription> {1}에 벌거 벗은 notify 메소드가 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> notify </ code> 메소드 또는 <code> notifyAll </ code> 메서드 호출은 가변 객체 상태에 어떤 (명백한) 부수적 인 변경도 초래하지 못했습니다.
일반적으로 다른 스레드가 기대하고있는 몇 가지 조건이 참 때문에, 모니터 <code> notify </ code> 메소드를 호출합니다.
그러나 의미가있는 조건 때문에 두 스레드에 보이는 힙 객체를 포함해야합니다.
</ p>
<p>
가변 객체의 상태 변경이 통지하는 메서드를 호출 한 메서드에서 일어난지도 모르기 때문에,이 버그가 오류를 나타내는 말은 없습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="MS_EXPOSE_REP">
    <ShortDescription> 배열을 반환하여 내부 표현을 폭로 할지도 모른다 public static 메서드 </ ShortDescription>
    <LongDescription> {1} {2.givenClass}를 반환하여 내부 표현을 폭로 할지도 모릅니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
public static 메서드는 클래스의 정적 인 상태의 일부 배열의 참조를 돌려줍니다.
이 메소드를 호출 어떤 코드도 기본 배열을 자유롭게 변경할 수 있습니다.
해결책은 배열의 복사본을 반환합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="EI_EXPOSE_REP">
    <ShortDescription> 가변 개체에 대한 참조를 반환하여 내부 표현을 폭로 할지도 모른다 방법 </ ShortDescription>
    <LongDescription> {1} {2.givenClass}를 반환하여 내부 표현을 폭로 할지도 모릅니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
개체의 필드 중 하나에 포함 된 가변 객체의 참조를 반환하면 객체의 내부 표현을 노출합니다.
인스턴스가 신뢰할 수없는 코드에 의해 접근된다면, 가변 객체의 검사되지 않은 변경이 보안 및 기타 중요한 속성을 위태롭게 할 것이다.
뭔가 다른 일을해야합니다. 개체의 새 복사본을 반환 할 많은 상황에서 더 나은 방법입니다.
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="EI_EXPOSE_REP2">
    <ShortDescription> 가변 개체에 대한 참조를 가져올하여 내부 표현을 폭로 할지도 모른다 방법 </ ShortDescription>
    <LongDescription> {1} {2.givenClass}에 외부 가변 객체를 저장하여 내부 표현을 폭로 할지도 모릅니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 객체의 내부 표현에 외부 가변 객체의 참조를 포함하고 있습니다.
인스턴스가 신뢰할 수없는 코드에 의해 접근된다면, 가변 객체의 검사되지 않은 변경이 보안 및 기타 중요한 속성을 위태롭게 할 것이다.
뭔가 다른 일을해야합니다. 개체의 새 복사본을 반환 할 많은 상황에서 더 나은 방법입니다.
  </ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="EI_EXPOSE_STATIC_REP2">
    <ShortDescription> static 필드에 가변 객체를 저장하여 내부 정적 상태를 폭로 할지도 모른다 방법 </ ShortDescription>
    <LongDescription> {1}는 static 필드 {2}에 가변 객체를 저장하여 내부 정적 상태를 폭로 할지도 모릅니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 static 필드에 외부 가변 객체를 포함하고 있습니다.
가변 객체의 검사되지 않은 변경이 보안 및 기타 중요한 속성을 위태롭게 할 것이다.
뭔가 다른 일을해야합니다. 객체의 복사본을 저장하는 것은 많은 상황에서 더 나은 방법입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RU_INVOKE_RUN">
    <ShortDescription> 스레드 run 메소드를 호출하는 </ ShortDescription>
    <LongDescription> {1}는 스레드에서 명시 적으로 run 메소드를 호출합니다 (start 메소드를 의미하고 있었습니까?) </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 스레드에서 명시 적으로 <code> run </ code> 메소드를 호출합니다.
일반적으로 클래스는 새로운 스레드에서 자기의 <code> run </ code> 메소드를 호출 해달라고하기 위하여 <code> Runnable </ code> 인터페이스를 구현합니다.
이 경우 <code> Thread.start () </ code>를 호출하는 것이 맞습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="SP_SPIN_ON_FIELD">
    <ShortDescription> 스핀 락을하는 방법 </ ShortDescription>
    <LongDescription> 필드 {2.givenClass}을 사용하여 스핀 잠금을하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 필드를 읽는 루프에서 계속 작동합니다.
컴파일러가 필드의 읽기를 루프 밖으로 질지도 모릅니다. 코드를 무한 루프로 변경합니다.
올바른 동기화 (wait / notify를 호출하도록 포함)을 사용하도록 클래스를 변경해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NS_DANGEROUS_NON_SHORT_CIRCUIT">
    <ShortDescription> 잠재적 인 비 단락 논리 위험한 사용 </ ShortDescription>
    <LongDescription> 잠재적 인 비 단락 논리 위험한 사용. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 단락 논리 (&& 및 | |) 대신 비 단락 논리 (&와 |)를 사용하고 있다고 생각됩니다.
또한 왼쪽 값이 오른쪽을 평가하고 싶지 않아 (예외 발생이나 연산이 많이 드는 부작용이 있기 때문에) 생각하고 있을지도 모릅니다.
비 단락 논리는 왼쪽의 결과를 알고 있고 추론 할 때도 양쪽의식이 평가됩니다.
왼쪽이 오른쪽의 평가에 오류를 발생시키는 사례를 가드한다면 효율이 나쁘고, 오류가 발생할 수 있습니다.
</ p>
<p>
자세한 내용은 <a href="http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.22.2"> the Java Language Specification </ a>를 참조 하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="NS_NON_SHORT_CIRCUIT">
    <ShortDescription> 비 단락 논리 의심 사용 </ ShortDescription>
    <LongDescription> 비 단락 논리 의심 사용. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 단락 논리 (&& 및 | |) 대신 비 단락 논리 (&와 |)를 사용하고 있다고 생각됩니다.
비 단락 논리는 왼쪽의 결과를 알고 있고 추론 할 때도 양쪽의식이 평가됩니다.
왼쪽이 오른쪽의 평가에 오류가 케이스를 가드한다면 비효율적 오류가 발생할 수 있습니다.
</ p>
자세한 내용은 <a href="http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.22.2"> the Java Language Specification </ a>를 참조 하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="TLW_TWO_LOCK_WAIT">
    <ShortDescription> 두 개 이상의 잠금을 보유하고 wait 메소드를 호출하는 </ ShortDescription>
    <LongDescription> 두 개 이상의 잠금을 보유하고 wait 메소드를 호출합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
두 개 이상의 잠금을 유지하고 모니터 대기 시키면 교착 상태의 원인이 될 수 있습니다.
<code> wait </ code> 메소드를 호출하면 대기하고있는 객체의 잠금을 해제하는 것만으로 다른 잠금 해제하지 않습니다.
이것은 반드시 버그는 아니지만 시험하는 가치가 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="TLW_TWO_LOCK_NOTIFY" deprecated="true"> <! - never generated ->
    <ShortDescription> Notify with two locks held </ ShortDescription>
    <LongDescription> notify () or notifyAll * () with two locks held in {1} </ LongDescription>
    <Details>
<! [CDATA [
  <p> The code calls notify () or notifyAll () while two locks
  are held. If this notification is intended to wake up a wait ()
  that is holding the same locks, it may deadlock, since the wait
  will only give up one lock and the notify will be unable to get both locks,
  and thus the notify will not succeed.
   If there is also a warning about a two lock wait, the
   probably of a bug is quite high.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="UW_UNCOND_WAIT">
    <ShortDescription> wait 메소드의 무조건 호출 </ ShortDescription>
    <LongDescription> wait 메소드를 무조건 호출합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법에는 조건 제어 흐름에 의해 가드되지 <code> java.lang.Object.wait () </ code>의 호출이 있습니다.
이 코드는 <code> wait </ code> 메소드를 호출하기 전에 대기 할 생각이었다 조건이 이미 충족되지 않는다는 것을 확인한다.
어떤 이전 고시도 무시됩니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="UR_UNINIT_READ">
    <ShortDescription> 생성자에서 초기화되지 않은 필드를 읽는 </ ShortDescription>
    <LongDescription> 초기화되지 않은 필드 {2.name}를 읽어 내고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 생성자는 아직 값이 할당되지 않은 필드를 읽어 내고 있습니다.
종종 프로그래머가 생성자의 매개 변수 대신 잘못 필드를 사용하는 경우에 발생합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR">
    <ShortDescription> 슈퍼 클래스의 생성자에서 호출되는 메서드에서 초기화되지 않은 필드를 읽는 </ ShortDescription>
    <LongDescription> 슈퍼 클래스의 생성자에서 호출 될 때 {2.name}는 {1}로 초기화되지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메소드는 슈퍼 클래스의 생성자에서 호출되어 있습니다. 이 시점에서, 클래스의 필드는 아직 초기화되지 않았습니다.
</ p>
<p>
이것은 많은 구상 클래스를 만드는 것입니다. 다음 클래스를 검토하십시오.
</ p>
<blockquote> <pre>
abstract class A {
    int hashCode;
    abstract Object getValue ();
    
    A () {
        hashCode = getValue () hashCode ();
    }
}

class B extends A {
    Object value;

    B (Object v) {
        this.value = v;
    }

    Object getValue () {
        return value;
    }
}
</ pre> </ blockquote>
<p>
<code> B </ code>가 구축 될 때, <code> B </ code>의 생성자가 <code> value </ code>에 값을 설정하기 전에 <code> A </ code> 클래스 생성자가 호출됩니다.
따라서 <code> A </ code>의 생성자가 <code> getValue </ code>를 호출 할 때 <code> value </ code>의 초기화되지 않은 값을 읽습니다.
</ p>

]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="UG_SYNC_SET_UNSYNC_GET">
    <ShortDescription> 동기화하지 get 메소드 동기화하는 set 메소드 </ ShortDescription>
    <LongDescription> {1}은 동기화하지 않습니다, {2}는 동기화하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 비슷한 이름의 get 및 set 메서드가, set 메소드는 동기화하고, get 메소드는 동기화하지 않습니다.
get 메서드 호출이 개체에 대한 일관된 상태를 반드시 본다는 것은 아니기 때문에 런타임에 잘못된 행동이 될지도 모릅니다.
get 메소드는 동기화해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="IC_INIT_CIRCULARITY">
    <ShortDescription> 초기화가 순환하고있는 </ ShortDescription>
    <LongDescription> {0} {1} 사이에 초기화가 순환하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
순환이 버그 인스턴스에서 참조하는 두 클래스의 정적 이니셜 라이저에서 발견되었습니다.
많은 종류의 의외의 행동은 그러한 순환에 기인 할지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION">
    <ShortDescription> 슈퍼 클래스는 초기화 중 하위 클래스를 사용하는 </ ShortDescription>
    <LongDescription> {0} 초기화는 아직 초기화되지 않은 클래스 {2}에 액세스하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
클래스는 초기화 중 하위 클래스를 적극적으로 사용하고 있습니다. 서브 클래스는이 시점에서는 아직 초기화되지 않습니다. <br>
예를 들어, 다음 코드에서 <code> foo </ code>는 null입니다.
</ p>
<blockquote> <pre>
public class CircularClassInitialization {
    static class InnerClassSingleton extends CircularClassInitialization {
        static InnerClassSingleton singleton = new InnerClassSingleton ();
    }
    
    static CircularClassInitialization foo = InnerClassSingleton.singleton;
}
</ pre> </ blockquote>

]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="IT_NO_SUCH_ELEMENT">
    <ShortDescription> Iterator.next ()가 NoSuchElementException를 발생하지 </ ShortDescription>
    <LongDescription> {1}는 NoSuchElementException을 발생하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 <code> java.util.Iterator </ code>를 구현하고 있습니다.
그러나 <code> next </ code> 메소드는 <code> java.util.NoSuchElementException </ code>를 throw 할 수 없습니다.
<code> next </ code> 메소드는 더 이상 요소를 반환 할 수없는 경우 <code> NoSuchElementException </ code>를 throw하도록 변경해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DL_SYNCHRONIZATION_ON_SHARED_CONSTANT">
    <ShortDescription> 정 준 화 된 문자열의 동기화 </ ShortDescription>
    <LongDescription> 정 준 화 된 문자열을 동기화하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 정 준 화 된 문자열로 동기화합니다.
</ p>
<blockquote> <pre>
private static String LOCK = "LOCK";

synchronized (LOCK) {
    ...
}
</ pre> </ blockquote>
<p>
문자열 상수는 정 준 화되어 Java 가상 머신에 의해로드 된 모든 클래스에서 공유됩니다.
따라서 이것은 다른 코드가 잠겨있을 무언가를 잠근 수 있습니다.
이것은 블로킹과 교착 상태 행동의 진단을 어렵게하고, 매우 이상한 결과를 초래할 수 있습니다. <br>
자세한 내용은 <a href="http://www.javalobby.org/java/forums/t96352.html"> http://www.javalobby.org/java/forums/t96352.html </ a>와 < a href = "http://jira.codehaus.org/browse/JETTY-352"> http://jira.codehaus.org/browse/JETTY-352 </ a>를 참조하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DL_SYNCHRONIZATION_ON_BOOLEAN">
    <ShortDescription> Boolean 동기화 </ ShortDescription>
    <LongDescription> Boolean을 동기화하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> Boolean </ code> 같은 권투 된 원시 형의 정수로 동기화합니다.
</ p>
<blockquote> <pre>
private static Boolean inited = Boolean.FALSE;

synchronized (inited) {
    if (! inited) {
        init ();
        inited = Boolean.TRUE;
    }
}
</ pre> </ blockquote>
<p>
일반적으로 2 개의 <code> Boolean </ code> 개체 만 존재합니다.
이 코드는 다른 무관 한 코드와 동일한 개체에서 동기화하고있을 가능성이 있기 때문에, 무응답 또는 교착 상태의 원인이됩니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE">
    <ShortDescription> 박싱 된 기본 값 동기화 </ ShortDescription>
    <LongDescription> {2}을 동기화하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 분명히 공유되지 않은 <code> Integer </ code> 같은 권투 된 원시 형 동기화합니다.
</ p>
<blockquote> <pre>
private static final Integer fileLock = new Integer (1);

synchronized (fileLock) {
    .. do something ..
}
</ pre> </ blockquote>
<p>
이 코드는 fileLock을 다음과 같이 선언하면 더 좋아집니다.
</ p>
<blockquote> <pre>
private static final Object fileLock = new Object ();
</ pre> </ blockquote>
<p>
기존의 코드로 잘못 않을지도 모르지만, 혼란 때문에 미래 리팩토링해야 할지도 모릅니다.
예를 들어, IntelliJ의 "Remove Boxing"같은 리팩토링은 Java 가상 머신을 통해 공유되는 정 준 화 된 <code> Integer </ code> 객체를 사용하도록 대체 할 수 매우 혼란 행동과 잠재적 교착 상태의 원인이됩니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE">
    <ShortDescription> 교착 상태의 원인이 될 수있는 권투 된 원시 형의 동기화 </ ShortDescription>
    <LongDescription> {2}의 동기화는 교착 상태의 원인이 될 수 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 Integer 같은 박싱 된 원시 형의 정수로 동기화합니다.
</ p>
<blockquote> <pre>
private static Integer count = 0;

synchronized (count) {
    count + +;
}
</ pre> </ blockquote>
<p>
<code> Integer </ code> 객체는 캐시 공유 될 수 있습니다.
다른 무관 한 코드와 동일한 개체에서 동기화하고있을 가능성이 있기 때문에, 무응답 또는 교착 상태의 원인이됩니다.
</ p>
<p>
CERT의 <a href="https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused"> CON08 -J. Do not synchronize on objects that may be reused </ a>를 참조하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="ESync_EMPTY_SYNC">
    <ShortDescription> 빈 synchronized 블록 </ ShortDescription>
    <LongDescription> 빈 synchronized 블록입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드에는 빈 synchronized 블록이 있습니다.
</ p>
<blockquote> <pre>
synchronized () {
}
</ pre> </ blockquote>
<p>
빈 synchronized 블록은 성공적 제대로 사용하기 어렵습니다.
빈 synchronized 블록은 일부러 결코 좋은 해결책은 없습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="IS_INCONSISTENT_SYNC">
    <ShortDescription> 일관성없는 동기화 </ ShortDescription>
    <LongDescription> {1}의 동기화에 일관성이 없습니다. {2} %의 시간을 잠금 </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스의 필드는 동기화에 대해 일관성없는 액세스를하고있는 것 같습니다.
이 버그는 버그 패턴 검출기 다음과 같이 판단했는지를 보여줍니다.
</ p>
<ul>
  <li> 클래스는 잠긴 액세스 및 잠금 해제 된 액세스가 혼재하고 있고, </ li>
  <li> 하나의 잠긴 액세스가 클래스 자신의 방법 중 하나에 의해 실행되고 </ li>
  <li> 읽기의 2 배의 가중치를 한 글에서 비동기 필드의 액세스 (읽기 및 쓰기) 수가 모든 액세스의 1 / 3 </ li>
</ ul>
<p>
이 버그 패턴에 맞는 전형적인 버그는 스레드로부터 안전을 의도 한 클래스에서 메소드를 동기화하는 것을 잊는 것입니다.
</ p>
<p>
부정확 한 다양한 소스가이 탐지기에 유의하십시오.
예를 들어, 검출기는 잠금되는 모든 상황을 정적으로 검출 할 수 있다는 뜻이 아닙니다.
또한 검출기 잠긴 액세스 및 잠금 해제 된 액세스를 구분 정확한 경우에도 문제의 코드는 여전히 올바른지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD">
    <ShortDescription> 필드를 동기화에서 가드하려는 헛된 시도 </ ShortDescription>
    <LongDescription> {2.givenClass}을 동기화에서 가드하려는 헛된 시도입니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 필드의 동시 업데이트에 동기화에서 가드하려고하지만 필드를 가드하면 필드가 아닌 참조 된 개체의 잠금을 획득합니다.
이것은 당신이 필요로하는 상호 배제를 제공하지 않을지도 모릅니다.
그리고 다른 스레드 (다른 목적을위한) 참조 된 개체의 잠금을 할지도 모릅니다. <br>
이 패턴의 예는 다음과 같습니다.
</ p>
<blockquote> <pre>
private Long myNtfSeqNbrCounter = new Long (0);
private Long getNotificationSequenceNumber () {
     Long result = null;
     synchronized (myNtfSeqNbrCounter) {
         result = new Long (myNtfSeqNbrCounter.longValue () + 1);
         myNtfSeqNbrCounter = new Long (result.longValue ());
     }
     return result;
}
</ pre> </ blockquote>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="ML_SYNC_ON_UPDATED_FIELD">
    <ShortDescription> 업데이트되는 필드에서 동기화하는 방법 </ ShortDescription>
    <LongDescription> {1}은 업데이트되는 필드 {2.givenClass}에서 동기화하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 가변 필드에서 참조되는 개체에서 동기화하고 있습니다.
다른 스레드가 다른 개체에서 동기화하는지도 모르기 때문에, 이것은 유용한 의미가있을 수 낮습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="MS_OOI_PKGPROTECT">
    <ShortDescription> 인터페이스에서 이동하여 패키지 뿌로테쿠텟도해야할 필드 </ ShortDescription>
    <LongDescription> {1}는 인터페이스에서 이동하여 패키지 뿌로테쿠텟도하여야합니다 </ LongDescription>
    <Details>
<! [CDATA [
<p>
인터페이스에 정의 된 final static 필드는 배열이나 Hashtable 등의 가변 객체를 참조하고 있습니다.
이 가변 개체는 악성 코드와 우연히 다른 패키지에 의해 변경 될 수 있습니다.
이를 해결하기 위해 필드는 클래스로 이동해야 취약점을 해결하기 위해 패키지 뿌로테쿠텟도합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="MS_FINAL_PKGPROTECT">
    <ShortDescription> final하고 패키지 뿌로테쿠텟도해야할 필드 </ ShortDescription>
    <LongDescription> {1}는 final하고 패키지 뿌로테쿠텟도하여야합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 가변 static 필드는 악성 코드와 우연히 다른 패키지에 의해 변경 될 수 있습니다.
필드는 취약점을 해결하기 위해 final 또는 패키지 뿌로테쿠텟도 수 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="MS_SHOULD_BE_REFACTORED_TO_BE_FINAL">
    <ShortDescription> final이 아닌 필드는 리팩토링해야 </ ShortDescription>
    <LongDescription> {1}는 final 아니기 때문에 리팩토링해야합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
final이 아닌 public static 필드는 악성 코드와 우연히 다른 패키지에 의해 변경 될 수 있습니다.
필드는 취약점을 해결하기 위해 final 수 있습니다.
그러나 정적 이니셜 라이저는 여러 필드에 쓸 수 있으므로, 어떤 리팩토링을 필요로 할 것이다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  
  <BugPattern type="MS_SHOULD_BE_FINAL">
    <ShortDescription> final해야할 필드 </ ShortDescription>
    <LongDescription> {1}는 final는 없지만, final하여야합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
final이 아닌 public static 필드는 악성 코드와 우연히 다른 패키지에 의해 변경 될 수 있습니다.
필드는 취약점을 해결하기 위해 final 수 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="MS_PKGPROTECT">
    <ShortDescription> 패키지 뿌로테쿠텟도해야할 필드 </ ShortDescription>
    <LongDescription> {1}는 패키지 뿌로테쿠텟도하여야합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 가변 static 필드는 악성 코드와 우연히 다른 패키지에 의해 변경 될 수 있습니다.
필드는 취약점을 해결하기 위해 패키지 뿌로테쿠텟도 수 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="MS_MUTABLE_HASHTABLE">
    <ShortDescription> 가변 Hashtable 필드 </ ShortDescription>
    <LongDescription> {1}은 가변 Hashtable입니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 final static 필드는 Hashtable을 참조하고 있기 때문에 악성 코드 나 우연히 다른 패키지에 액세스 할 수 있습니다.
이 코드는 Hashtable 콘텐츠를 자유롭게 변경할 수 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="MS_MUTABLE_ARRAY">
    <ShortDescription> 가변 배열의 필드 </ ShortDescription>
    <LongDescription> {1}는 가변 배열입니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 final static 필드는 배열을 참조하고 있기 때문에 악성 코드 나 우연히 다른 패키지에 액세스 할 수 있습니다.
이 코드는 배열의 내용을 자유롭게 변경할 수 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="MS_CANNOT_BE_FINAL">
    <ShortDescription> final이 아닌 필드는 악성 코드로부터 보호 할 수 없다 </ ShortDescription>
    <LongDescription> {1}은 final이 아니기 때문에, 악성 코드로부터 보호 할 수 없습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 가변 static 필드는 악성 코드와 우연히 다른 패키지에 의해 변경 될 수 있습니다.
불행히도 이러한 방법은 쉽게 해결할 수 없습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD">
    <ShortDescription> 상속 된 메소드인가 외부 방법인지 모호한 메소드 호출 </ ShortDescription>
    <LongDescription> 상속 된 메소드인가 외부 방법인지 모호한 메소드 {2}를 호출합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
내부 클래스는 상속 된 메소드 또는 외부 클래스에서 정의 된 메소드인지 어느 쪽이라고도 해석 할 수있는 방법을 호출합니다.
Java의 사양으로는 상속 된 메서드를 호출하지만, 이것은 의도 한 것은 아니다지도 모릅니다.
정말 상속 된 메소드를 호출하려고한다면 super으로 (예 : super.foo (17)) 호출하십시오.
그러면 외부 클래스의 메서드 대신 상속 된 메서드를 호출 할 수이 코드를 읽는 사람과 FindBugs 명확합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NM_SAME_SIMPLE_NAME_AS_SUPERCLASS">
    <ShortDescription> 클래스 이름은 슈퍼 클래스의 단순 명을 가로막는 안된다 </ ShortDescription>
    <LongDescription> 클래스 이름 {0}는 슈퍼 클래스 {1}의 간단한 이름을 차단합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 슈퍼 클래스와 동일한 간단한 이름이 있지만, 슈퍼 클래스는 다른 패키지 (예를 들어, <code> alpha.Foo </ code>가 <code> beta.Foo </ code>을 확장합니다 ).
이것은 매우 요즘 참조 관계를 해결하기 위해 import 문장을 봐야하지 않으며, 슈퍼 클래스에있는 메소드를 잘못 재정의 버리거나하는 상황을 만들어냅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NM_SAME_SIMPLE_NAME_AS_INTERFACE">
    <ShortDescription> 클래스 이름은 구현 된 인터페이스의 간단한 이름을 가로막는 안된다 </ ShortDescription>
    <LongDescription> 클래스 이름 {0}은 구현 된 인터페이스 {1}의 간단한 이름을 차단합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스 또는 인터페이스에 구현 된 / 확장 된 인터페이스와 같은 단순한 이름이 있지만, 인터페이스는 다른 패키지 (예를 들어, <code> alpha.Foo </ code>가 <code> beta.Foo </ code>를 계승하고있는 상황입니다.)
이것은 매우 요즘 참조 관계를 해결하기 위해 import 문장을 봐야하지 않으며, 슈퍼 클래스에있는 메소드를 잘못 재정의 버리거나하는 상황을 만들어냅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NM_CLASS_NAMING_CONVENTION">
    <ShortDescription> 클래스 이름은 대문자로 시작해야 </ ShortDescription>
    <LongDescription> 클래스 이름 {0}는 대문자로 시작하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
클래스 이름은 첫 글자와 연속적인 각 단어의 첫 글자를 대문자로 된 명사로해야합니다.
클래스 이름은 간단하고 이해하기 쉬운 있도록하십시오.
머리 기호 및 약어 (URL이나 HTML 등과 같이 약자가 긴 형식보다 훨씬 널리 사용되고있는 경우를 제외)의 사용은 피하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NM_METHOD_NAMING_CONVENTION">
    <ShortDescription> 메소드 명은 소문자로 시작한다 </ ShortDescription>
    <LongDescription> 메서드 이름 {1}는 소문자로 시작하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
메소드 이름은 첫 글자는 소문자로, 연속적인 각 단어의 첫 글자를 대문자로 동사해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NM_FIELD_NAMING_CONVENTION">
    <ShortDescription> 필드 이름은 소문자로 시작해야 </ ShortDescription>
    <LongDescription> 필드 이름 {1}는 소문자로 시작하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
final이 아닌 필드의 이름은 첫 글자는 소문자로, 연속적인 각 단어의 첫 글자를 대문자로해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NM_VERY_CONFUSING">
    <ShortDescription> 매우 혼란 이름의 메소드 </ ShortDescription>
    <LongDescription> {1}과 {3}은 매우 잘못된 것입니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
참조 된 메서드는 대문자 사용을 통해서만 다른 이름이 있습니다.
대문자 사용법이 동일하면 메소드 중 하나가 다른 메서드를 재정의하기 때문에 매우 잘못된 것입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NM_VERY_CONFUSING_INTENTIONAL">
    <ShortDescription> 매우 혼란 이름의 메소드 (아마 의도적으로) </ ShortDescription>
    <LongDescription> {1}과 {3} 방법은 매우 잘못된 것입니다 (아마 의도적으로). </ LongDescription>
    <Details>
<! [CDATA [
<p>
참조 된 메서드는 대문자 사용을 통해서만 다른 이름이 있습니다.
대문자 사용법이 동일하면 메소드 중 하나가 다른 메서드를 재정의하기 때문에 매우 잘못된 것입니다.
다른 방법의 존재에서 이러한 방법의 두 존재가 의도적 확실하게 혼란시키고 있다고 생각됩니다.
API의 얼어서 둘 다 가지지 않을 수없는 경우를 제외하고 그 중 하나를 제거하려고 노력하는 것이 좋습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NM_WRONG_PACKAGE">
    <ShortDescription> 매개 변수의 잘못된 포장을 위해, 슈퍼 클래스의 메서드를 재정의하지 않는 방법 </ ShortDescription>
    <LongDescription> 매개 변수 유형 {4}이 슈퍼 클래스의 매개 변수 형식 {5}과 일치하지 않기 때문에, {1}는 슈퍼 클래스의 메서드를 재정의하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
매개 변수의 형식이 슈퍼 클래스로 대응하는 파라미터의 형태와 정확하게 일치하지 않기 때문에, 서브 클래스의 메소드는 슈퍼 클래스의 유사한 메서드를 재정의하지 않습니다. <br>
예를 들어 다음과 같은 코드입니다.
</ p>
<blockquote> <pre>
import alpha.Foo;

public class A {
    public int f (Foo x) {return 17;}
}
----
import beta.Foo;

public class B extends A {
    public int f (Foo x) {return 42;}
}
</ pre> </ blockquote>
<p>
클래스 <code> B </ code>에 정의 된 <code> f (Foo) </ code> 메서드는 클래스 <code> A </ code>의 <code> f (Foo) </ code> 메소드를 재정하지 않습니다.
이것은 인수 형식 <code> Foo </ code>가 다른 패키지이기 때문입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="NM_WRONG_PACKAGE_INTENTIONAL">
    <ShortDescription> 매개 변수의 잘못된 포장을 위해 슈퍼 클래스 메서드를 재정의하지 않는 방법 </ ShortDescription>
    <LongDescription> 매개 변수 유형 {4}이 슈퍼 클래스의 매개 변수 형식 {5}와 일치하지 않기 때문에, {1}는 슈퍼 클래스의 메서드를 재정의하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
매개 변수의 형식이 슈퍼 클래스로 대응하는 파라미터의 형태와 정확하게 일치하지 않기 때문에, 서브 클래스의 메소드는 슈퍼 클래스의 유사한 메서드를 재정의하지 않습니다. <br>
예를 들어 다음과 같은 코드입니다.
<blockquote> <pre>
import alpha.Foo;

public class A {
    public int f (Foo x) {return 17;}
}
----
import beta.Foo;

public class B extends A {
    public int f (Foo x) {return 42;}
    public int f (alpha.Foo x) {return 27;}
}
</ pre> </ blockquote>
<p>
클래스 <code> B </ code>에 정의 된 <code> f (Foo) </ code> 메서드는 클래스 <code> A </ code>의 <code> f (Foo) </ code> 메소드를 우선하지 않습니다.
이것은 인수 형식 <code> Foo </ code>가 다른 패키지이기 때문입니다.
</ p>
<p>
이 경우, 서브 클래스가 슈퍼 클래스의 메소드와 동일한 서명으로 메서드를 정의하기 때문에, 아마 이해됩니다.
그러나 그런 방법은 매우 잘못된 것입니다.
유사하지만 동일하지 않은 서명의 메소드를 제거하거나 비추천하는 것이 좋을 것이다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NM_CONFUSING">
    <ShortDescription> 혼란 이름의 메소드 </ ShortDescription>
    <LongDescription> {1}과 {3}는 잘못된 것입니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
참조 된 메서드는 대문자 사용을 통해서만 다른 이름이 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="NM_METHOD_CONSTRUCTOR_CONFUSION">
    <ShortDescription> 명백한 메소드와 생성자의 혼란 </ ShortDescription>
    <LongDescription> {1}은 아마 생성자하는 것을 목적으로했습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 정규 방법은 정의하고있는 클래스와 같은 이름입니다.
이것은 생성자를 의도했을 가능성이 높습니다. 그렇다면 void 반환 선언을 제거하십시오.
이 메소드를 정의는 우연 잘못 알 올바른 생성자를 정의했지만, 하위 호환성을 위해이 방법을 제거 할 수 없다면, 메소드를 비추천합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  
  <BugPattern type="NM_LCASE_HASHCODE">
    <ShortDescription> 클래스는 hashcode ()를 정의하고 있습니다. hashCode ()에해야하나요? </ ShortDescription>
    <LongDescription> 클래스 {0}은 hashcode ()를 정의하고 있습니다. hashCode ()에해야하나요? </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 <code> hashcode () </ code>라는 메소드를 정의하고 있습니다.
이 방법은 <code> java.lang.Object </ code>의 <code> hashCode </ code> 메서드를 (아마도 의도적으로) 재정하지 않습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  
  <BugPattern type="NM_LCASE_TOSTRING">
    <ShortDescription> 클래스는 tostring ()를 정의하고 있습니다. toString ()에해야하나요? </ ShortDescription>
    <LongDescription> 클래스 {0}은 tostring ()를 정의하고 있습니다. toString ()에해야하나요? </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 <code> tostring () </ code>라는 메소드를 정의하고 있습니다.
이 방법은 <code> java.lang.Object </ code>의 <code> toString </ code> 메서드를 (아마도 의도적으로) 재정하지 않습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NM_BAD_EQUAL">
    <ShortDescription> 클래스는 equal (Object)를 정의하고 있습니다. equals (Object)에해야하나요? </ ShortDescription>
    <LongDescription> 클래스 {0}은 equal (Object)를 정의하고 있습니다. equals (Object)에해야하나요? </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 <code> equal (Object) </ code>라는 메소드를 정의하고 있습니다.
이 방법은 <code> java.lang.Object </ code>의 <code> equals (Object) </ code>를 (아마도 의도적으로) 재정하지 않습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NM_CLASS_NOT_EXCEPTION">
    <ShortDescription> 예외 클래스처럼 명명되어 있지만 클래스는 Exception에서 파생되지 않은 </ ShortDescription>
    <LongDescription> 예외 클래스처럼 명명되어 있지만 클래스 {0}은 Exception에서 파생되지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 예외 클래스에서 파생 된 않았는데 클래스 이름이 "Exception"으로 끝납니다.
이것은이 클래스의 사용자에게 잘못된 것입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RR_NOT_CHECKED">
    <ShortDescription> InputStream.read ()의 반환 값을 무시하는 방법 </ ShortDescription>
    <LongDescription> {1} {2}의 반환 값을 무시하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 여러 바이트를 반환 할 수있는 <code> java.io.InputStream.read () </ code> (또는 유사)의 반환 값을 무시하고 있습니다.
반환 값이 체크되지 않으면 호출자는 요청 된 바이트 수보다 적은 바이트 수를 읽어 낸 경우 제대로 처리 할 수​​ 없습니다.
이것은 잠재적 인 버그입니다.
많은 프로그램에서 입력 스트림에서 읽기는 요청 된 전체 데이터 양을 읽기 있지만 산발적으로 실패 할 수 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SR_NOT_CHECKED">
    <ShortDescription> InputStream.skip ()의 반환 값을 무시하는 방법 </ ShortDescription>
    <LongDescription> {1} {2}의 반환 값을 무시하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 여러 바이트를 건너 뛸 수있다 <code> java.io.InputStream.skip () </ code>의 반환 값을 무시하고 있습니다.
반환 값이 체크되지 않으면 호출자는 요청 된 바이트 수보다 적은 바이트 수 밖에 스킵하지 않으면 제대로 처리 할 수​​ 없습니다.
이것은 잠재적 인 버그입니다.
많은 프로그램에서 입력 스트림에서 건너 뛰기 요구 한 전체 데이터 양을 건너하지만 산발적으로 실패 할 수 있습니다.
그러나 버퍼 스트림에서 <code> skip </ code> 메소드는 버퍼의 데이터를 건너 뛰므로, 요구 된 바이트 스킵은 항상 실패합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
<BugPattern type="SE_READ_RESOLVE_IS_STATIC">
    <ShortDescription> readResolve 메소드가 static 메서드로 선언 된 </ ShortDescription>
    <LongDescription> {1}는 static 메서드 대신 인스턴스 메서드로 선언해야합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> readResolve </ code> 메소드가 직렬화기구로 인식되기 위하여는 static 메서드로 선언해서는 안됩니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="SE_PRIVATE_READ_RESOLVE_NOT_INHERITED">
    <ShortDescription> 서브 클래스에서 상속 할 수없는 private 인 readResolve 메소드 </ ShortDescription>
    <LongDescription> 서브 클래스에서 상속 할 수없는 {0} private 인 readResolve 메소드입니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 private 인 <code> readResolve </ code> 메소드를 정의하고 있습니다.
따라서이 메소드는 서브 클래스에서 상속 할 수 없습니다.
이것이 의도 한 것이라면 잘못 할지도 모르지만, 확인하기 위해 검토해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SE_READ_RESOLVE_MUST_RETURN_OBJECT">
    <ShortDescription> readResolve 메소드의 반환 형식이 Object로 선언되지 않은 </ ShortDescription>
    <LongDescription> 메소드 {1}의 반환 형식은 {1.returnType} 대신 Object로 선언되어야합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> readResolve </ code> 메소드가 직렬화기구로 인식되기 위하여는 반환 형식이 <code> Object </ code>로 선언되어야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS">
    <ShortDescription> Serializable하지 않은 클래스의 transient 필드 </ ShortDescription>
    <LongDescription> {1.givenClass}는 transient하지만 {0}는 Serializable하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
필드는 transient로 선언하고 있습니다 만, 클래스는 직렬화 가능하지 않기 때문에, 전혀 효과가 없습니다.
이것은 클래스가 transient 일 때의 자취 수도 또는 직렬화기구를 오해하고있는지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SE_TRANSIENT_FIELD_NOT_RESTORED">
    <ShortDescription> 직렬화 복원에 의해 설정되지 transient 필드 </ ShortDescription>
    <LongDescription> 필드 {1}는 transient이므로 직렬화 복원에 의해 설정되지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 여러 곳에서 업데이트되는 필드가 있습니다. 따라서이 클래스의 상태의 일부라고 생각합니다.
그러나 필드는 transient로 선언하고 있으므로, readObject / readResolve에서 설정되지 않습니다.
클래스의 직렬화 복원 된 인스턴스에 대한 기본값이 설정됩니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SE_METHOD_MUST_BE_PRIVATE">
    <ShortDescription> 직렬화기구를 위해 private으로해야한다 방법 </ ShortDescription>
    <LongDescription> 메소드 {1.givenClass}는 {0} 직렬화 / 직렬화 복원 호출 위해 private으로해야합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 <code> Serializable </ code> 인터페이스를 구현하여 사용자 지정 직렬화 / 직렬화 복원을위한 방법을 정의하고 있습니다.
그러나, 그 메소드가 private로 선언되어 있지 않기 때문에, 직렬화 / 직렬화 복원 API에 의해 무시됩니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION">
    <ShortDescription> Externalizable 클래스가 인수없이 생성자를 정의하지 않는 </ ShortDescription>
    <LongDescription> {0}는 Externalizable을 구현하고 있는데 인수없는 생성자를 정의하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 <code> Externalizable </ code> 인터페이스를 구현하고 있는데, 인수없이 생성자는 정의하지 않습니다.
Externalizable 객체가 직렬화 복원 될 때, 먼저 인수가없는 생성자를 호출하여 구축 될 필요가 있습니다.
이 클래스는 인수가없는 생성자가 없기 때문에, 직렬화 및 직렬화 복원 할 때 실패합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SE_NO_SUITABLE_CONSTRUCTOR">
    <ShortDescription> Serializable 클래스의 슈퍼 클래스에서 인수가없는 생성자를 정의하지 않는 </ ShortDescription>
    <LongDescription> {0}는 Serializable를 구현하고 있습니다 만, 그 슈퍼 클래스는 액세스 가능한 인수없는 생성자를 정의하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 <code> Serializable </ code> 인터페이스를 구현하고 있습니다 만, 그 슈퍼 클래스는 구현하지 않습니다.
그러한 오브젝트가 직렬화 복원 될 때, 슈퍼 클래스의 필드는 슈퍼 클래스의 인수없는 생성자를 호출하여 초기화되어야합니다.
슈퍼 클래스는 인수가없는 생성자가 없기 때문에, 직렬화 및 직렬화 복원 할 때 실패합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SE_NO_SERIALVERSIONID">
    <ShortDescription> Serializable 클래스가 serialVersionUID를 정의하지 않은 </ ShortDescription>
    <LongDescription> {0}는 Serializable를 구현하고 있는데 serialVersionUID는 정의하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 <code> Serializable </ code> 인터페이스를 구현하고 있는데 <code> serialVersionUID </ code> 필드를 정의하지 않습니다.
. class 개체에 대한 참조를 추가하는 것만큼이나 간단한 변경 클래스 합성 필드를 추가합니다.
그것은 불행히도 암시 적 serialVersionUID을 바꿉니다 (예 <code> String.class </ code>에 대한 참조를 추가하면 <code> class $ java $ lang $ String </ code>라는 static 필드를 생성 매스).
또한 바이트 코드 컴파일러에 다른 소스 코드는 클래스 객체 또는 내부 클래스 참조를 위해 생성 된 합성 변수에 대한 다른 명명 규칙을 사용하는지도 모릅니다.
버전을 횡단하는 Serializable의 상호 운용성을 보장하기 위해 명시 적으로 serialVersionUID를 추가하는 것을 고려하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SE_COMPARATOR_SHOULD_BE_SERIALIZABLE">
    <ShortDescription> Comparator는 Serializable을 구현하지 않는 </ ShortDescription>
    <LongDescription> {0}은 Comparator를 구현하고 있는데 Serializable을 구현하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 <code> Comparator </ code> 인터페이스를 구현하고 있습니다.
<code> Serializable </ code> 인터페이스도 구현해야하는지 고려해야합니다.
콤퍼레이터가 <code> TreeMap </ code>와 같은 정렬 된 컬렉션을 구축하는 데 사용될 경우, 비교기가 직렬화 가능한 경우에만 <code> TreeMap </ code>는 직렬화 가능합니다.
대부분의 비교기가 대부분 상태가없는 경우에도 직렬화 가능하게하는 것은 간단 좋은 방어적인 프로그래밍입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>


  <BugPattern type="SF_SWITCH_FALLTHROUGH">
    <ShortDescription> 하나의 case가 다음 case로 통과 switch 문을 발견했다 </ ShortDescription>
    <LongDescription> 하나의 case가 다음 case로 통과 switch 문을 발견했습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 하나의 case가 다음 case로 통과 switch 문이 있습니다.
일반적으로 break 또는 return이 case를 끝낼 필요가 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="SF_SWITCH_NO_DEFAULT">
    <ShortDescription> default가없는 switch 문을 발견했다 </ ShortDescription>
    <LongDescription> default가없는 switch 문을 발견했습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메소드는 default가없는 switch 문이 있습니다.
일반적으로 default를 준비해야합니다.
</ p>
<p>
분석은 생성 된 바이트 코드를 볼 뿐이므로 default가 switch 문장의 끝 부분에 있고, break 문으로 끝나지 않는다면, 잘못된 경고를 트리거합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH">
    <ShortDescription> switch 문장 폴 스루 위해 저장이 비활성화되어있는 </ ShortDescription>
    <LongDescription> 이전 case에서 값 {2.givenClass}이 switch 문 폴 스루를 위해 여기에서 덮어되어 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이전 case에 저장된 값이 switch 문 폴 스루를 위해 여기에서 덮어되어 있습니다.
이전 case의 끝에 break 또는 return을 두는 것을 잊은 가능성이 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW">
    <ShortDescription> 던져 switch 문장 폴 스루 위해 저장이 비활성화되어있는 </ ShortDescription>
    <LongDescription> 이전 case에서 값 {2.givenClass}가 발생하는 switch 문 폴 스루를 위해 여기에서 손실됩니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이전 case에 저장된 값이 예외가 발생되는 장소에서 switch 문 폴 스루를 위해 여기에서 손실됩니다.
이전 case의 끝에 break 또는 return을 두는 것을 잊은 가능성이 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="WS_WRITEOBJECT_SYNC">
    <ShortDescription> writeObject 메소드는 동기화하고 있지만 다른 방법은 동기화하지 클래스 </ ShortDescription>
    <LongDescription> {0}의 writeObject 메소드는 동기화하고 있지만, 다른 방법은 동기화하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 동기화하는 <code> writeObject </ code> 메소드가 있습니다.
그러나 클래스의 다른 메소드는 동기화하지 않습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RS_READOBJECT_SYNC">
    <ShortDescription> readObject 메소드를 동기화하는 클래스 </ ShortDescription>
    <LongDescription> {0}의 readObject 메소드를 동기화하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 직렬화 가능 클래스는 동기화 <code> readObject </ code> 메소드를 정의하고 있습니다.
정의에 의해, 직렬화 복원에 의해 생성 된 개체는 하나의 스레드에 의해서만 도달 할 수 있습니다.
따라서 <code> readObject </ code> 메소드는 동기화 할 필요가 없습니다.
<code> readObject </ code> 메소드 자체가 다른 스레드에 보이게되는 오브젝트의 원인이 있다면 매우 의심 코딩 스타일을 보여줍니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SE_NONSTATIC_SERIALVERSIONID">
    <ShortDescription> serialVersionUID가 static이 아닌 </ ShortDescription>
    <LongDescription> {1}는 static가 없습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 static이 아닌 <code> serialVersionUID </ code> 필드를 정의하고 있습니다.
직렬화를 목적으로 버전 UID를 지정하기위한한다면 필드는 static으로 삼아야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SE_NONFINAL_SERIALVERSIONID">
    <ShortDescription> serialVersionUID가 final이 아닌 </ ShortDescription>
    <LongDescription> {1}는 final가 없습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 final이 아닌 <code> serialVersionUID </ code> 필드를 정의하고 있습니다.
직렬화를 목적으로 버전 UID를 지정하기위한한다면 필드는 final이되어야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SE_NONLONG_SERIALVERSIONID">
    <ShortDescription> serialVersionUID가 long이 아닌 </ ShortDescription>
    <LongDescription> {1}은 long가 없습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 long 아닌 <code> serialVersionUID </ code> 필드를 정의하고 있습니다.
직렬화를 목적으로 버전 UID를 지정하기위한한다면 필드는 long으로 삼아야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SE_BAD_FIELD">
    <ShortDescription> 직렬화 가능 클래스의 비 transient 비 직렬화 가능한 인스턴스 필드 </ ShortDescription>
    <LongDescription> 클래스 {0}은 비 transient 비 직렬화 가능한 인스턴스 필드 {1.name}을 정의합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 직렬화 가능 클래스는 transient, Serializable, <code> java.lang.Object </ code>도 아닌 비 원시적 형의 인스턴스 필드를 정의하고,
<code> Externalizable </ code> 인터페이스 또는 <code> readObject </ code> 메소드와 <code> writeObject </ code> 메소드를 구현하도록 보이지 않습니다.
또한 <code> Externalizable </ code> 인터페이스도 구현하지 않으며 <code> readObject </ code> 메서드 <code> writeObject </ code> 메서드를 정의하지 않습니다.
비 직렬화 가능 오브젝트가이 필드에 포함된다면이 클래스의 개체가 제대로 직렬화 복원되지 않습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SE_BAD_FIELD_INNER_CLASS">
    <ShortDescription> 비 직렬화 가능 클래스에 직렬화 가능한 내부 클래스가 </ ShortDescription>
    <LongDescription> {0}는 직렬화 가능하지만, 비 직렬화 가능 클래스의 내부 클래스입니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 직렬화 가능 클래스는 직렬화 가능 클래스의 내부 클래스입니다.
내부 클래스를 직렬화하려고하면 관​​련된 외부 클래스의 인스턴스를 묶으려고하기 때문에 런타임 오류가 발생할 수 있습니다.
</ p>
<p>
가능하면 내부 클래스를 static으로 문제를 해결해야합니다.
외부 클래스를 직렬화 가능하게하는 방식으로 작동 할지도 모르지만, 내부 클래스의 인스턴스를 직렬화하는 것은 외부 클래스도 항상 직렬화하는 것을 의미합니다.
정말로 원하는 것입니까?
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SE_INN​​ER_CLASS">
    <ShortDescription> 직렬화 가능한 내부 클래스 </ ShortDescription>
    <LongDescription> {0}는 직렬화 가능한 내부 클래스입니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 직렬화 가능한 클래스는 내부 클래스입니다.
내부 클래스를 직렬화하려고와 관련된 외부 클래스의 인스턴스를 직렬화합니다.
외부 클래스의 인스턴스는 직렬화 가능하므로 실패하지 않지만, 의도 한 것보다 더 훨씬 많은 데이터를 직렬화하는지도 모릅니다.
가능하면 내부 클래스를 static으로 문제를 해결해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SE_BAD_FIELD_STORE">
    <ShortDescription> 직렬화 가능한 값을 직렬화 가능 클래스의 인스턴스 필드에 들어있는 </ ShortDescription>
    <LongDescription> 비 transient 필드 {1.givenClass}에 {2}을 포함하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
직렬화 가능한 값을 직렬화 가능 클래스의 비 transient 필드에 저장합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SC_START_IN_CTOR">
    <ShortDescription> Thread.start ()를 호출하는 생성자 </ ShortDescription>
    <LongDescription> {1} {2}를 호출합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
생성자가 스레드를 시작합니다. 클래스가 확장되고, 서브 클래스가 만들어진다면 잘못 높습니다.
왜냐하면, 서브 클래스의 생성자에서 스레드가 시작되기 전에, 슈퍼 클래스의 스레드가 시작되기 때문입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SS_SHOULD_BE_STATIC">
    <ShortDescription> 읽어 않는 필드 </ ShortDescription>
    <LongDescription> 읽어 않는 필드 : {1};이 필드는 static으로해야하나요? </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 컴파일시에 정적 인 값으로 초기화되는 인스턴스 final 필드가 있습니다.
static 필드하는 것이 좋습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="UUF_UNUSED_FIELD">
    <ShortDescription> 미사용 필드 </ ShortDescription>
    <LongDescription> 미사용 필드 : {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 필드는 절대로 사용하지 않습니다. 클래스에서 제거하는 것이 좋습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="URF_UNREAD_FIELD">
    <ShortDescription> 읽어 않는 필드 </ ShortDescription>
    <LongDescription> 읽어 않는 필드 : {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 필드는 결코 읽히지 않습니다. 클래스에서 제거하는 것이 좋습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription> 미사용 public 또는 protected 필드 </ ShortDescription>
    <LongDescription> 미사용 public 또는 protected 필드 : {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 필드는 결코 사용되지 않습니다.
필드는 public 또는 protected이므로, 아마 그것은 분석의 일부로 보이지 않는 클래스에서 사용되는 것을 의도하고 있습니다.
그렇지 않으면 클래스에서 제거하는 것을 고려하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription> 읽은없는 public 또는 protected 필드 </ ShortDescription>
    <LongDescription> 읽은없는 public 또는 protected 필드 : {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 필드는 결코 읽히지 않습니다.
필드는 public 또는 protected이므로, 아마 그것은 분석의 일부로 보이지 않는 클래스에서 사용되는 것을 의도하고 있습니다.
그렇지 않으면 클래스에서 제거하는 것을 고려하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="QF_QUESTIONABLE_FOR_LOOP">
    <ShortDescription> 복잡하거나 성공적인하거나 틀린 증가의 for 루프 </ ShortDescription>
    <LongDescription> 복잡하거나 성공적인하거나 틀린 증가의 for 루프입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
정말이 for 루프가 올바른 변수를 증가하고 있습니까?
다른 변수가 for 루프에 의해 초기화되어, 체크되는 것 같습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="UWF_NULL_FIELD">
    <ShortDescription> null로 설정되는만큼 필드 </ ShortDescription>
    <LongDescription> null로 설정되는만큼 필드 : {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 필드에 상수 값 null을 씁니다. 따라서 필드의 읽기는 null를 돌려줍니다.
오류를 확인하십시오. 사용하지 않으면 제거하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription> 기록 있지되지 않은 public 또는 protected 필드 </ ShortDescription>
    <LongDescription> 기록되지 않은 public 또는 protected 필드 : {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 public 또는 protected 필드는 기록되지 않습니다. 이 필드에서 읽기는 기본 값을 반환합니다.
오류를 확인하십시오 (필드는 초기화해야 했습니까?) 사용하지 않으면 제거하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="UWF_UNWRITTEN_FIELD">
    <ShortDescription> 기록되지 않은 필드 </ ShortDescription>
    <LongDescription> 기록되지 않은 필드 : {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 필드는 결코 기록되지 않습니다. 이 필드에서 읽기는 기본 값을 반환합니다.
오류를 확인하십시오 (필드는 초기화해야 했습니까?) 사용하지 않으면 제거하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD">
    <ShortDescription> 인스턴스 메소드에서 static 필드에 쓰기 </ ShortDescription>
    <LongDescription> 인스턴스 메소드 {1} static 필드 {2}에 기록하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 인스턴스 메서드는 static 필드에 기록하고 있습니다.
여러 인스턴스가 작동되어 있다면 제대로시키는 것은 어렵다. 일반적으로 잘못된 방법입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_LOAD_OF_KNOWN_NULL_VALUE">
    <ShortDescription> null로 알고있는 값의로드 </ ShortDescription>
    <LongDescription> null로 알고있는 값을로드합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
여기에서 참조되는 변수는 이전에 null인지 체크하고 있기 때문에 null 인 것을 알고 있습니다.
이것은 유효 할지도 모르고 실수일지도 모릅니다 (아마 다른 변수를 참조하는 것을 목적으로했습니다 또는 이전 null 검사 null 아닌가 확인해야했다).
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_DEREFERENCE_OF_READLINE_VALUE">
    <ShortDescription> readLine 메소드의 결과가 null인지 확인하지 값을 이용하고있다 </ ShortDescription>
    <LongDescription> readLine 메소드의 결과가 null인지 확인하지 값을 이용하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> readLine </ code> 메소드의 결과가 null인지 확인하지 값을 이용하고 있습니다.
<code> readLine </ code> 메소드는 더 이상 읽을 텍스트 행이 없으면 null을 반환하기 때문에 NullPointerException이 발생합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_IMMEDIATE_DEREFERENCE_OF_READLINE">
    <ShortDescription> readLine 메소드의 결과를 빨리 이용하고있다 </ ShortDescription>
    <LongDescription> readLine 메소드의 결과를 즉시 사용할 수 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> readLine </ code> 메소드의 결과를 즉시 사용할 수 있습니다.
<code> readLine </ code> 메소드는 더 이상 읽을 텍스트 행이 없으면 null을 반환하기 때문에 NullPointerException이 발생합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_UNWRITTEN_FIELD">
	<ShortDescription> 기록되지 않은 필드의 읽기 </ ShortDescription>
    <LongDescription> 기록되지 않은 필드 {2.name}를 읽어 내고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
프로그램은 결코 null이 아닌 값을 쓸 생각되지 않는 필드 값을 이용하고 있습니다.
이 값을 사용하면 NullPointerException이 발생합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription> 기록되지 않은 public 또는 protected 필드의 읽기 </ ShortDescription>
    <LongDescription> 기록되지 않은 public 또는 protected 필드 {2.name}를 읽어 내고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
프로그램은 결코 null 값이 아닌 값을 쓸 생각하지 public 또는 protected 필드의 null 값을 이용하고 있습니다.
필드가 해석에 의해 볼 수없는 기능을 통해 초기화되지 않는 한,이 값을 사용하면 NullPointerException이 발생합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SIC_THREADLOCAL_DEADLY_EMBRACE">
    <ShortDescription> 비 static 내부 클래스와 스레드 로컬 교착 </ ShortDescription>
    <LongDescription> {0} {1}과의 교착 상태를 해결하기 위해 static으로해야합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 내부 클래스이지만, 아마 static 내부 클래스에해야합니다.
실제로는 내부 클래스와 외부 클래스 스레드 로컬 사이에 교착 상태의 심각한 위험이 있습니다.
내부 클래스가 static이 아니기 때문에 외부 클래스에 대한 참조를 유지합니다.
스레드 로컬 내부 클래스 인스턴스의 참조가 있다면, 내부와 외부의 인스턴스가 모두 도달 할 수 가비지되지 않습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC">
    <ShortDescription> static 내부 클래스에해야 </ ShortDescription>
    <LongDescription> {0}는 static 내부 클래스에해야합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 내부 클래스인데 그것을 만든 개체에 포함 된 참조를 사용하지 않습니다.
이 참조는 더 큰 클래스의 인스턴스를 생성하고, 필요 이상으로 오랫동안 만들기 개체에 대한 참조를 존속하는 것이 있을지도 모릅니다.
있다면 클래스는 static으로해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR">
    <ShortDescription> 생성자에서 초기화되지 않은 필드를 null 체크없이 null 값을 이용하고있다 </ ShortDescription>
    <LongDescription> {1.givenClass}는 생성자에서 초기화되지 않습니다. {2}에서 null 값을 이용하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 필드는 어떤 생성자 중에서도 결​​코 초기화되지 않습니다. 따라서 개체가 생성 된 후, null 일 가능성이 있습니다.
어딘가 다른 곳에서 값이로드되어, null 검사없이 null 값이 사용됩니다.
필드가 초기화되기 전에 사용하면 NullPointerException이 발생하므로 부정확 또는 의심 설계지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC_ANON">
    <ShortDescription> 명명 된 static 내부 클래스로 리팩토링 할 수 있을지도 모른다 </ ShortDescription>
    <LongDescription> 클래스 {0}은 명명 된 static 내부 클래스로 리팩토링 할 수 있을지도 모릅니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 내부 클래스인데 그것을 만든 개체에 포함 된 참조를 사용하지 않습니다.
이 참조는 더 큰 클래스의 인스턴스를 생성하고, 필요 이상으로 길게 만들 개체에 대한 참조를 존속하는 것이 있을지도 모릅니다.
있다면 클래스는 static 내부 클래스에해야합니다.
무명 내부 클래스는 static으로 할 수 없기 때문에 명명 된 내부 클래스 리팩토링해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS">
    <ShortDescription> static 내부 클래스로 리팩토링 할 수 있을지도 모른다 </ ShortDescription>
    <LongDescription> 클래스 {0}은 static 내부 클래스로 리팩토링 할 수 있을지도 모릅니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 내부 클래스인데 그것을 만든 개체에 포함 된 참조를 사용하지 않습니다.
이 참조는 더 큰 클래스의 인스턴스를 생성하고, 필요 이상으로 길게 만들 개체에 대한 참조를 존속하는 것이 있을지도 모릅니다.
있다면 클래스는 static 내부 클래스에해야합니다.
외부 개체에 대한 참조가 내부 클래스의 인스턴스를 구축하는 동안 필요한 때문에 내부 클래스의 생성자에 외부 인스턴스에 대한 참조를 전달하도록 리팩토링해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="WA_NOT_IN_LOOP">
    <ShortDescription> wait 메소드가 루프에없는 </ ShortDescription>
    <LongDescription> wait 메소드가 루프에 없습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 루프없는 <code> java.lang.Object.wait () </ code>을 호출합니다.
모니터가 여러 조건을 위해 사용될 경우, 호출자가 대기 거라고 조건은 실제로는 발생하지 않을지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="WA_AWAIT_NOT_IN_LOOP">
    <ShortDescription> Condition.await ()가 루프에없는 </ ShortDescription>
    <LongDescription> Condition.await ()가 루프에 없습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 루프없는 <code> java.util.concurrent.await () </ code> (또는 변형)을 호출합니다.
개체가 여러 조건을 위해 사용될 경우, 호출자가 대기 거라고 조건은 실제로는 발생하지 않을지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NO_NOTIFY_NOT_NOTIFYALL">
    <ShortDescription> notifyAll 메서드 대신 notify 메소드를 사용하는 </ ShortDescription>
    <LongDescription> notifyAll 메서드 대신 notify 메소드를 사용하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 <code> notifyAll </ code> 메서드 대신 <code> notify </ code> 메소드를 호출합니다.
모니터가 여러 조건 때문에 종종 사용됩니다.
<code> notify </ code> 메서드 호출은 하나의 스레드를 일으키는 것만으로 일어난 스레드는 호출이 충족 대기 조건 중 하나가 아닐지도 모른다는 것을 의미합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RV_CHECK_FOR_POSITIVE_INDEXOF">
    <ShortDescription> String.indexOf 결과가 올바른지 확인하고있다 </ ShortDescription>
    <LongDescription> String.indexOf 결과가 올바른지 확인합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메소드는 <code> String.indexOf </ code>를 호출하여 결과가 올바른지 확인합니다.
결과가 음수인지 확인하는 것이 훨씬 일반적입니다. 체크되는 부분 문자열 선두 이외의 장소에서 출현하는 경우에만 양수가됩니다.

</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RV_DONT_JUST_NULL_CHECK_READLINE">
    <ShortDescription> readLine 메소드의 결과를 null 아닌가 확인 후 버리고있는 </ ShortDescription>
    <LongDescription> {1}는 readLine 메소드의 결과를 null 아닌가 확인 후 버리고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> readLine </ code> 메소드의 반환 값을 null 아닌가 확인 후 버리고 있습니다.
거의 모든 상황에서 결과가 null이 아니라면 반환 값을 사용하고 싶을 것이다.
다시 <code> readLine </ code> 메소드를 호출하면 다른 행을 얻을 수 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED_INFERRED">
    <ShortDescription> 메소드는 반환 값을 무시하고 있습니다, 이것은 실수가 아닙니까? </ ShortDescription>
    <LongDescription> {2.givenClass}의 반환 값을 무시하고 있습니다, 이것은 실수가 아닙니까? {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 메서드를 호출하여 반환 값을 무시하고 있습니다.
반환 값은 메서드 호출 형태와 같은 형태입니다. 그리고 우리의 분석에서 반환 값이 중요일지도 모른다 보입니다 (예 <code> String.toLowerCase () </ code>의 반환 값을 무시하는듯한).
</ p>
<p>
우리는 반환 값을 무시할 수 메서드 본문의 단순한 분석에서 나쁜 생각지도 모른다고 추측하고 있습니다.
이 메소드의 반환 값을 무시하는 것이 중요하다 또는 허용 할 수 있는지에 대해 FindBugs에 지시 @ CheckReturnValue 주석을 사용할 수 있습니다.
</ p>
<p>
반환 값을 무시하는 것이 틀림이 아닐까 결정하기 위해 엄격하게 조사하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED">
    <ShortDescription> 반환 값을 무시하는 방법 </ ShortDescription>
    <LongDescription> {2.givenClass}의 반환 값을 무시하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메소드의 반환 값은 확인해야합니다.
이 경고의 일반적인 원인은 개체가 업데이트된다고 생각 불변 객체의 메소드를 호출하는 것입니다. <br>
예를 들어 다음과 같은 코드입니다.
</ p>
<blockquote> <pre>
String dateString = getHeaderField (name);
dateString.trim ();
</ pre> </ blockquote>
<p>
프로그래머는 <code> trim </ code> 메소드가 <code> dateString </ code>가 참조하는 String 개체가 업데이트된다고 생각합니다.
그러나, String 객체는 불변, <code> trim </ code> 메소드가 새로운 String 객체를 반환 무시하고 있습니다.
이 코드는 다음과 같이 수정해야합니다.
</ p>
<blockquote> <pre>
String dateString = getHeaderField (name);
dateString = dateString.trim ();
</ pre> </ blockquote>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED_BAD_PRACTICE">
    <ShortDescription> 예외 반환 값을 무시하는 방법 </ ShortDescription>
    <LongDescription> {2} 예외 반환 값을 무시하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 체크되지 않은 값을 반환합니다.
반환 값은 이상 의외의 결과를 나타낼 수 있으므로 확인해야합니다.
예를 들어, <code> File.delete () </ code> 파일을 잘 제거 할 수 없었던 경우에 예외를 throw하는 대신 false를 반환합니다.
결과를 확인하지 않으면 예외 반환 값을 메서드 호출에서 의외의 행동의 신호로 인식하지 못합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE">
    <ShortDescription> compareTo 의해 반환 된 특정 값 코드 확인 </ ShortDescription>
    <LongDescription> {2.givenClass}의 반환 값이 {3}과 동일한 지 확인하십시오. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 compareTo 또는 compare 메소드를 호출 해, 반환 값이 특정 값 (예를 들어 1 또는 -1)인지 확인합니다.
이러한 메소드를 호출 할 때 특정 제로 이외의 값이 아니라 결과의 부호 만 확인해야합니다.
다수 또는 대부분의 compareTo와 비교 메서드는 -1 또는 1을 반환하지만, 일부는 다른 값을 반환합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  
  <BugPattern type="RV_EXCEPTION_NOT_THROWN">
    <ShortDescription> 만든 예외를 던질 것이 아니라 버리고있는 </ ShortDescription>
    <LongDescription> {2.givenClass}을 발생하지 않습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 예외 또는 오류 개체를 만들고 있는데 아무것도하지 않습니다. <br>
예를 들어 다음과 같은 코드입니다.
</ p>
<blockquote> <pre>
if (x <0) {
    new IllegalArgumentException ( "x must be nonnegative");
}
</ pre> </ blockquote>
<p>
아마 프로그래머의 의도는 만든 예외를 던질 것이 었습니다.
</ p>
<blockquote> <pre>
if (x <0) {
    throw new IllegalArgumentException ( "x must be nonnegative");
}
</ pre> </ blockquote>
]]>
    </ Details>
  </ BugPattern>

  

  <BugPattern type="NP_ALWAYS_NULL">
    <ShortDescription> null 값을 이용하고있다 </ ShortDescription>
    <LongDescription> {2.givenClass}의 null 값을 이용하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
여기서 null 값을 이용하려고합니다.
코드가 실행되면 NullPointerException이 발생합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_CLOSING_NULL">
    <ShortDescription> 항상 null 값 개체에서 close 메소드를 호출하는 </ ShortDescription>
    <LongDescription> 항상 null이므로 {2.givenClass}을 닫을 수 없습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> close </ code> 메서드는 항상 null 값 개체에서 호출됩니다.
이 문이 실행된다면 NullPointerException이 발생합니다.
여기서 청산해야 뭔가를 결코 청산하지 않는다는 큰 위험이 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_STORE_INTO_NONNULL_FIELD">
    <ShortDescription> @ NonNull에서 어노테이션 된 필드에 null을 포함하는 </ ShortDescription>
    <LongDescription> @ NonNull에서 어노테이션 된 필드 {2.givenClass}에 null을 포함하고 있습니다. {1} </ LongDescription>
    <Details>
      <! [CDATA [
<p>
@ NonNull에서 어노테이션 된 필드에 null지도 모른다 값을 포함하고 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_ALWAYS_NULL_EXCEPTION">
    <ShortDescription> null 값을 예외 경로로 이용하고있다 </ ShortDescription>
    <LongDescription> {2.givenClass}의 null 값을 예외 경로로 이용하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
예외 경로에 여기에서 null 값을 이용하고 있습니다.
코드가 실행되면 NullPointerException이 발생합니다.
현재 FindBugs는 실행 불가능한 예외 경로를 제거하지 않기 때문에, 잘못된 판단 할지도 모른다주의하십시오.
</ p>
<p>
switch 문의 default가 많은 경우 실행 불가능하므로 FindBugs 예외 경로 인 default를 검토하는 것에주의하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE">
    <ShortDescription> 매개 변수는 비 null이어야하지만 null 가능으로 어노테이션 된 </ ShortDescription>
    <LongDescription> {2}는 비 null이어야하지만, null 가능으로 어노테이션되어 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 매개 변수는 항상 비 null하는 것을 요구하는 방법으로 사용되지만 매개 변수는 명시 적으로 null 가능으로 어노테이션되어 있습니다.
매개 변수 또는 주석 중 하나의 사용법이 잘못되었습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  
  <BugPattern type="NP_NULL_ON_SOME_PATH">
    <ShortDescription> null 값을 사용하는 가능성이있다 </ ShortDescription>
    <LongDescription> {2.givenClass}의 null 값을 사용하고있을 수 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
그래서 분기 또는 문이 실행된다면 null 값이 이용되고 NullPointerException이 발생합니다.
물론, 문제는 분기 또는 문장이 실행 불가능한, NullPointerException가 결코 발생할 수없는 것일지도 모릅니다.
그것을 결정하는 것은 FindBugs의 능력을 초과합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE">
    <ShortDescription> null 값을 실행 불가능할지도 모른다 분기에 이용하고있을 가능성이있는 </ ShortDescription>
    <LongDescription> {2.givenClass}의 null 값을 실행 불가능할지도 모른다 분기에 이용하고있을 수 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
분기 또는 문이 실행된다면, null 값이 이용되고 NullPointerException이 발생합니다.
물론, 문제는 분기 또는 문장이 실행 불가능한, NullPointerException가 결코 발생할 수없는 것일지도 모릅니다.
그것을 결정하는 것은 FindBugs의 능력을 초과합니다.
이 값이 이미 null임을 검사했다는 사실에서 이것은 확실히 가능성입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_NULL_ON_SOME_PATH_EXCEPTION">
    <ShortDescription> null 값을 예외 경로로 이용하고있을 가능성이있는 </ ShortDescription>
    <LongDescription> {2.givenClass}의 null 값을 예외 경로로 이용하고있을 가능성이 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
예외 경로에 여기에서 null 값이 이용되고 있습니다.
코드가 실행되면 NullPointerException가 발생할지도 모릅니다.
현재 FindBugs는 실행 불가능한 예외 경로를 제거하지 않기 때문에, 잘못된 판단 할지도 모른다주의하십시오.
</ p>
<p>
switch 문의 default가 많은 경우 실행 불가능하므로 FindBugs 예외 경로 인 default를 검토하는 것에주의하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE">
    <ShortDescription> null이있을 가능성이있는 메소드의 반환 값을 이용하고있다 </ ShortDescription>
    <LongDescription> null이있을 가능성이있는 메소드의 반환 값을 이용하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
메소드의 반환 값을 null 체크하지 사용하고 있습니다. 메소드의 반환 값은 null인지 확인해야합니다.
코드가 실행되면 NullPointerException가 발생할지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_NULL_PARAM_DEREF_NONVIRTUAL">
    <ShortDescription> 비 null 매개 변수에 null을 전달하는 비 가상 메서드 호출 </ ShortDescription>
    <LongDescription> 비 가상 메서드 {2.givenClass} 비 null 매개 변수에 null을 전달 호출합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
null의 가능성이있는 값이 비 null 메서드 매개 변수로 전달됩니다.
매개 변수는 항상 비 null이되어야 매개 변수로 어노테이션되어했거나 분석이 항상 null 값을 이용하면 표시했습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS">
    <ShortDescription> 메서드 호출은 비 null 매개 변수에 null을 전달하는 </ ShortDescription>
    <LongDescription> {2.givenClass} 비 null 매개 변수에 null을 전달합니다. {1} </ LongDescription>
    <Details>
      <! [CDATA [
<p>
아마 모든 알려진 대상 메서드가 null 인 것을 요구하는 호출 장소에서 null 값을 전달합니다.
매개 변수는 항상 비 null이되어야 매개 변수로 어노테이션되어했거나 분석이 항상 null 값을 이용하면 표시했습니다.
</ p>
      ]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_NULL_PARAM_DEREF">
    <ShortDescription> 메서드 호출은 비 null 매개 변수에 null을 전달하는 </ ShortDescription>
    <LongDescription> {2.givenClass} 비 null 매개 변수에 null을 전달합니다. {1} </ LongDescription>
    <Details>
      <! [CDATA [
<p>
이 메서드 호출은 비 null 메서드 매개 변수에 null 값을 전달합니다.
매개 변수는 항상 비 null이되어야 매개 변수로 어노테이션되어했거나 분석이 항상 null 값을 이용하면 표시했습니다.
</ p>
      ]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_NONNULL_PARAM_VIOLATION">
    <ShortDescription> 메서드 호출은 비 null 매개 변수에 null을 전달하는 </ ShortDescription>
    <LongDescription> {2.givenClass} 비 null 매개 변수에 null을 전달합니다. {1} </ LongDescription>
    <Details>
      <! [CDATA [
<p>
이 방법은 비 null이어야한다 메소드의 매개 변수로 null 값을 전달합니다.
이 매개 변수는 @ Nonnull로 명시 적으로 어노테이션되어했거나 분석이 항상 null 값을 이용하면 표시했습니다.
</ p>
      ]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_NONNULL_RETURN_VIOLATION">
    <ShortDescription> null을 반환 할지도 모른다 메소드가 @ NonNull 선언 된 </ ShortDescription>
    <LongDescription> {1}는 null을 반환 할지도 모르다 @ NonNull 선언되어 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 null 값을 반환 할지도 모르다 메소드 (또는 슈퍼 클래스의 메소드)의 반환 값에 @ NonNull가 선언되어 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_CLONE_COULD_RETURN_NULL">
    <ShortDescription> null을 반환 할지도 모른다 clone 메소드 </ ShortDescription>
    <LongDescription> {1}는 null을 반환 할지도 모릅니다. </ LongDescription>
    <Details>
      <! [CDATA [
<p>
이 <code> clone </ code> 메소드는 어떤 조건에서 null을 반환하는 것으로합니다.
그러나 <code> clone </ code> 메소드는 결코 null를 돌려주는 것은 허용되지 않습니다.
이 경로가 도달 할 수없는 것을 확신하고 있다면, 대신 <code> AssertionError </ code>를 throw합니다.
</ p>
      ]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="NP_TOSTRING_COULD_RETURN_NULL">
    <ShortDescription> null을 반환 할지도 모른다 toString 메소드 </ ShortDescription>
    <LongDescription> {1}는 null을 반환 할지도 모릅니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 <code> toString </ code> 메소드는 어떤 조건에서 null을 반환하는 것으로합니다.
사양을 관대하게 읽고이 허용되는 것으로 해석 할 수 있을지도 모릅니다 만, 아마 잘못된 생각에서 다른 코드가 깨지는 원인이 될 수 있습니다.
null 대신 빈 문자열 또는 일부 다른 적절한 문자열을 반환합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_GUARANTEED_DEREF">
    <ShortDescription> null 값을 사용하는 것이 보증되는 </ ShortDescription>
    <LongDescription> {2.givenClass}는 null 값을 사용하는 것이 보증되고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
문 분기가 실행된다면 이제 값은 null이고, null 값을 사용하는 (전달 경로에서 런타임 예외를 수반하는 것 이외는) 보장되어 있습니다.
</ p>
<p>
또한 <code> if (x == null) throw new NullPointerException (); </ code>는 <code> x </ code>의 참조 해제로 처리된다는 점에 유의하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH">
    <ShortDescription> null 값을 예외 경로로 이용이 보장 된 </ ShortDescription>
    <LongDescription> {2.name} 예외 경로에서 null 값을 사용하는 것이 보증되고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
예외 경로의 문 분기가 실행된다면 이제 값은 null이고, null 값을 사용하는 (전달 경로에서 런타임 예외를 수반하는 것 이외는) 보장되어 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SI_INSTANCE_BEFORE_FINALS_ASSIGNED">
    <ShortDescription> 정적 이니셜 라이저는 모든 static final 필드가 할당되기 전에 인스턴스 만들기 </ ShortDescription>
    <LongDescription> {0}에 대한 정적 이니셜 라이저는 모든 static final 필드가 할당되기 전에 인스턴스를 만듭니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
모든 static final 필드가 초기화되기 전에 정적 이니셜 라이저는 클래스의 인스턴스를 만듭니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="OS_OPEN_STREAM">
    <ShortDescription> 스트림 닫기에 실패 할지도 모른다 방법 </ ShortDescription>
    <LongDescription> {1}는 스트림 닫기에 실패 할지도 모릅니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 출력 스트림 객체를 생성하고 있는데 어떤 필드에도 할당하지 않으며 청산 할지도 모른다 다른 방법으로도 전달되지 않으며, 반환 값도 없습니다. 그리고 메소드에서 모든 경로에서 청산하도록 보이지 않습니다.
이것은 파일 기술자 누수가 될지도 모릅니다.
스트림이 폐쇄되는 것을 보장하기 위해 <code> finally </ code> 블록을 사용하는 것은 일반적으로 좋은 생각입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="OS_OPEN_STREAM_EXCEPTION_PATH">
    <ShortDescription> 예외 경로 스트림 닫기에 실패 할지도 모른다 방법 </ ShortDescription>
    <LongDescription> {1} 예외 경로 스트림 닫기에 실패 할지도 모릅니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 출력 스트림 객체를 생성하고 있는데 어떤 필드에도 할당하지 않으며 청산 할지도 모른다 다른 방법으로도 전달되지 않으며, 반환 값도 없습니다. 그리고 방법에서 모든 가능성이있는 예외 경로로 청산하도록 보이지 않습니다.
이것은 파일 기술자 누수가 될지도 모릅니다.
스트림이 폐쇄되는 것을 보장하기 위해 <code> finally </ code> 블록을 사용하는 것은 일반적으로 좋은 생각입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="PZLA_PREFER_ZERO_LENGTH_ARRAYS">
    <ShortDescription> null 대신 길이가 0의 배열을 돌려주는 것을 검토 </ ShortDescription>
    <LongDescription> {1}는 null 대신 길이가 0의 배열을 돌려 주어야하지 않겠습니까? </ LongDescription>
    <Details>
<! [CDATA [
<p>
결과가 없다 (즉, 결과의 빈 목록)을 나타 내기 위해 null 참조가 아닌 길이가 0의 배열을 반환하는 것은 많은 경우 더 나은 디자인입니다.
</ p>
<p>
다른 한편으로는 "이 질문에 대한 답이 없음"을 나타 내기 위해 null을 사용하는 것은 아마 좋습니다.
예를 들어, <code> File.listFiles () </ code> 파일이없는 디렉토리를 주어진 경우는 하늘의리스트를 돌려 파일이 디렉토리가 아니라면 null을 반환합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="UCF_USELESS_CONTROL_FLOW">
    <ShortDescription> 쓸모없는 제어 흐름 </ ShortDescription>
    <LongDescription> 쓸모없는 제어 흐름입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 분기하는지 여부에 관계없이 제어 흐름이 동일한 위치에 이어지는 쓸모없는 제어 흐름 문이 있습니다. <br>
예를 들어, 이것은 빈 <code> if </ code> 글이 원인이됩니다.
<blockquote> <pre>
if (argv.length == 0) {
    / / TODO : handle this case
}
</ pre> </ blockquote>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="UCF_USELESS_CONTROL_FLOW_NEXT_LINE">
    <ShortDescription> 다음 줄에 계속 그냥 쓸모없는 제어 흐름 </ ShortDescription>
    <LongDescription> 다음 줄에 계속 그냥 쓸모없는 제어 흐름입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 분기하는지 여부에 관계없이 제어 흐름이 같은지 다음 행으로 이어지는, 쓸모없는 제어 흐름 문이 있습니다. <br>
종종 부주의하게 <code> if </ code> 문의 본체를 공문을 사용한 것이 원인이됩니다.
</ p>
<blockquote> <pre>
if (argv.length == 1);
    System.out.println ( "Hello"+ argv [0]);
</ pre> </ blockquote>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE">
    <ShortDescription> 이미 사용하고 있던 값의 null 체크 </ ShortDescription>
    <LongDescription> 이미 사용하고 있던 {2.givenClass} 값을 {4.lineNumber}에서 null 체크하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
여기에 값이 null인지 체크하고 있습니다 만, 이미 값을 사용했기 때문에 null 일 가능성은 없습니다.
값이 null이라면 이전의 이용에서 NullPointerException이 발생했을 것입니다.
기본적으로이 값이 null 인 것을 허락 여부에 관계없이이 코드와 이전 값의 이용은 일치하지 않습니다.
검사는 중복 또는 이전 값의 사용이 잘못되었습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE">
    <ShortDescription> null로 알고있는 값의 중복 null 체크 </ ShortDescription>
    <LongDescription> null로 알려진 값 {2}의 중복 null 체크가 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메소드는 null로 알고있는 값의 중복 null 체크가 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE">
    <ShortDescription> null이 아닌 것을 알고있는 값의 중복 null 체크 </ ShortDescription>
    <LongDescription> null이 아닌 것을 알고있는 값 {2}의 중복 null 체크가 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메소드는 null이 아닌 것을 알고있는 값의 중복 null 체크가 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES">
    <ShortDescription> 2 개의 null 값 중복 비교 </ ShortDescription>
    <LongDescription> 2 개의 null 값 중복 비교합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메소드는 모두 분명히 null로 알려진 두 참조 중복 비교합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE">
    <ShortDescription> null이 아닌 값과 null 값과 중복 비교 </ ShortDescription>
    <LongDescription> null이 아닌 값과 null 값과 중복 비교합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메소드는 null이 아닌 것을 알고있는 참조와 null로 알려진 다른 참조와 비교합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RCN_REDUNDANT_CHECKED_NULL_COMPARISON" deprecated="true"> <! - deprecated in favor of two separate RCN_ patterns ->
    <ShortDescription> Redundant comparison to null of previously checked value </ ShortDescription>
    <LongDescription> Redundant comparison to null of previously checked {2} in {1} </ LongDescription>
    <Details>
<! [CDATA [
<p> This method contains a redundant comparison of a reference value
to null. Two types of redundant comparison are reported :
</ p>
<ul>
<li> Both values​​ compared are definitely null </ li>
<li> One value is definitely null and the other is definitely not null </ li>
</ ul>

<p> This particular warning generally indicates that a
value known not to be null was checked against null.
While the check is not necessary, it may simply be a case
of defensive programming </ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="UL_UNRELEASED_LOCK">
    <ShortDescription> 모든 경로에서 잠금이 해제되지 않는 방법 </ ShortDescription>
    <LongDescription> {1}은 모든 경로에서 잠금이 해제되지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 JSR-166 (<code> java.util.concurrent </ code>)의 락을 획득하고 있는데 메소드에서 모든 경로에서 해제하지 않습니다.
일반적으로 JSR-166의 잠금을 사용하는 올바른 관용구는 다음과 같습니다.
</ p>
<blockquote> <pre>
Lock l = ...;
l.lock ();
try {
    / / do something
} finally {
    l.unlock ();
}
</ pre> </ blockquote>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="UL_UNRELEASED_LOCK_EXCEPTION_PATH">
    <ShortDescription> 모든 예외 경로에서 잠금이 해제되지 않는 방법 </ ShortDescription>
    <LongDescription> {1} 모든 예외 경로에서 잠금이 해제되지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 JSR-166 (<code> java.util.concurrent </ code>)의 락을 획득하고 있는데 메서드에서 모든 예외 경로에서 해제하지 않습니다.
일반적으로 JSR-166의 잠금을 사용하는 올바른 관용구는 다음과 같습니다.
</ p>
<blockquote> <pre>
Lock l = ...;
l.lock ();
try {
    / / do something
} finally {
    l.unlock ();
}
</ pre> </ blockquote>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RC_REF_COMPARISON">
    <ShortDescription> 의심 참조 비교 </ ShortDescription>
    <LongDescription> {2} 참조 비교는 의심입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 == 또는! = 연산자를 사용하여 두 참조 값을 비교하고 있습니다.
이 형식의 인스턴스를 비교하는 올바른 방법은 일반적 <code> equals </ code> 메소드입니다.
등가 식별 가능한 인스턴스를 만들 수 있지만, 다른 개체이므로 ==로 비교하지 마십시오.
참조로 보통 비교 안된다 클래스의 예는 <code> java.lang.Integer </ code>, <code> java.lang.Float </ code> 등입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RC_REF_COMPARISON_BAD_PRACTICE">
    <ShortDescription> 상수의 의심 참조 비교 </ ShortDescription>
    <LongDescription> {2} 상수 참조 비교는 의심입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 == 또는! = 연산자를 사용하여 상수와 비교하고 있습니다.
이 형식의 인스턴스를 비교하는 올바른 방법은 일반적 <code> equals </ code> 메소드입니다.
등가 식별 가능한 인스턴스를 만들 수 있지만, 다른 개체이므로 ==로 비교하지 마십시오.
참조로 보통 비교되는 안된다 클래스의 예는 <code> java.lang.Integer </ code>, <code> java.lang.Float </ code> 등입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN">
    <ShortDescription> Boolean 값 의심 참조 비교 </ ShortDescription>
    <LongDescription> Boolean 값 의심 참조 비교입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 == 또는! = 연산자를 사용하여 두 Boolean 값을 비교하고 있습니다.
일반적으로 두 Boolean 값 (<code> Boolean.TRUE </ code>와 <code> Boolean.FALSE </ code>) 뿐이지 만,
<code> new Boolean (b) </ code> 생성자를 사용하여 다른 Boolean 개체를 만들 수 있습니다.
그런 객체를 피할 최고입니다.
하지만 그들이 존재한다면, Boolean 객체의 동등성을 확인하기 위해 <code>. equals (...) </ code> 대신 == 또는! =를 사용한다면 다른 결과를 가져옵니다 .
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="EC_UNRELATED_TYPES_USING_POINTER_EQUALITY">
    <ShortDescription> 참조 등가성을 사용하여 다른 형식을 비교하는 </ ShortDescription>
    <LongDescription> {2.givenClass}을 {3.givenClass}과 비교하기 위해 참조 등가성을 사용하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 다른 형태라고 생각되는 2 개의 참조를 비교하기 위해 참조 등가성을 사용하고 있습니다.
이 비교의 결과는 항상 false입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="EC_UNRELATED_TYPES">
    <ShortDescription> equals 메서드를 호출하여 다른 형식을 비교하는 </ ShortDescription>
    <LongDescription> {3.simpleClass} equals ({2.simpleClass})를 호출합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 일반적인 서브 클래스가없는 다른 클래스 형의 두 개체 참조 <code> equals (Object) </ code> 메소드를 호출합니다.
따라서, 비교되는 두 개체는 런타임에 같은 클래스의 멤버 일 가능성이 낮습니다 (일부 응용 프로그램 클래스를 해석 할 수 없거나 동적 클래스 로딩이 실행시에 발생할 수있는 경우를 제외 ).
<code> equals </ code> 메소드의 규약에 의하면, 다른 클래스의 객체는 항상 같지 않음으로 비교해야합니다.
따라서 <code> java.lang.Object.equals (Object) </ code>에 정의 된 규칙에 따르면,이 비교의 결과는 실행시 항상 false입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="EC_UNRELATED_INTERFACES">
    <ShortDescription> equals 메소드를 호출 해 다른 형태의 인터페이스를 비교하고있다 </ ShortDescription>
    <LongDescription> {3.simpleClass} equals ({2.simpleClass})를 호출합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 모두 다른 서브 타입이 아닌 독립적 인 인터페이스 형의 두 참조 <code> equals (Object) </ code> 메소드를 호출합니다.
그리고 두 인터페이스를 구현하는 기존의 비 추상 클래스가 없습니다.
따라서, 비교되는 두 개체는 런타임에 같은 클래스의 멤버 일 가능성이 낮습니다 (일부 응용 프로그램 클래스를 해석 할 수 없거나 동적 클래스 로딩이 실행시에 발생할 수있는 경우를 제외 ).
<code> equals </ code> 메소드의 규약에 의하면, 다른 클래스의 객체는 항상 같지 않음으로 비교해야합니다.
따라서 <code> java.lang.Object.equals (Object) </ code>에 정의 된 규칙에 따르면,이 비교의 결과는 실행시 항상 false입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="EC_UNRELATED_CLASS_AND_INTERFACE">
    <ShortDescription> equals 메소드를 호출 관계의 클래스와 인터페이스를 비교하고있다 </ ShortDescription>
    <LongDescription> {3.simpleClass} equals ({2.simpleClass})를 호출합니다. {1} </ LongDescription>
    <Details>
      <! [CDATA [
<p>
이 방법은 한편이 클래스에서 다른이 인터페이스 인 2 개의 참조 <code> equals (Object) </ code> 메소드를 호출합니다.
클래스는 그 클래스의 비추 서브 클래스를 포함하여 인터페이스를 구현하지 않습니다.
따라서, 비교되는 두 개체는 런타임에 같은 클래스의 멤버 일 가능성이 낮습니다 (일부 응용 프로그램 클래스를 해석 할 수 없거나 동적 클래스 로딩이 실행시에 발생할 수있는 경우를 제외 ).
<code> equals </ code> 메소드의 규약에 의하면, 다른 클래스의 객체는 항상 같지 않음으로 비교해야합니다.
따라서 <code> java.lang.Object.equals (Object) </ code>에 정의 된 규칙에 따르면,이 비교의 결과는 실행시 항상 false입니다.
</ p>
      ]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="EC_NULL_ARG">
    <ShortDescription> equals (null)의 호출 </ ShortDescription>
    <LongDescription> equals (null)의 호출. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 null 값 인수를 전달 <code> equals (Object) </ code>을 호출합니다.
<code> equals </ code> 메소드의 규약에 의하면,이 호출은 항상 false를 반환해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="MWN_MISMATCHED_WAIT">
    <ShortDescription> 일관성 wait 메소드 </ ShortDescription>
    <LongDescription> 일관성 wait 메소드입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 개체에서 분명히 잠금하지 않고 <code> Object.wait () </ code>을 호출합니다.
유지되는 잠금이없는 상태에서 <code> wait </ code> 메소드를 호출하는 것은 <code> IllegalMonitorStateException </ code>를 던질 수 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="MWN_MISMATCHED_NOTIFY">
    <ShortDescription> 일관성 notify 메소드 </ ShortDescription>
    <LongDescription> 일관성 notify 메소드입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 개체에서 분명히 잠금하지 않고 <code> Object.notify () </ code> 나 <code> Object.notifyAll () </ code>을 호출합니다.
유지되는 잠금이없는 상태에서 <code> notify </ code> 메소드 나 <code> notifyAll </ code> 메소드를 호출하는 것은 <code> IllegalMonitorStateException </ code>를 던질 수 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SA_LOCAL_SELF_ASSIGNMENT_INSTEAD_OF_FIELD">
    <ShortDescription> 필드에 대입이 아닌 로컬 변수에 자기 대입 </ ShortDescription>
    <LongDescription> 필드에 대입이 아닌 {2}의 자기 지정. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 로컬 변수의 자기 대입이 지역 변수와 필드가 같은 이름입니다. <br>
예를 들어 다음과 같은 코드입니다.
</ p>
<blockquote> <pre>
    int foo;
    public void setFoo (int foo) {
        foo = foo;
    }
</ pre> </ blockquote>
<p>
그런 할당은 도움이되지 않습니다. 그렇지 않고 필드에 대입 할 생각 이었습니까?
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SA_LOCAL_SELF_ASSIGNMENT">
    <ShortDescription> 로컬 변수의 자기 대입 </ ShortDescription>
    <LongDescription> {2}의 자기 지정. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 로컬 변수의 자기 대입 있습니다. <br>
예를 들어 다음과 같은 코드입니다.
</ p>
<blockquote> <pre>
public void foo () {
    int x = 3;
    x = x;
}
</ pre> </ blockquote>
<p>
그런 할당은 쓸모가 없으니, 논리적 오류 또는 오타지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SA_FIELD_SELF_ASSIGNMENT">
    <ShortDescription> 필드의 자기 대입 </ ShortDescription>
    <LongDescription> 필드 {2.givenClass} 각자 지정. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 필드의 자기 대입 있습니다. <br>
예를 들어 다음과 같은 코드입니다.
</ p>
<blockquote> <pre>
int x;
public void foo () {
    x = x;
}
</ pre> </ blockquote>
<p>
그런 할당은 쓸모가 없으니, 논리적 오류 또는 오타지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SA_FIELD_DOUBLE_ASSIGNMENT">
    <ShortDescription> 필드의 이중 할당 </ ShortDescription>
    <LongDescription> 필드 {2.givenClass}의 이중 지정. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 필드의 이중 할당합니다. <br>
예를 들어 다음과 같은 코드입니다.
</ p>
<blockquote> <pre>
int x, y;
public void foo () {
    x = x = 17;
}
</ pre> </ blockquote>
<p>
필드에 두 번 할당 할 쓸모가 없으니 논리적 오류 또는 오타지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SA_LOCAL_DOUBLE_ASSIGNMENT">
    <ShortDescription> 로컬 변수의 이중 할당 </ ShortDescription>
    <LongDescription> 로컬 변수 {2}의 이중 지정. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 로컬 변수의 이중 할당합니다. <br>
예를 들어 다음과 같은 코드입니다.
</ p>
<blockquote> <pre>
public void foo () {
    int x, y;
    x = x = 17;
}
</ pre> </ blockquote>
<p>
변수에 같은 값을 두 번 할당 할 쓸모가 없으니 논리적 오류 또는 오타지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SA_FIELD_SELF_COMPUTATION">
    <ShortDescription> 필드의 무의미한 자기 연산 (예를 들어, x & x) </ ShortDescription>
    <LongDescription> {2.givenClass}과 자신과의 무의미한 자기 연산입니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 필드와 같은 필드에 다른 참조와 무의미한 계산을 수행합니다 (예를 들어, x & x 또는 x - x).
이 계산의 본질 때문에, 연산은 이해 생각되지 않기 때문에, 논리적 오류 또는 오타지도 모릅니다.
계산을 확인하십시오.
</ p>
]]>
</ Details>
  </ BugPattern>

  <BugPattern type="SA_LOCAL_SELF_COMPUTATION">
    <ShortDescription> 변수의 무의미한 자기 연산 (예를 들어, x & x) </ ShortDescription>
    <LongDescription> {2}과 자신과의 무의미한 자기 연산입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 로컬 변수와 같은 변수에 다른 참조와 무의미한 계산을 수행합니다 (예를 들어, x & x 또는 x - x).
이 계산의 본질 때문에, 연산은 이해 생각되지 않기 때문에, 논리적 오류 또는 오타지도 모릅니다.
계산을 확인하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SA_FIELD_SELF_COMPARISON">
    <ShortDescription> 필드와 자신과의 자기 비교 </ ShortDescription>
    <LongDescription> {2.givenClass}과 자신과의 자기 비교입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 필드를 자체적으로 비교하고 있습니다.
논리 오류 또는 오타지도 모릅니다. 올바른 비교하고 있는지 확인하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SA_LOCAL_SELF_COMPARISON">
    <ShortDescription> 지역 변수와 자신과의 자기 비교 </ ShortDescription>
    <LongDescription> {2.givenClass}과 자신과의 자기 비교입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 로컬 변수를 자체적으로 비교하고 있습니다.
논리 오류 또는 오타지도 모릅니다. 올바른 비교하고 있는지 확인하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT">
    <ShortDescription> int에 Double.longBitsToDouble ()를 호출하는 </ ShortDescription>
    <LongDescription> int에 Double.longBitsToDouble ()를 호출합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> Double.longBitsToDouble () </ code>의 호출 32 비트 int 값이 인수로 전달됩니다.
이것은 틀림없이 의도 한 것이 아니며, 의도 한 결과를주는 것은 거의 없습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_ARGUMENTS_WRONG_ORDER">
    <ShortDescription> 거꾸로 인수 </ ShortDescription>
    <LongDescription> {2.name}의 호출에 대한 잘못된 순서의 인수. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드 호출에 대한 인수는 순서가 잘못된 것 같습니다.
예를 들어, 호출 <code> Preconditions.checkNotNull ( "message", message) </ code>는 인수를 예약했습니다. 체크되는 값은 첫 번째 인수입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  
  <BugPattern type="DMI_RANDOM_USED_ONLY_ONCE">
    <ShortDescription> Random 개체가 만들어 1 번 밖에 사용되지 않는 </ ShortDescription>
    <LongDescription> Random 개체를 생성 한 번만 사용되지 않습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 <code> java.util.Random </ code> 객체를 생성하고 하나의 난수를 생성하는 데 사용하고 버리고 있습니다.
이것은별로 좋지 않은 품질의 난수를 생성하고 비효율적입니다.
있다면 <code> Random </ code> 객체를 하나 만들어 저장되도록 코드를 다시 작성합니다.
그리고 새로운 난수가 필요할 때마다 기존 <code> Random </ code> 개체의 메서드를 호출합니다.
</ p>
<p>
생성 된 난수를 추측 할 수없는 것이 중요하다면, 난수마다 새로운 <code> Random </ code> 객체를 생성하지 않아야 (값은 너무 쉽게 추측 가능합니다).
대신 <code> java.security.SecureRandom </ code>을 사용하는 것이 좋을 것이다 (그리고 필요한 난수마다 새로운 <code> SecureRandom </ code>의 개체를 만드는 것을 방지 합니다).
</ p>
]]>
    </ Details>
  </ BugPattern>


  <BugPattern type="RV_ABSOLUTE_VALUE_OF_RANDOM_INT">
    <ShortDescription> 부호있는 정수의 난수의 절대 값을 계산하는 잘못된 시도 </ ShortDescription>
    <LongDescription> 부호있는 정수의 난수의 절대 값을 계산하는 잘못된 시도입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 부호있는 정수의 난수를 생성하여 절대 값을 계산합니다.
난수 생성기에서 반환되는 숫자가 <code> Integer.MIN_VALUE </ code>이면 결과는 마찬가지로 음수 (<code> Math.abs (Integer.MIN_VALUE) == Integer.MIN_VALUE </ code>이므로).
(같은 문제는 long 값도 마찬가지로 일어납니다).
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RV_ABSOLUTE_VALUE_OF_HASHCODE">
    <ShortDescription> 부호있는 32 비트 해시 코드의 절대 값을 계산하는 잘못된 시도 </ ShortDescription>
    <LongDescription> 부호있는 32 비트 해시 코드의 절대 값을 계산하는 잘못된 시도입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 해시 코드를 생성하여 절대 값을 계산합니다.
해시 코드 <code> Integer.MIN_VALUE </ code>이면 결과는 마찬가지로 음수 (<code> Math.abs (Integer.MIN_VALUE) == Integer.MIN_VALUE </ code>이므로).
</ p>
<p>
문자열의 2 ^ 32 개에 1 개는 <code> Integer.MIN_VALUE </ code>의 해시 코드를 가지고 있고, "polygenelubricants", "GydZG_", "DESIGNING WORKHOUSES"가 해당합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RV_REM_OF_RANDOM_INT">
    <ShortDescription> 부호있는 32 비트 정수의 난수 나머지 </ ShortDescription>
    <LongDescription> 부호있는 32 비트 정수의 난수 나머지를 계산합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 부호있는 정수의 난수를 생성하여 다른 값을 법으로하는 나머지를 계산합니다.
난수가 부의지도 모르기 때문에, 나머지 연산의 결과도 부정도 모릅니다. 이것이 의도 한 것으로인지 확인합니다.
대신 <code> Random.nextInt (int) </ code>을 사용하는 것이 좋습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RV_REM_OF_HASHCODE">
    <ShortDescription> 해시 코드 나머지는 부의지도 모른다 </ ShortDescription>
    <LongDescription> 해시 코드 나머지는 부의지도 모릅니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 해시 코드를 계산하여 다른 값을 법으로하는 나머지를 계산합니다.
해시 코드가 부의지도 모르기 때문에, 나머지 연산의 결과도 부정도 모릅니다.
</ p>
<p>
계산 결과가 음수가 아닌 것을 확인하고 싶다면, 코드를 변경할 필요가 있을지도 모릅니다.
제수가 2의 제곱 인 것을 알고 있다면, 대신에 비트 연산을 사용할 수 있습니다 (즉, <code> x.hashCode () % n </ code> 대신 <code> x.hashCode () & (n-1) </ code>를 사용하십시오).
아마 나머지를 계산하는 것보다 빠릅니다.
제수가 2의 제곱이라는 것을 알고 있지 않다면, 나머지 연산 결과의 절대 값을 얻습니다 (즉, <code> Math.abs (x.hashCode () % n) </ code>) .
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE">
    <ShortDescription> 부가 아닌 값과 음의 정수와의 잘못된 비교 </ ShortDescription>
    <LongDescription> 부가 아닌 값 {2}에 잘못된 비교입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 부가 아닌 것이 보증되는 값과 음의 정수와 비교하고 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="INT_BAD_COMPARISON_WITH_SIGNED_BYTE">
    <ShortDescription> 부호 바이트의 잘못된 비교 </ ShortDescription>
    <LongDescription> 부호 바이트와 {2}에 잘못된 비교입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
부호있는 바이트 수있는 값의 범위는 -128 ~ 127입니다. 그 범위 밖에서 부호있는 바이트 값과 비교하는 것은 무의미 잘못 높습니다.
부호 바이트 <code> b </ code>를 범위가 0 ~ 255 부호없는 바이트로 변환하려면 <code> 0xff & b </ code>를 사용하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="INT_BAD_COMPARISON_WITH_INT_VALUE">
    <ShortDescription> int 값과 long 상수의 잘못된 비교 </ ShortDescription>
    <LongDescription> int 값 {2}에 잘못된 비교입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 int 값 int 값으로 표현할 수있는 값의 범위를 벗어나는 long 정수를 비교하고 있습니다.
이 비교는 무의미 아마도 잘못된 것입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  
  <BugPattern type="INT_VACUOUS_BIT_OPERATION">
    <ShortDescription> 정수 무의미한 비트 마스크 연산 </ ShortDescription>
    <LongDescription> {3} 무의미한 {2} 연산입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이것은 어떤 유용한 기능도하지 않는 정수 비트 연산 (AND, OR, XOR)입니다 (예 <code> v & 0xffffffff </ code>).
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="INT_VACUOUS_COMPARISON">
    <ShortDescription> 정수 무의미한 비교 </ ShortDescription>
    <LongDescription> 정수 무의미한 비교입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
항상 같은 값을 반환 정수 비교가 있습니다 (예 <code> x <= Integer.MAX_VALUE </ code>).
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="INT_BAD_REM_BY_1">
    <ShortDescription> 1을 법으로하는 정수 나머지 </ ShortDescription>
    <LongDescription> 1을 법으로하는 정수 나머지를 계산합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
어떤 식 <code> (exp % 1) </ code>도 항상 0을 돌려주는 것이 보증되고 있습니다.
그렇지 않고, <code> (exp & 1) </ code> 또는 <code> (exp & 2) </ code>을 의미하고 있었습니까?
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BIT_IOR_OF_SIGNED_BYTE">
    <ShortDescription> 부호 바이트 값의 비트 논리합 </ ShortDescription>
    <LongDescription> 부호 바이트 값의 비트 논리합을 계산합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
로드 한 바이트 값 (예를 들어, 바이트 배열에서로드 된 값과 반환 값이 바이트 형식 메서드에서 반환 된 값)와 비트 논리합을 수행하고 있습니다.
비트 연산을 수행하기 전에 바이트 값은 32 비트까지 부호 확장됩니다.
따라서 <code> b [0] </ code>의 값이 <code> 0xff </ code>에서 <code> x </ code>의 초기 값이 <code> 0 </ code>라고하면,
<code> ((x << 8) | b [0]) </ code>는 <code> 0xff </ code>이 부호 확장 <code> 0xffffffff </ code>이되므로 결과적으로 <code> 0xffffffff </ code>를 얻을 수 있습니다.
</ p>
<p>
특히 바이트 배열 int에 팩하는 다음과 같은 코드는 심하게 잘못되었습니다.
</ p>
<blockquote> <pre>
int result = 0;
for (int i = 0; i <4; i + +) {
    result = ((result << 8) | b [i]);
}
</ pre> </ blockquote>
<p>
대신 다음과 같은 관용구 작동합니다.
</ p>
<blockquote> <pre>
int result = 0;
for (int i = 0; i <4; i + +) {
    result = ((result << 8) | (b [i] & 0xff));
}
</ pre> </ blockquote>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BIT_ADD_OF_SIGNED_BYTE">
    <ShortDescription> 부호 바이트 값의 비트 더하기 </ ShortDescription>
    <LongDescription> 부호 바이트 값의 비트 덧셈을 계산합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
바이트 값과 분명히 하위 8 비트가 있다고 알고있는 값을 가산하고 있습니다.
비트 연산을 수행하기 전에 바이트 배열에서로드 된 값은 32 비트까지 부호 확장됩니다.
따라서 <code> b [0] </ code>의 값이 <code> 0xff </ code>에서 <code> x </ code>의 초기 값이 <code> 0 </ code>라고하면,
<code> ((x << 8) + b [0]) </ code>는 <code> 0xff </ code>이 부호 확장 <code> 0xffffffff </ code>이되므로 결과적으로 <code> 0xffffffff </ code>를 얻을 수 있습니다.
</ p>
<p>
특히 바이트 배열 int에 팩하는 다음과 같은 코드는 심하게 잘못되었습니다.
</ p>
<blockquote> <pre>
int result = 0;
for (int i = 0; i <4; i + +)
  result = ((result << 8) + b [i]);
</ pre> </ blockquote>
<p>
대신 다음과 같은 관용구 작동합니다.
</ p>
<blockquote> <pre>
int result = 0;
for (int i = 0; i <4; i + +)
  result = ((result << 8) + (b [i] & 0xff));
</ pre> </ blockquote>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BIT_AND">
    <ShortDescription> 호환되지 않는 비트 마스크 </ ShortDescription>
    <LongDescription> (e & {2} == {3})의 호환되지 않는 비트 마스크는 일정한 결과를 가져옵니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 <i> (e & C) </ i> 형식의 식을 <i> D </ i>와 비교합니다.
상수 <i> C </ i>과 <i> D </ i>의 특정 값과 항상 동일하지 않은 것을 비교합니다. 논리 오류 또는 오타지도 모릅니다.
</ p>

]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BIT_SIGNED_CHECK">
    <ShortDescription> 비트 연산 부호를 확인 </ ShortDescription>
    <LongDescription> 비트 연산 부호를 확인하십시오. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 <code> ((event.detail & SWT.SELECTED)> 0) </ code>과 같은 식을 비교하고 있습니다.
비트 연산을 더 큰 연산자 비교하는 것은 의외의 결과 (물론 <code> SWT.SELECTED </ code>의 값에 의한)의 원인이 될 수 있습니다.
<code> SWT.SELECTED </ code>가 음수라면, 이것은 버그 후보입니다.
<code> SWT.SELECTED </ code>가 부가 아니더라도 '> 0'대신 '! = 0'을 사용하는 것은 좋은 방법이라고 생각됩니다.
</ p>
<p>
Boris Bokowski
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BIT_SIGNED_CHECK_HIGH_BIT">
    <ShortDescription> 비트 연산 부호를 확인 </ ShortDescription>
    <LongDescription> 비트 연산 부호를 확인하십시오. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 <code> ((event.detail & SWT.SELECTED)> 0) </ code>과 같은 식을 비교하고 있습니다.
비트 연산을 더 큰 연산자 비교하는 것은 의외의 결과 (물론 <code> SWT.SELECTED </ code>의 값에 의한)의 원인이 될 수 있습니다.
<code> SWT.SELECTED </ code>가 음수라면, 이것은 버그 후보입니다.
<code> SWT.SELECTED </ code>가 부가 아니더라도 '> 0'대신 '! = 0'을 사용하는 것은 좋은 방법이라고 생각됩니다.
</ p>
<p>
Boris Bokowski
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BIT_AND_ZZ">
    <ShortDescription> ((...) & 0) == 0인지 확인하고있다 </ ShortDescription>
    <LongDescription> ((...) & 0) == 0인지 확인하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 <i> (e & 0) </ i> 형식의 식을 0과 비교하고 있습니다. 그것은 항상 동일하다는 것을 비교합니다. 논리 오류 또는 오타지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BIT_IOR">
    <ShortDescription> 호환되지 않는 비트 마스크 </ ShortDescription>
    <LongDescription> (e | {2} == {3})의 호환되지 않는 비트 마스크는 일정한 결과를 가져옵니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 <code> (e | C) </ code> 형식의 식을 <code> D </ code>와 비교합니다.
상수 <i> C </ i>과 <i> D </ i>의 특정 값과 항상 동일하지 않은 것을 비교합니다. 논리 오류 또는 오타지도 모릅니다.
</ p>
<p>
일반적으로,이 버그는 비트 세트 귀속 관계를 테스트하려는 코드에서 발생합니다.
하지만 비트 논리 곱 연산자 ( "&") 대신 비트 논리합 연산자 ( "|")를 사용하고 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="LI_LAZY_INIT_INSTANCE" deprecated="true"> <! - never generated? ->
    <ShortDescription> Incorrect lazy initialization of instance field </ ShortDescription>
    <LongDescription> Incorrect lazy initialization of instance field {2} in {1} </ LongDescription>
    <Details>
<! [CDATA [
<p> This method contains an unsynchronized lazy initialization of a non-volatile field.
Because the compiler or processor ​​may reorder instructions,
threads are not guaranteed to see a completely initialized object,
<em> if the method can be called by multiple threads </ em>.
You can make the field volatile to correct the problem.
For more information, see the
<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/"> Java Memory Model web site </ a>.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="LI_LAZY_INIT_STATIC">
    <ShortDescription> static 필드의 잘못된 지연 초기화 </ ShortDescription>
    <LongDescription> static 필드 {2}의 잘못된 지연 초기화. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메소드는 volatile 아닌 static 필드의 비동기 지연 초기화합니다.
컴파일러와 프로세서가 명령어를 정렬지도 모르기 때문에, 방법이 여러 스레드에 의해 호출 될 수 없다면,
스레드는 완전히 초기화 된 개체보기는 보장되지 않습니다.
필드에 액세스 할 때, 도중에 초기화 된 인스턴스가 보여 버리는 위험이 있습니다.
이 문제를 해결하기 위해 필드를 volatile 수 있습니다. <br>
자세한 내용은 <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/"> Java Memory Model web site </ a>를 참조하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="LI_LAZY_INIT_UPDATE_STATIC">
    <ShortDescription> 업데이트되는 static 필드의 잘못된 지연 초기화 </ ShortDescription>
    <LongDescription> 업데이트되는 static 필드 {2}의 잘못된 지연 초기화. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메소드는 static 필드의 비동기 지연 초기화합니다.
필드가 설정된 후 그 위치에 저장되는 개체는 또한 업데이트되거나 액세스됩니다.
그것이 설정되면 즉시 해당 필드의 설정은 다른 스레드에 보입니다.
필드를 설정하는 새로운 접근이 개체를 초기화하는 데 도움이 있다면,
그것이 완전히 초기화 될 때까지 어떤 다른 스레드도 포함 된 개체에 액세스하는 것을 방지하지 않으면 매우 심각한 멀티 스레드 버그가 있습니다.
</ p>
<p>
비록 방법이 여러 스레드에서 호출되지 않는다고 확신도
그것은 필드에 설정 한 값이 완전히 데이터를로드하거나 초기화 될 때까지 static 필드를 설정하지 않는 것이 좋을지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="JLM_JSR166_LOCK_MONITORENTER">
    <ShortDescription> Lock으로 동기화하고있는 </ ShortDescription>
    <LongDescription> {2}에서 동기화하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 java.util.concurrent.locks.Lock를 구현 한 개체에서 동기화하고 있습니다.
그런 개체 <code> synchronized (...) </ code> 구문보다 <code> acquire () </ code> / <code> release () </ code>를 사용하여 잠금 및 잠금 해제합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="JML_JSR166_CALLING_WAIT_RATHER_THAN_AWAIT">
    <ShortDescription> util.concurrent 추상에서 모니터 스타일의 wait 메소드를 사용하는 </ ShortDescription>
    <LongDescription> {3.name} 대신 {2.name}를 호출합니다. {1} </ LongDescription>
<Details>
<! [CDATA [
<p>
이 방법은 <code> await () </ code> 메서드 <code> signal </ code> 메서드 <code> signalAll </ code> 메소드를 제공하는 객체
(예를 들어, util.concurrent의 Condition 객체)에서 <code> wait </ code> 메서드 <code> notify </ code> 메서드 <code> notifyAll </ code> 메소드를 호출합니다.
이것은 아마도 당신이 원하는 것은 아닙니다. 비록 그것을 희망으로도 다른 개발자가 매우 혼동을 이해하고 설계를 변경하는 것을 고려해야합니다.
</ p>
]]>
</ Details>
  </ BugPattern>

  <BugPattern type="JLM_JSR166_UTILCONCURRENT_MONITORENTER">
    <ShortDescription> java.util.concurrent 인스턴스에서 동기화하는 </ ShortDescription>
    <LongDescription> {2}에서 동기화하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 java.util.concurrent 패키지의 클래스 (또는 서브 클래스)의 인스턴스로 동기화합니다.
이 클래스의 인스턴스는 <code> synchronized </ code>의 사용과는 다른 호환되지 않는 그 자신의 병행 제어 메커니즘을 가지고 있습니다.
예를 들어, <code> AtomicBoolean </ code>에 동기화하면 다른 스레드가 <code> AtomicBoolean </ code>을 변경하는 것을 방지합니다.
</ p>
<p>
그런 코드는 맞을지 모르지만 나중에 코드를 유지해야하는 사람들을 혼란스럽게 할 수 있기 때문에 신중하게 검토하고 문서화해야합니다,
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="UPM_UNCALLED_PRIVATE_METHOD">
    <ShortDescription> private 메소드는 결코 호출되지 </ ShortDescription>
    <LongDescription> {1}는 결코 호출되지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 private 메소드는 결코 호출되지 않습니다.
메소드가 리플렉션을 통해 호출 될지도 모르지만, 결코 사용되지 않는 경우 제거해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS">
    <ShortDescription> 호출 불가능한 방법이 무명 클래스에 정의 된 </ ShortDescription>
    <LongDescription> 호출 불가능한 방법 {1}이 무명 클래스에 정의되어 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 무명 클래스는 직접 호출되지 않는 슈퍼 클래스 메서드를 재정의하지 않는 메소드를 정의하고 있습니다.
다른 클래스의 메소드가 익명 클래스에서 선언 된 메소드를 직접 호출 할 수 없기 때문에,이 메소드는 호출 불가능하다고 생각됩니다.
메소드는 단지 죽은 코드일지도 모릅니다. 하지만 메소드가 슈퍼 클래스에 선언 된 메서드를 재정의하는 것을 의도했을 가능성도 있습니다.
그리고 오타 또는 다른 오류에 대한 방법은 실제로 그것이 의도 된 메서드를 재정의하지 않습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="ODR_OPEN_DATABASE_RESOURCE">
    <ShortDescription> 데이터베이스 자원의 청산에 실패 할지도 모른다 방법 </ ShortDescription>
    <LongDescription> {1} {2.excludingPackage}의 청산에 실패 할지도 모릅니다. </ LongDescription>
    <Details>
	<! [CDATA [
<p>
이 방법은 데이터베이스 리소스 (예 : 데이터베이스 연결 및 행 집합)을 만들고 있는데 어떤 필드에도 할당하지 않으며, 다른 방법으로도 전달되지 않으며, 반환 값도하지 않습니다.
그리고 메소드에서 모든 경로에서 개체를 닫기 것처럼 보이지 않습니다.
메소드의 모든 경로에서 데이터베이스 리소스 청산 실패는 좋지 않다 성능이 될지도 모릅니다.
데이터베이스와의 통신에 문제가있는 응용 프로그램의 원인이 될 수 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH">
    <ShortDescription> 예외 경로에서 데이터베이스 자원의 청산에 실패 할지도 모른다 방법 </ ShortDescription>
    <LongDescription> {1} 예외 경로에서 데이터베이스 자원의 청산에 실패 할지도 모릅니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 데이터베이스 리소스 (예 : 데이터베이스 연결 및 행 집합)을 만들고 있는데 어떤 필드에도 할당하지 않으며, 다른 방법으로도 전달되지 않으며, 반환 값도하지 않습니다.
그리고 메서드에서 모든 예외 경로에서 개체를 닫기 것처럼 보이지 않습니다.
메소드의 모든 경로에서 데이터베이스 리소스 청산 실패는 좋지 않다 성능이 될지도 모릅니다.
데이터베이스와의 통신에 문제가있는 응용 프로그램의 원인이 될 수 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SBSC_USE_STRINGBUFFER_CONCATENATION">
    <ShortDescription> 루프에서 +를 사용하여 문자열을 연결하는 방법 </ ShortDescription>
    <LongDescription> {1} 루프에서 +를 사용하여 문자열을 연결합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 루프에서 +를 사용하여 <code> String </ code>를 구축하고 있다고 생각됩니다.
각 반복에서 <code> String </ code>는 <code> StringBuffer </ code> / <code> StringBuilder </ code>로 변환 추가되어 <code> String </ code>로 변환됩니다.
각 반복에서 문자열을 다시 복사 증가하면 반복 수에서 이차 비용이 발생할 수 있습니다.
</ p>
<p>
명시 적으로 <code> StringBuffer </ code> (또는 J2SE 5.0의 <code> StringBuilder </ code>)를 사용하면 더 나은 성능을 얻을 수 있을지도 모릅니다.
</ p>
<p>
예를 들어,
</ p>
<blockquote> <pre>
/ / This is bad
String s = "";
for (int i = 0; i <field.length; + + i) {
    s = s + field [i];
}

/ / This is better
StringBuffer buf = new StringBuffer ();
for (int i = 0; i <field.length; + + i) {
    buf.append (field [i]);
}
String s = buf.toString ();
</ pre> </ blockquote>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="ITA_INEFFICIENT_TO_ARRAY">
    <ShortDescription> 길이가 0 인 배열의 인수 toArray 메소드를 사용하는 방법 </ ShortDescription>
    <LongDescription> {1}는 길이가 0 인 배열의 인수 Collection.toArray ()를 사용하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메소드는 Collection 파생 클래스 </ code> toArray </ code> 메소드를 사용하여 길이가 0 인 배열의 인수를 전달합니다.
<code> myCollection.toArray (new Foo [myCollection.size ()) </ code>를 사용하는 것이 더 효율적입니다.
전달 된 배열이 컬렉션의 모든 요소를​​ 포함 할 수있는 정도의 크기라면, 데이터를로드하여 그대로 반환됩니다.
그 결과로 반환 두 번째 배열 (리플렉션을 통해)를 만들어야을 방지합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD">
    <ShortDescription> run 메소드에서 JUnit 주장 JUnit 의해 통지되지 않는 </ ShortDescription>
    <LongDescription> {1}에서 JUnit 주장 JUnit에서보고되지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> run </ code> 메소드에서 JUnit 주장이 실행되고 있습니다. 실패한 JUnit 주장 예외가 발생합니다.
따라서이 예외가 테스트 메서드를 실행 한 스레드 이외의 스레드에서 발생한다면, 예외는 스레드를 종료하지만, 테스트의 실패가 없습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="IJU_SETUP_NO_SUPER">
    <ShortDescription> TestCase는 super.setup ()를 호출하지 setUp 메소드를 구현하고있는 </ ShortDescription>
    <LongDescription> TestCase {0}는 super.setup ()를 호출하지 setUp 메소드를 정의하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
JUnit의 TestCase 클래스에서 <code> setUp </ code> 메소드를 구현하고 있습니다.
<code> setUp </ code> 메서드는 <code> super.setUp () </ code>을 호출해야하는데 그렇지 않습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="IJU_TEARDOWN_NO_SUPER">
    <ShortDescription> TestCase는 super.tearDown ()를 호출하지 tearDown 메소드를 구현하고있는 </ ShortDescription>
    <LongDescription> TestCase {0}는 super.tearDown ()를 호출하지 tearDown 메소드를 구현하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
JUnit의 TestCase 클래스에서 <code> tearDown </ code> 메소드를 구현하고 있습니다.
<code> tearDown </ code> 메서드는 <code> super.tearDown () </ code>을 호출해야하는데 그렇지 않습니다.
 </ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="IJU_SUITE_NOT_STATIC">
    <ShortDescription> TestCase 비 static 인 suite 메소드를 구현하고있는 </ ShortDescription>
    <LongDescription> TestCase {0}은 비 static 인 suite 메소드를 구현하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
JUnit의 TestCase 클래스에서 <code> suite </ code> 메소드를 구현하고 있습니다.
<code> suite </ code> 메소드는 static으로 선언해야하는데 그렇지 않습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="IJU_BAD_SUITE_METHOD">
    <ShortDescription> TestCase는 suite 메서드의 잘못된 선언을하고있다 </ ShortDescription>
    <LongDescription> TestCase {0}는 suite 메서드의 잘못된 선언을하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
JUnit의 TestCase 클래스에서 <code> suite </ code> 메소드를 구현하고 있습니다.
그러나 <code> suite </ code> 메소드는
</ p>
<pre> public static junit.framework.Test suite () </ pre>
<p> 하나 </ p>
<pre> public static junit.framework.TestSuite suite () </ pre>
<p>
중 하나를 선언해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="IJU_NO_TESTS">
    <ShortDescription> TestCase 테스트가 없다 </ ShortDescription>
    <LongDescription> TestCase {0}은 테스트가 없습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
JUnit의 TestCase 클래스에서 어떤 테스트 방법도 구현하지 않습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>


  <BugPattern type="BOA_BADLY_OVERRIDDEN_ADAPTER">
    <ShortDescription> 슈퍼 클래스의 Adapter에서 구현되는 방법을 잘못 재정의하는 클래스 </ ShortDescription>
    <LongDescription> 클래스 {0}는 슈퍼 클래스의 Adapter에서 구현되는 메소드 {1}을 잘못 재정의하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메소드는 슈퍼 클래스에서 구현되는 메서드를 재정의합니다.
슈퍼 클래스는 java.awt.event 나 javax.swing.event 패키지로 정의 된 수신기를 구현하는 Adapter입니다.
따라서 이벤트가 발생하면이 메소드는 불려 가지 않습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BRSA_BAD_RESULTSET_ACCESS" deprecated="true"> <! - deprecated in favor of SQL_BAD_RESULTSET_ACCESS ->
    <ShortDescription> Method attempts to access a result set field with index 0 </ ShortDescription>
    <LongDescription> {1} attempts to access a result set field with index 0 </ LongDescription>
    <Details>
<! [CDATA [
<p> A call to getXXX or updateXXX methods of a result set was made where the
field index is 0. As ResultSet fields start at index 1, this is always a mistake. </ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SQL_BAD_RESULTSET_ACCESS">
    <ShortDescription> 인덱스가 0에서 ResultSet에 액세스하려고하는 방법 </ ShortDescription>
    <LongDescription> {1}은 인덱스가 0에서 ResultSet에 액세스하려고합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
인덱스가 0에서 <code> ResultSet </ code>의 ge​​tXXX, updateXXX 메소드를 호출합니다.
<code> ResultSet </ code>의 인덱스는 1부터 시작하기 때문에 이것은 항상 실수입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SQL_BAD_PREPARED_STATEMENT_ACCESS">
    <ShortDescription> 인덱스가 0에서 PreparedStatement에 액세스하려고하는 방법 </ ShortDescription>
    <LongDescription> {1}은 인덱스가 0에서 PreparedStatement에 액세스하려고합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
인덱스가 0에서 <code> PreparedStatement </ code>의 setXXX 메소드를 호출합니다.
인덱스는 1부터 시작하기 때문에 이것은 항상 실수입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SIO_SUPERFLUOUS_INSTANCEOF">
    <ShortDescription> instanceof 연산자를 사용하여 불필요한 유형 검사 </ ShortDescription>
    <LongDescription> {1}은 정적으로 확정 될 수 있는데 instanceof 연산자를 사용하여 불필요한 형식 검사를하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
객체가 요구하는 형식인지 여부에 관계없이 정적으로 확정 될 수 있는데 instanceof 연산자를 사용하여 형식 검사를하고 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BAC_BAD_APPLET_CONSTRUCTOR">
    <ShortDescription> 초기화되지 않은 AppletStub에 의존하는 잘못된 애플릿 생성자 </ ShortDescription>
    <LongDescription> 잘못된 애플릿 생성자는 초기화되지 않은 AppletStub에 의존하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 생성자는 AppletStub에 의존하는 부모 애플릿 메소드를 호출합니다.
이 애플릿 <code> init </ code> 메소드가 호출 될 때까지 AppletStub은 초기화되지 않기 때문에 이러한 방법은 제대로 작동하지 않습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="EC_ARRAY_AND_NONARRAY">
    <ShortDescription> equals 메소드를 사용하여 배열과 비 배열을 비교하는 </ ShortDescription>
    <LongDescription> {3.simpleClass} equals ({2.simpleClass})를 호출합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 배열과 배열이라고 생각되지 않는 참조를 비교하기 위해 <code>. equals (Object o) </ code>을 호출합니다.
비교되는 것이 다른 형이라면, 같지 않음이 보장되어 있기 때문에 비교는 거의 확실히 잘못된 것입니다.
비록 그들이 모두 배열이라고해도 배열 <code> equals </ code> 메소드는 두 배열이 동일한 개체로 결정하면됩니다.
배열의 내용을 비교하기 위해서는 <code> java.util.Arrays.equals (Object [], Object []) </ code>를 사용하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="EC_BAD_ARRAY_COMPARE">
    <ShortDescription> 배열의 equals 메소드 호출은 ==와 동일하다 </​​ ShortDescription>
    <LongDescription> {2.simpleClass}을 비교하기 위하여. equals를 사용하고 있지만, ==와 같습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 배열 <code>. equals (Object o) </ code>을 호출합니다.
배열은 <code> Object </ code>의 <code> equals </ code> 메서드를 재정의하지 않기 때문에, 배열 <code> equals </ code> 메소드를 호출 할 주소를 비교하는 것과 같습니다.
배열의 내용을 비교하기 위해서는 <code> java.util.Arrays.equals (Object [], Object []) </ code>를 사용하십시오.
배열의 주소를 비교하기 위해 명시 적으로 <code> == </ code>를 사용하여 참조 동등성을 확인하는 것은 그만큼 요즘 않을까요.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="EC_INCOMPATIBLE_ARRAY_COMPARE">
    <ShortDescription> equals (...) 메소드를 사용하여 호환되지 않는 배열을 비교하는 </ ShortDescription>
    <LongDescription> {2.simpleClass}와 {3.simpleClass}을 비교하기 위해 equals 메소드를 사용하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 호환되지 않는 형식의 배열을 비교하는 <code>. equals (Object o) </ code>를 호출합니다 (예 <code> String [] </ code>와 <code> StringBuffer [] </ code>, <code> String [] </ code>와 <code> int [] </ code>).
그들은 결코 동일하지 않습니다.
또한 <code> equals (...) </ code>가 배열을 비교하는 데 사용되는 때, 그들이 동일한 배열인지 확인 만하면 배열의 내용은 무시합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="STI_INTERRUPTED_ON_CURRENTTHREAD">
    <ShortDescription> interrupted 메서드를 호출하는 데 불필요한 currentThread 메소드를 호출하는 </ ShortDescription>
    <LongDescription> {1}는 interrupted 메서드를 호출하는 데 불필요한 currentThread 메소드를 호출합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 <code> interrupted </ code> 메소드를 호출 <code> Thread.currentThread () </ code>을 호출합니다.
<code> interrupted </ code> 메소드는 static 메소드입니다. <code> Thread.interrupted () </ code>를 사용하는 것이 단순 명료합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="STI_INTERRUPTED_ON_UNKNOWNTHREAD">
    <ShortDescription> 스레드 인스턴스 static Thread.interrupted ()를 호출하는 </ ShortDescription>
    <LongDescription> {1}는 스레드 인스턴스 static Thread.interrupted ()를 호출합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메소드는 현재 스레드가 아닌 Thread 객체 인 것처럼 보인다 Thread 개체 <code> Thread.interrupted () </ code>을 호출합니다.
<code> interrupted </ code> 메소드는 static에서 작성자가 의도 한 것과는 다른 개체에서 호출됩니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN">
    <ShortDescription> 메서드 읽은 않고 덮어 된 매개 변수 </ ShortDescription>
    <LongDescription> {1}에 매개 변수 {2}는 읽은 않고 덮어되어 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 매개 변수의 초기 값은 무시되고 여기서 덮어되어 있습니다.
이것은 많은 경우, 매개 변수에 쓸 호출자에게 리턴된다는 잘못된 생각을 보여줍니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DLS_DEAD_LOCAL_STORE_SHADOWS_FIELD">
    <ShortDescription> 필드를 차단 로컬 변수에 잘못된 할당 </ ShortDescription>
    <LongDescription> 같은 이름의 느낌이 아닌, {2}에 잘못된 지정. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 명령은 로컬 변수에 값을 할당하고 있는데 값은 읽어 않거나 이후의 명령으로도 사용되지 않습니다.
많은 경우 계산 된 값이 결코 사용되지 않기 때문에, 이것은 잘못입니다.
필드가 로컬 변수와 같은 이름입니다. 그렇지 않고 필드에 대입 할 생각 이었습니까?
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DLS_DEAD_LOCAL_STORE">
    <ShortDescription> 로컬 변수에 잘못된 할당 </ ShortDescription>
    <LongDescription> {2}에 잘못된 지정. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 명령은 로컬 변수에 값을 할당하고 있는데 값은 읽어 않거나 이후의 명령으로도 사용되지 않습니다.
많은 경우 계산 된 값이 결코 사용되지 않기 때문에, 이것은 잘못입니다.
</ p>
<p>
Sun의 javac 컴파일러가 final 지역 변수를 위해 종종 잘못된 저장을 생성하는 것에주의하십시오.
FindBugs는 바이트 코드 기반 도구이므로 고장을 없애는 간단한 방법이 없습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DLS_DEAD_LOCAL_STORE_IN_RETURN">
    <ShortDescription> return 문에 쓸모없는 대입이 </ ShortDescription>
    <LongDescription> {1}에서 return 문에 쓸모없는 대입 있습니다. </ LongDescription>
    <Details>
      <! [CDATA [
<p>
이 문은 return 문에서 지역 변수에 할당하고 있습니다. 이 할당은 적용되지 않습니다.
이 글이 정확한지 확인하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DLS_DEAD_STORE_OF_CLASS_LITERAL">
    <ShortDescription> 클래스 리터럴 잘못된 대입 </ ShortDescription>
    <LongDescription> {3} class의 잘못된 지정. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 명령은 변수에 클래스 리터럴을 할당하고 있는데 절대로 사용하지 않습니다. <br>
<a href="//java.sun.com/j2se/1.5.0/compatibility.html#literal"> The behavior of this differs in Java 1.4 and in Java 5 </ a> <br>
J2SE 1.4 및 그 이전 버전에서는 <code> Foo.class </ code>에 대한 참조는 <code> Foo </ code>에 대한 정적 이니셜 라이저가 이미 실행되고 있지 않으면 실행하도록 강요 합니다.
J2SE 5.0에서는 그렇지 않습니다.
</ p>
<p>
더 자세한 내용과 예제와 J2SE 5.0의 클래스 강제 초기화 방법 제안은 Sun의 <a href="//java.sun.com/j2se/1.5.0/compatibility.html#literal"> article on Java SE compatibility </ a>를 참조하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DLS_DEAD_LOCAL_STORE_OF_NULL">
    <ShortDescription> 로컬 변수에 잘못된 null 대입 </ ShortDescription>
    <LongDescription> {2}에 잘못된 null 지정. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 로컬 변수에 null을 할당하는 데 할당 된 값은 읽어하지 않습니다.
이 할당은 가비지 컬렉터를 돕기 위해 도입 된지도 모릅니다 만, Java SE 6에서는 더 이상 필요하지 않거나 유용하지 않습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="MF_METHOD_MASKS_FIELD">
    <ShortDescription> 필드 숨기기 변수를 정의하는 방법 </ ShortDescription>
    <LongDescription> {1} 필드 {2.givenClass} 숨기기 변수를 정의하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는이 클래스 또는 수퍼 클래스의 필드와 동일한 이름으로 로컬 변수를 정의하고 있습니다.
이것은 필드에서 초기화되지 않은 값을 읽거나, 초기화되지 않은 필드를 그대로 두는 메소드의 원인이 될지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="MF_CLASS_MASKS_FIELD">
    <ShortDescription> 슈퍼 클래스의 필드 숨기기 필드를 정의하고있는 클래스 </ ShortDescription>
    <LongDescription> 필드 {1.givenClass}는 슈퍼 클래스 {2.class} 필드를 숨기고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 슈퍼 클래스의 가시​​ 인스턴스 필드와 같은 이름으로 필드를 정의하고 있습니다.
이것은 혼동하여 메소드가 필드를 업데이트하거나 액세스한다면 실수를 지적 할지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="WMI_WRONG_MAP_ITERATOR">
    <ShortDescription> entrySet 반복자가 아니라 비효율적 keySet 반복자를 사용하는 </ ShortDescription>
    <LongDescription> {1}은 entrySet 반복자가 아니라 비효율적 keySet 반복자를 사용하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 keySet 반복자로부터 추출 된 키를 사용하여 맵 항목의 값에 액세스합니다.
Map의 entrySet 반복자를 사용하는 것이 <code> Map.get (key) </ code> 조회를 방지하기 때문에보다 효율적입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="ISC_INSTANTIATE_STATIC_CLASS">
    <ShortDescription> static 메소드만을 제공하는 클래스의 불필요한 인스턴스화 </ ShortDescription>
    <LongDescription> {1}는 static 메소드만을 제공하는 클래스를 불필요하게 인스턴스화합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 static 메소드만을 제공하는 클래스의 객체를 생성합니다.
이 개체는 만들 필요가 없습니다. 한정자로 직접 클래스 이름을 사용하는 static 메서드에 액세스하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="REC_CATCH_EXCEPTION">
    <ShortDescription> 예외가 발생하는데 예외를 포착하고있는 </ ShortDescription>
    <LongDescription> 예외가 발생하는데 예외를 캐치합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메소드는 예외 객체를 포착하는 try-catch 블록을 사용하고 있는데 예외는 try 블록 내에서 발생하지 않습니다. 또한 런타임 예외는 명시 적으로 캐치되지 않습니다.
각각의 catch 블록이 동일 많은 예외 형을 잡을 약어로 <code> try {...} catch (Exception e) {something} </ code>를 사용하는 것이 일반적인 버그 패턴 입니다.
그러나이 구문은 잘못 실행시 예외도 마찬가지로 잡기 때문에, 잠재적 인 버그를 숨 깁니다.
</ p>
<p>
더 나은 방법은 명시 적으로 캐치하는 것보다 발생하는 특정 예외가 발생합니다.
또는 다음과 같이 명시 적으로 RuntimeException을 잡아 다시 발생하여 비 실행시 예외를 캐치합니다.
</ p>
<blockquote> <pre>
try {
    ...
} catch (RuntimeException e) {
    throw e;
} catch (Exception e) {
    - deal with all non-runtime exceptions ...
}
</ pre> </ blockquote>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER">
    <ShortDescription> NaN에 등가성을위한 절망적 인 테스트 </ ShortDescription>
    <LongDescription> NaN에 등가성을위한 절망적 인 테스트입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 부동 소수점이 특별한 비 수치와 같은지 확인합니다 (예 <code> if (x == Double.NaN) </ code>).
그러나 <code> NaN </ code>의 특별한 의미 때문에 값은 <code> NaN </ code>와 동일하지 않습니다.
따라서 <code> x == Double.NaN </ code>은 항상 false로 평가합니다.
<code> x </ code> 값이 특별한 숫자가 아닌 지 확인하기 위하여는 <code> Double.isNaN (x) </ code>를 사용합니다 (또는 <code> x </ code > 부동 소수점 정밀도이라면 <code> Float.isNaN (x) </ code>).
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="FE_FLOATING_POINT_EQUALITY">
    <ShortDescription> 부동 소수점의 등가성을위한 테스트 </ ShortDescription>
    <LongDescription> 부동 소수점의 등가성을위한 테스트입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 연산은 등가성을 위해 두 개의 부동 소수점 값을 비교하고 있습니다.
부동 소수점 계산은 반올림을 동반 할지도 모르기 때문에, 계산 된 float와 double의 값은 정확하지 않을지도 모릅니다.
통화와 같은 정확해야한다 값을 위해, <code> BigDecimal </ code>와 같은 고정 정밀도 형을 사용하는 것을 고려하십시오.
정확한 필요가없는 값을 위해, 어떤 범위에서 동등성을 위해 비교하는 것을 고려하십시오.
예를 들어, <code> if (Math.abs (x - y) <.0000001) </ code>. <br>
자세한 내용은 Java 언어 사양 4.2.4을 참조하십시오.
</ p>
]]>
    </ Details>
</ BugPattern>

  <BugPattern type="UM_UNNECESSARY_MATH">
    <ShortDescription> 상수 값에서 Math 클래스의 static 메소드를 호출하는 방법 </ ShortDescription>
    <LongDescription> 메서드는 상수 값으로 Math 클래스의 static 메소드를 호출합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 상수 값으로 java.lang.Math의 static 메소드를 호출합니다.
이 메소드의 결과는 정적으로 확정 된 수보다 빠르고, 때로는 상수를 사용하는 것이 더 정확합니다. <br>
감지되는 방법은 다음과 같습니다.
</ p>
<table>
<tr>
   <th> 방법 </ th> <th> 매개 변수 </ th>
</ tr>
<tr>
   <td> abs </ td> <td>-any-</ td>
</ tr>
<tr>
   <td> acos </ td> <td> 0.0 or 1.0 </ td>
</ tr>
<tr>
   <td> asin </ td> <td> 0.0 or 1.0 </ td>
</ tr>
<tr>
   <td> atan </ td> <td> 0.0 or 1.0 </ td>
</ tr>
<tr>
   <td> atan2 </ td> <td> 0.0 </ td>
</ tr>
<tr>
   <td> cbrt </ td> <td> 0.0 or 1.0 </ td>
</ tr>
<tr>
   <td> ceil </ td> <td>-any-</ td>
</ tr>
<tr>
   <td> cos </ td> <td> 0.0 </ td>
</ tr>
<tr>
   <td> cosh </ td> <td> 0.0 </ td>
</ tr>
<tr>
   <td> exp </ td> <td> 0.0 or 1.0 </ td>
</ tr>
<tr>
   <td> expm1 </ td> <td> 0.0 </ td>
</ tr>
<tr>
   <td> floor </ td> <td>-any-</ td>
</ tr>
<tr>
   <td> log </ td> <td> 0.0 or 1.0 </ td>
</ tr>
<tr>
   <td> log10 </ td> <td> 0.0 or 1.0 </ td>
</ tr>
<tr>
   <td> rint </ td> <td>-any-</ td>
</ tr>
<tr>
   <td> round </ td> <td>-any-</ td>
</ tr>
<tr>
   <td> sin </ td> <td> 0.0 </ td>
</ tr>
<tr>
   <td> sinh </ td> <td> 0.0 </ td>
</ tr>
<tr>
   <td> sqrt </ td> <td> 0.0 or 1.0 </ td>
</ tr>
<tr>
   <td> tan </ td> <td> 0.0 </ td>
</ tr>
<tr>
   <td> tanh </ td> <td> 0.0 </ td>
</ tr>
<tr>
   <td> toDegrees </ td> <td> 0.0 or 1.0 </ td>
</ tr>
<tr>
   <td> toRadians </ td> <td> 0.0 </ td>
</ tr>
</ table>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="CD_CIRCULAR_DEPENDENCY">
    <ShortDescription> 클래스 간의 순환 종속성 테스트 </ ShortDescription>
    <LongDescription> 클래스 {0}은 다른 클래스와 순환 종속성이 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 다른 클래스와 순환 종속성이 있습니다.
각각 다른 종류의 정확한 구축에 의존하고, 클래스의 구축을 어렵게하고 있습니다.
어려운 종속성을 끊기 위해, 인터페이스의 사용을 고려하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RI_REDUNDANT_INTERFACES">
    <ShortDescription> 슈퍼 클래스와 동일한 인터페이스를 구현하는 클래스 </ ShortDescription>
    <LongDescription> 클래스 {0}은 슈퍼 클래스와 동일한 인터페이스를 구현하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 슈퍼 클래스에 따라 구현되는 인터페이스를 구현 함을 선언합니다.
슈퍼 클래스가 인터페이스를 구현하므로, 이것은 중복입니다. 기본적으로 모든 하위 클래스도이 인터페이스를 구현합니다.
이 클래스가 생성 된 후 상속 계층이 바뀐 것을 지적 할지도 모릅니다. 인터페이스 구현의 소유권을 고려해야합니다.
</ p>
    ]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="MTIA_SUSPECT_STRUTS_INSTANCE_FIELD">
    <ShortDescription> Struts Action을 확장 한 클래스의 인스턴스 변수의 사용 </ ShortDescription>
    <LongDescription> Struts Action 클래스를 확장 한 클래스 {0}에서 인스턴스 변수를 사용하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
Struts Action 클래스를 확장 한 클래스에서 인스턴스 변수를 사용하고 있습니다.
Struts Action 클래스의 하나의 인스턴스 만 Struts 프레임 워크에서 만든 다중 스레드에 의해 사용되므로,이 패러다임은 매우 문제가 권장되지 않습니다.
지역 변수를 사용하는 것만을 고려하십시오.
모니터를 제외하고 기록 된 인스턴스 필드 만보고됩니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="MTIA_SUSPECT_SERVLET_INSTANCE_FIELD">
    <ShortDescription> Servlet 클래스를 확장 한 클래스의 인스턴스 변수의 사용 </ ShortDescription>
    <LongDescription> Servlet 클래스를 확장 한 클래스 {0}에서 인스턴스 변수를 사용하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
Servlet 클래스를 확장 한 클래스에서 인스턴스 변수를 사용하고 있습니다.
Servlet 클래스의 하나의 인스턴스 만 Java EE 프레임 워크에서 만든 다중 스레드에 의해 사용되므로,이 패러다임은 매우 문제가 권장되지 않습니다.
지역 변수를 사용하는 것만을 고려하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="PS_PUBLIC_SEMAPHORES">
    <ShortDescription> 공개 인터페이스에서 동기화와 세마포어를 노출하는 클래스 </ ShortDescription>
    <LongDescription> 클래스 {0}는 공개 인터페이스에서 동기화와 세마포어를 노출하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 그 자체 (this 참조)에서 <code> wait </ code> 메서드 <code> notify </ code> 메서드 <code> notifyAll </ code> 메소드와 함께 동기화합니다.
이 클래스를 사용하는 클라이언트 클래스는 동기화를위한 객체로이 클래스의 인스턴스를 더 사용할지도 모릅니다.
2 개의 클래스가 동기화를 위해 동일한 개체를 사용하기 때문에 멀티 스레드의 정확성은 의심입니다.
동기화해야없고, 공개 참조 세마포어 메서드 호출해서는 없습니다.
동기화 제어는 내부의 공개되지 않은 멤버 변수를 사용하는 것이 좋습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="ICAST_INTEGER_MULTIPLY_CAST_TO_LONG">
    <ShortDescription> 정수 곱셈의 결과를 long으로 캐스팅하는 </ ShortDescription>
    <LongDescription> 정수 곱셈의 결과를 long으로 변환합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 다음과 같이 정수의 곱셈을 수행하고 결과를 long로 변환합니다.
</ p>
<blockquote> <pre>
long convertDaysToMilliseconds (int days) {return 1000 * 3600 * 24 * days;}
</ pre> </ blockquote>
<p>
long을 사용하여 곱셈을하면 결과가 오버플로 가능성을 방지 할 수 있습니다. <br>
예를 들어, 다음과 같이 수정합니다.
</ p>
<blockquote> <pre>
long convertDaysToMilliseconds (int days) {return 1000L * 3600 * 24 * days;}
</ pre> </ blockquote>
<p>
또는
</ p>
<blockquote> <pre>
static final long MILLISECONDS_PER_DAY = 24L * 3600 * 1000;
long convertDaysToMilliseconds (int days) {return days * MILLISECONDS_PER_DAY;}
</ pre> </ blockquote>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="ICAST_INT_2_LONG_AS_INSTANT">
    <ShortDescription> int 값을 long으로 변환하여 절대 시간으로 사용하는 </ ShortDescription>
    <LongDescription> int 값을 long로 변환 해, {2}에 절대 시간으로 전달합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 32 비트 int 값을 64 비트 long 값으로 변환하여 절대 시간 값을 필요로하는 메서드 매개 변수에 전달합니다.
절대 시간 값은 "신기원"(즉, 1970 년 1 월 1 일 00:00:00 GMT)로 알고있는 표준 기준 시간에서 밀리 초입니다. <br>
예를 들어 다음의 메소드 (Date에 신기원으로부터 초를 변환하는 것을 의도 한)는 심하게 손상되었습니다.
</ p>
<blockquote> <pre>
Date getDate (int seconds) {return new Date (seconds * 1000);}
</ pre> </ blockquote>
<p>
곱셈은​​ 32 비트 연산을 사용하여 64 비트 값으로 변환됩니다.
32 비트 값은 64 비트로 변환되고, 절대 시간 값을 나타내는 데 사용되는 경우, 1969 년 12 월과 1970 년 1 월의 날짜 밖에 나타낼 수 없습니다.
</ p>
<p>
위의 방법에 대한 올바른 구현은 다음과 같습니다.
</ p>
<blockquote> <pre>
/ / 실패, 2037 년 이후의 날짜
Date getDate (int seconds) {return new Date (seconds * 1000L);}

/ / 더 나은, 모든 날짜에서 작동
Date getDate (long seconds) {return new Date (seconds * 1000);}
</ pre> </ blockquote>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND">
    <ShortDescription> 정수 값을 float로 캐스팅하여 Math.round ()에 전달하는 </ ShortDescription>
    <LongDescription> 정수 값을 float로 캐스팅하여 Math.round ()에 전달합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 정수 값을 float 정밀도 부동 소수점으로 변환하고 그 결과를 <code> Math.round () </ code>에 전달 인수에 가장 가까운 int / long를 돌려줍니다.
정수를 float로 변환하면 소수 부분이없는 숫자를 얻을 수 있으므로,이 연산은 항상 무 연산됩니다.
<code> Math.round () </ code>에 전달 된 값을 생성하는 연산이 부동 소수점 연산을 사용하여 실행하는 것을 의도 한 가능성이 높습니다.
</ p>

]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL">
    <ShortDescription> 정수 값을 double로 캐스팅하여 Math.ceil ()에 전달하는 </ ShortDescription>
    <LongDescription> 정수 값을 double로 캐스팅하여 Math.ceil ()에 전달합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 정수 (예 : int 또는 long)를 배정 밀도 부동 소수점으로 변환하고 그 결과를 <code> Math.ceil () </ code>에 전달합니다.
정수를 double로 변환하면 소수 부분이없는 숫자를 얻을 수 있으므로,이 연산은 항상 무 연산됩니다.
<code> Math.ceil () </ code>에 전달 된 값을 생성하는 연산이 배정도 부동 소수점 연산을 사용하여 실행하는 것을 의도 한 가능성이 높습니다.
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="ICAST_IDIV_CAST_TO_DOUBLE">
    <ShortDescription> 정수 나누기 결과를 double 또는 float로 캐스팅하는 </ ShortDescription>
    <LongDescription> 정수 나누기 결과를 double 또는 float로 캐스팅합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 정수 나누기 결과를 double 또는 float로 캐스팅합니다.
정수 나누기를하는 것은 0에 가장 가까운 정수까지 결과를 자릅니다.
결과가 double에 캐스팅 된 사실이 정도가 유지되어야 이었다는 것을 시사하고 있습니다.
아마 의미 된 것은 나누기를 수행하기 전에 피연산자 중 하나 또는 모두를 double로 캐스팅하는 것이 었습니다. <br>
예를 나타냅니다.
</ p>
<blockquote> <pre>
int x = 2;
int y = 5;
/ / Wrong : yields result 0.0
double value1 = x / y;

/ / Right : yields result 0.4
double value2 = x / (double) y;
</ pre> </ blockquote>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION">
    <ShortDescription> HttpSession에 비 직렬화 가능 오브젝트의 저장 </ ShortDescription>
    <LongDescription> 비 직렬화 가능 오브젝트 {2}를 HttpSession에 저장합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 HttpSession에 직렬화 가능 오브젝트를 포함하고 있다고 생각합니다.
이 세션이 불 활성화되거나 이행했다면 오류를 초래합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_NONSERIALIZABLE_OBJECT_WRITTEN">
    <ShortDescription> ObjectOutput에 기입 해지는 비 직렬화 가능 오브젝트 </ ShortDescription>
    <LongDescription> 비 직렬화 가능 오브젝트 {2}이 ObjectOutput에 기록되어 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 <code> ObjectOutput.writeObject </ code>에 비 직렬화 가능 개체를 전달하고 있다고 생각됩니다.
이 개체가 정말 비 직렬화 가능하면 오류를 초래합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT">
    <ShortDescription> 서식 문자열 위해 이전 인자가없는 </ ShortDescription>
    <LongDescription> 형식 문자열 인수 {2} 이전 인자가 없습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 서식 문자열은 이전의 서식 지시자의 인수가 재사용되도록하기 위해 "상대 인덱스 ("< ")"를 지정하고 있습니다.
그러나 이전 인수가 없습니다.
예를 들어, <code> formatter.format ( "% <s % s", "a", "b") </ code>가 실행되면 MissingFormatArgumentException가 발생합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="VA_FORMAT_STRING_USES_NEWLINE">
    <ShortDescription> 서식 문자열은 \ n보다 % n을 사용한다 </ ShortDescription>
    <LongDescription> 서식 문자열은 \ n보다 % n을 사용해야합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 서식 문자열에 개행 문자 (\ n)가 포함되어 있습니다.
일반적으로 형식 문자열에 % n을 사용하는 것이 더 바람직합니다. % n은 플랫폼 특유의 행 구분을 만들어냅니다.
</ p>
]]>
  </ Details>
  </ BugPattern>

  <BugPattern type="VA_FORMAT_STRING_BAD_CONVERSION">
    <ShortDescription> 주어진 인수의 형태는 서식 지시자에 일치하지 않습니다 </ ShortDescription>
    <LongDescription> 인수 형식 {3}은 서식 지시자 {4}에서 다룰 수 없습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
인수 중 하나는 해당 서식 지시자와 호환되지 않습니다. 그 결과, 실행될 때 런타임 예외를 생성합니다.
예를 들어, <code> String.format ( "% d", "1") </ code>는 문자열 "1"이 서식 지시자 "% d"와 호환이 없으므로 예외를 생성합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN">
    <ShortDescription> Boolean 형이 아닌 인수를 % b 서식 지시자를 사용하여 포맷하고 </ ShortDescription>
    <LongDescription> Boolean 형이 아닌 인수를 % b 서식 지시자를 사용하여 포맷합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
Boolean 형이 아닌 인수를 % b 서식 지시자 포맷합니다. 이것은 예외를 throw하지 않습니다.
대신 비 null 값이 true, null는 false를 출력합니다.
서식 문자열이 기능은 이상한 의도 한 것은 아니다지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="VA_FORMAT_STRING_BAD_CONVERSION_FROM_ARRAY">
    <ShortDescription> 형식 문자열을 사용하여 쓸모없는 방법으로 배열을 포맷하고 </ ShortDescription>
    <LongDescription> 쓸모없는 방법으로 인수 형 {3}을 포맷합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
서식 문자열로 포맷 된 인수 중 하나는 배열입니다.
이것은 [I @ 304282 같은 꽤 쓸모없는 형식을 사용하여 포맷됩니다. 그것은 배열의 내용을 표시하지 않습니다.
포맷 처리 전에 <code> Arrays.asList (...) </ code>를 사용하여 배열을 랩하는 것을 고려해보십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="VA_FORMAT_STRING_ARG_MISMATCH">
    <ShortDescription> 서식 문자열에 인수의 수와 서식 지시자의 수가 일치하지 않는 </ ShortDescription>
    <LongDescription> 서식 문자열 "{3}"에 의해 호출되는 형식 문자열 메소드 {2}는 서식 지시자 수가 {4}인데 인수의 수는 {5}입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
가변 인수의 서식 문자열 메소드가 호출되어 있지만 전달 된 인수의 수와 형식 문자열의 % 서식 지시자의 수가 일치하지 않습니다.
이것은 아마 작성자가 의도 한 것은 아닙니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="VA_FORMAT_STRING_EXPECTED_MESSAGE_FORMAT_SUPPLIED">
    <ShortDescription> printf 스타일의 형식이 예상되는 곳에서 MessageFormat이 주어진 </ ShortDescription>
    <LongDescription> {2}는 prntf 스타일의 서식을 필요로하고 있지만 MessageFormat 의해 호출됩니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
Java의 printf 서식 캐릭터 라인과 인수 목록을 기대하는 메소드가 호출됩니다.
그러나 서식 문자열에는 어떤 서식 지시자 (예를 들어, % s)도없고, 메시지 형식의 요소 (예 : {0})가 있습니다.
printf 스타일 형식 문자열이 필요할 때, MessageFormat의 문자열을주고있을 가능성이 높습니다.
런타임에 모든 인수는 무시되고 형식 문자열은 정확하게 포맷되지 않고 반환됩니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED">
    <ShortDescription> 서식 문자열에서 실제로 사용되는보다 많은 인수가 전달되는 </ ShortDescription>
    <LongDescription> 형식 문자열 {3}에 의해 호출되는 형식 문자열 메소드 {2}는 서식 지시자 수가 {4}인데 인수의 수는 {5}입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
가변 인수의 서식 문자열 메소드가 호출되어 있지만 형식 문자열에서 실제로 사용되는보다 많은 인수가 전달됩니다.
이것은 실행시 예외의 원인이되지 않지만 코드는 포맷 된 문자열에 포함되는 것을 의도 한 정보를 자동으로 생략하고 있을지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="VA_FORMAT_STRING_ILLEGAL">
    <ShortDescription> 잘못된 형식 문자열 </ ShortDescription>
    <LongDescription> 잘못된 형식 문자열 "{3}"입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
서식 문자열은 구문 적으로 무효입니다. 이 문이 실행되면 실행시 예외가 발생합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="VA_FORMAT_STRING_MISSING_ARGUMENT">
    <ShortDescription> 서식 문자열은 부족한 인수를 참조하는 </ ShortDescription>
    <LongDescription> 형식 문자열 "{3}"인수가 {5} 필요한데 {6} 밖에 주어지지 않습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
서식 문자열에 서식 지시자를 충족 충분한 인수가 전달되지 않습니다. 이 문이 실행되면 실행시 예외가 발생합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="VA_FORMAT_STRING_BAD_ARGUMENT">
    <ShortDescription> 서식 지시자에 전달하는 인수에 호환되지 않는 </ ShortDescription>
    <LongDescription> 서식 지시자 {4}는 해당 인수와 호환성이 없습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
서식 지시자는 해당 인수와 호환성이 없습니다.
예를 들어, <code> System.out.println ( "% d \ n", "hello"); </ code>의 % d 서식 지시자는 숫자 인수를 필요로하지만 숫자 대신 문자열이 전달 있습니다.
이 문이 실행되면 실행시 예외가 발생합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG">
    <ShortDescription> 가변 인자를 기대하고있는 메소드에 원시적 형태의 배열을 전달하는 </ ShortDescription>
    <LongDescription> 가변 인자의 메소드 {3}에 {2}을 전달합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 가변 인수를 취하는 메소드에 원시적 형태의 배열을 전달합니다.
이것은 원시 형의 배열을 유지하기 위해 길이가 1 배열을 만들어 메서드에 전달합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS">
    <ShortDescription> equals 메소드는 인수의 형태를 가정 안된다 </ ShortDescription>
    <LongDescription> {0}에 대한 equals 메소드는, 인수의 형태가 {0.givenClass}이라고 가정합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> equals (Object o) </ code> 메서드는 <code> o </ code> 형식에 대해 어떤 가정도해서는 없습니다.
<code> o </ code>가 <code> this </ code>와 같은 형태가 아니라면 단순히 false를 반환해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BC_BAD_CAST_TO_ABSTRACT_COLLECTION">
    <ShortDescription> 추상 컬렉션에 의심 캐스트 </ ShortDescription>
    <LongDescription> Col​​lection에서 추상 클래스 {3}에 의심 캐스트입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 Collection을 추상 컬렉션에 캐스팅하고 있습니다 (예 <code> List </ code>, <code> Set </ code>, <code> Map </ code>).
객체가 캐스팅 형이라고 보장되는지 확인하십시오.
필요로하는 컬렉션의 반복 수 있다면 Set 또는 List에 캐스팅 할 필요가 없습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY">
    <ShortDescription> 원시 형의 배열을 포함한다 불가능한 캐스트 </ ShortDescription>
    <LongDescription> 원시 형의 배열을 포함한다 불가능한 캐스트입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 캐스트는 항상 ClassCastException를 throw합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
<BugPattern type="BC_IMPOSSIBLE_CAST">
    <ShortDescription> 불가능한 캐스트 </ ShortDescription>
    <LongDescription> {2}에서 {3}에없는 캐스팅입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 캐스트는 항상 ClassCastException를 throw합니다.
FindBugs는 instanceof 체크에서 형식 정보를 조사하여 메소드의 반환 값과 필드에서로드 된 형식에 대해 더 정확한 정보를 사용합니다.
따라서 선언 된 변수의 형식은 더 정확한 정보가 있을지도 모른다 모릅니다.
그리고 배우가 항상 런타임 예외를 던질 지 결정하는 데 사용할 수 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BC_IMPOSSIBLE_DOWNCAST">
    <ShortDescription> 불가능한 다운 캐스트 </ ShortDescription>
    <LongDescription> {2}에서 {3}에없는 다운 캐스팅입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 캐스트는 항상 ClassCastException를 throw합니다.
분석은 캐스팅 된 값의 정확한 형식을 알고 있다고 생각합니다.
그리고 하위 유형으로 다운 캐스팅하려는 시도는 ClassCastException의 슬로우에 의해 항상 실패합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY">
    <ShortDescription> toArray 메소드의 결과 불가능한 다운 캐스트 </ ShortDescription>
    <LongDescription> {3}에 toArray 메소드의 결과 불가능한 다운 캐스팅입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 다음과 같이 <code> Object [] </ code>보다 특정 형식의 컬렉션에서 <code> toArray </ code> 메서드 호출 결과를 캐스팅하고 있습니다.
</ p>
<blockquote> <pre>
String [] getAsArray (Collection <String> c) {
  return (String []) c.toArray ();
}
</ pre> </ blockquote>
<p>
이것은 일반적으로 ClassCastException를 슬로우 해 실패합니다.
거의 모든 컬렉션의 <code> toArray </ code> 메서드는 <code> Object [] </ code>를 반환합니다.
Collection 객체는 선언 된 범용 형 컬렉션 참조가 없기 때문에, 정말로 아무것도 할 수 없습니다.
컬렉션에서 특정 유형의 배열을 얻는 올바른 방법은 <code> c.toArray (new String []); </ code> 또는 <code> c.toArray (new String [c.size ()); < / code> (후자는 경미하게 더 효율적입니다)을 사용하는 것입니다.
이에 대한 하나의 일반적인 알려진 예외가 있습니다.
<code> Arrays.asList (...) </ code>에 의해 반환되는 목록 <code> toArray () </ code> 메서드는 공변 배열을 돌려줍니다.
예를 들어, <code> Arrays.asArray (new String [] { "a"}) toArray () </ code>는 <code> String [] </ code>를 반환합니다.
FindBugs는 이러한 경우를 발견하고 억제하려고하지만 일부 바라 볼지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="NP_NULL_INSTANCEOF">
    <ShortDescription> null로 알고있는 값을 해당 형식의 인스턴스인지 확인하고있다 </ ShortDescription>
    <LongDescription> null로 알고있는 값을 {2}의 인스턴스인지 확인합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
체크 된 값이 null임을 보장되어 있으므로, instanceof는 항상 faluse을 반환합니다.
이것은 안전하고, 오해와 논리적 오류를 지적하지 않는 것을 확인하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BC_NULL_INSTANCEOF" deprecated="true"> <! - deprecated in favor of NP_NULL_INSTANCEOF ->
    <ShortDescription> A known null value is checked to see if it is an instance of a type </ ShortDescription>
    <LongDescription> A known null value is checked to see if it is an instance of {2} in {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
This instanceof test will always return false, since the value being checked is guaranteed to be null.
Although this is safe, make sure it isn't
an indication of some misunderstanding or some other logic error.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BC_IMPOSSIBLE_INSTANCEOF">
    <ShortDescription> 항상 false를 반환 instanceof </ ShortDescription>
    <LongDescription> {2}가 {3} 일 가능성이 없기 때문에, instanceof는 항상 false를 돌려줍니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 instanceof는 항상 false를 돌려줍니다. 이것은 안전하고, 오해와 논리적 오류를 지적하지 않는 것을 확인하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BC_VACUOUS_INSTANCEOF">
    <ShortDescription> 항상 true를 반환 instanceof </ ShortDescription>
    <LongDescription> {2}는 {3}의 인스턴스이므로 instanceof는 항상 모든 비 null 값에 true를 돌려줍니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 instanceof는 항상 true를 반환합니다 (테스트 값이 null가 아닌 경우).
이것은 안전하고, 오해와 논리적 오류를 지적하지 않는 것을 확인하십시오.
정말 null 그런지 값을 테스트하고 싶다면, 아마 instanceof 대신 null 테스트를하는 것이 좋고,보다 명확 해집니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BC_UNCONFIRMED_CAST">
    <ShortDescription> 검사되지 않은 / 확인되지 않은 캐스트 </ ShortDescription>
    <LongDescription> {2}에서 {3}에 체크되지 않은 / 확인되지 않은 캐스트입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 캐스트는 확인되지 않습니다.
모든 유형의 인스턴스가 캐스팅 형식으로 캐스팅 할 수있는 것은 없습니다.
프로그램의 로직이 캐스팅에 실패하지 않는다는 것을 확실하게 확인하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

   <BugPattern type="BC_UNCONFIRMED_CAST_OF_RETURN_VALUE">
    <ShortDescription> 메서드에서 반환되지 않은 확인 / 미확인 캐스트 </ ShortDescription>
    <LongDescription> {2}에서 {3} 반환 값에 체크되지 않은 / 확인되지 않은 캐스트입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 메소드의 반환 미확인 캐스트를 수행하고 있습니다.
코드는 캐스팅이 안전하다는 것을 보장하도록 메소드를 호출하고 있을지도 모릅니다 만, FindBugs 캐스트가 안전하다는 것을 확인할 수 없습니다.
프로그램의 로직이 캐스팅에 실패하지 않는다는 것을 확실하게 확인하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="BC_BAD_CAST_TO_CONCRETE_COLLECTION">
    <ShortDescription> 구상 컬렉션에 의심 캐스트 </ ShortDescription>
    <LongDescription> {2}에서 {3}에 의심 캐스트입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 추상 컬렉션 (예를 들어, Collection, List, Set)를 특정의 구상 구현 (예를 들어, ArrayList, HashSet)에 캐스팅하고 있습니다.
이것은 잘못된지도 모릅니다.
그리고 미래의 시점에서 다른 구체적인 구현에 전환을 매우 곤란하기 때문에 취약한 코드가 될지도 모릅니다.
이렇게하는 특별한 이유가없는 한 추상 컬렉션 클래스를 사용하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RE_POSSIBLE_UNINTENDED_PATTERN">
    <ShortDescription> 정규식을 위해 사용되고있다 ""</ ShortDescription>
    <LongDescription> 정규식 ""를 사용하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
String 메서드를 호출 해, ""이 인수로 정규식을 가지고 매개 변수로 전달됩니다.
이것은 의도 된 것입니까?
예를 들어, <code> s.replaceAll ( "", "/") </ code>는 모든 문자가 "/"문자로 대체 된 문자열을 반환합니다.
또한 <code> s.split ( ".") </ code>는 항상 길이가 0의 String의 배열을 돌려줍니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION">
    <ShortDescription> 정규식에 대한 잘못된 구문 </ ShortDescription>
    <LongDescription> 정규식에 대한 잘못된 구문입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 정규식 구문에 따르면 잘못 정규식을 사용하고 있습니다.
이 글이 실행될 때 PatternSyntaxException를 throw합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION">
    <ShortDescription> 정규식을 위해 사용되는 File.separator </ ShortDescription>
    <LongDescription> File.separator가 정규 표현을 위해 사용됩니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 정규식이 필요하다 <code> File.separator </ code>를 사용하고 있습니다.
이것은 <code> File.separator </ code>가 backslash 인 Windows 플랫폼에서 실패합니다.
백 슬래시는 정규 표현식에서 이스케이프 문자로 해석됩니다.
다른 방법으로는 <code> File.separator </ code> 대신 <code> File.separatorChar == '\ \'? "\ \ \ \": File.separator </ code>를 사용할 수 있습니다 .
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DLS_OVERWRITTEN_INCREMENT">
    <ShortDescription> 덮어 쓴 증가 </ ShortDescription>
    <LongDescription> 덮어 쓴 증가합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 증가 연산 (예 <code> i + + </ code>)를 실행하고 즉각적으로 겹쳐있다.
예를 들어, <code> i = i + + </ code>는 원래 값을 증가 값으로 덮어 씁니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  <BugPattern type="ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT">
    <ShortDescription> 부호없는 오른쪽 시프트를 short / byte에 캐스트하는 </ ShortDescription>
    <LongDescription> 부호없는 오른쪽 시프트를 short / byte에 캐스트합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 부호없는 캐스팅의 결과를 short 또는 byte에 캐스트합니다. 결과의 상위 비트는 버려집니다.
상위 비트가 버려지기 때문에, 부호, 부호없는 오른쪽 시프트의 (시프트의 크기에 따라) 차이가 없을지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="ICAST_BAD_SHIFT_AMOUNT">
    <ShortDescription> 32 비트 int의 0에서 31의 범위를 초과 한 양의 변화 </ ShortDescription>
    <LongDescription> 32 비트 int를 {2} 비트 시프트했습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 32 비트 int의 0에서 31의 범위를 초과 한 양에 변화를 실행하고 있습니다.
이것의 효과는 얼마나 변화 할 것인가를 결정하기 위해 정수 값의 하위 5 비트 (32로 나눈 나머지)를 사용하는 것입니다 (예를 들어, 40 비트 쉬프트하는 것은 8 비트 시프트하는 것과 같다, 32 비트에서 이동하는 것은 0 비트 교대 것과 같습니다).
이것은 아마도 예상 된 일이 없습니다, 적어도 잘못된 것입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="IM_MULTIPLYING_RESULT_OF_IREM">
    <ShortDescription> 정수 나머지 결과 정수 곱셈 </ ShortDescription>
    <LongDescription> 정수 나머지 결과 정수 곱셈. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 정수 나머지 결과에 정수를 곱합니다.
혼란 연산자의 우선 순위가 없는지 확인합니다.
예를 들어, i % 60 * 1000, i % (60 * 1000) 대신 (i % 60) * 1000입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_INVOKING_HASHCODE_ON_ARRAY">
    <ShortDescription> 배열 hashCode 메소드를 호출하는 </ ShortDescription>
    <LongDescription> 배열 hashCode 메소드를 호출합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 배열 <code> hashCode </ code> 메소드를 호출합니다.
배열 <code> hashCode </ code> 메소드를 호출하는 것은 System.identityHashCode와 같은 값을 반환하므로 콘텐츠와 배열의 길이를 무시합니다.
배열 <code> a </ code>의 내용으로 해시 코드를 필요로한다면, <code> java.util.Arrays.hashCode (a) </ code>를 사용하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_INVOKING_TOSTRING_ON_ARRAY">
    <ShortDescription> 배열 toString 메소드를 호출하는 </ ShortDescription>
    <LongDescription> {2.givenClass}에서 toString 메서드를 호출합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 배열 <code> toString </ code> 메소드를 호출합니다. "[C @ 16f0472"같이 확실히 쓸모없는 결과를 생성합니다.
배열의 내용을주고 읽을 문자열로 변환하기 위해 <code> Arrays.toString () </ code>를 사용하는 것이 좋습니다. <br>
"Programming Puzzlers"의 제 3 장, 퍼즐 12을 참조하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY">
    <ShortDescription> 이름없는 배열에서 toString 메서드를 호출하는 </ ShortDescription>
    <LongDescription> 이름없는 배열에서 toString 메서드를 호출합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 익명의 배열 <code> toString </ code> 메소드를 호출합니다. "[C @ 16f0472"같이 확실히 쓸모없는 결과를 생성합니다.
배열의 내용을주고 읽을 문자열로 변환하기 위해 <code> Arrays.toString () </ code>를 사용하는 것이 좋습니다. <br>
"Programming Puzzlers"의 제 3 장, 퍼즐 12을 참조하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>


  <BugPattern type="IM_AVERAGE_COMPUTATION_COULD_OVERFLOW">
    <ShortDescription> 평균 계산 오버플로 가능성이있는 </ ShortDescription>
    <LongDescription> 평균 계산은 오버플로가 발생할 수 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 나누기 또는 부호 오른쪽 쉬프트를 사용하여 2 개의 정수의 평균을 계산하여 그 결과를 배열의 인덱스로 사용하고 있습니다.
평균 값이 매우 큰 경우 오버 플로우가 발생할 수 있습니다 (결과적으로 부의 평균 계산된다).
결과가 부가 아닌 것을 의도했다면 대신 부호없는 오른쪽 시프트를 사용할 수 있습니다.
즉, <code> (low + high) / 2 </ code> 대신 <code> (low + high) >>> 1 </ code>를 사용하십시오.
</ p>
<p>
이 버그는 이진 검색과 병합 정렬의 많은 이전의 구현 존재합니다.
Martin Buchholz가 <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6412541"> JDK 라​​이브러리에서 버그를 발견하고 수정하고 있습니다 </ a>.
Joshua Bloch가 <a href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html"> 버그 패턴으로 공표했습니다 </ a>.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="IM_BAD_CHECK_FOR_ODD">
    <ShortDescription> 음수 작동하지 홀수 확인 </ ShortDescription>
    <LongDescription> 음수 작동하지 홀수 검사입니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 <code> x % 2 == 1 </ code>을 사용하여 값이 음수인지 확인하고 있습니다 만, 음수 (예 <code> (-5) % 2 == -1 </ code>)이므로 작동하지 않습니다.
홀수 검사를 예정하고 있다면, <code> x & 1 == 1 </ code> 또는 <code> x % 2! = 0 </ code>를 사용하는 것이 좋습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_HARDCODED_ABSOLUTE_FILENAME">
    <ShortDescription> 하드 코드 된 경로 이름에 대한 참조가있는 </ ShortDescription>
    <LongDescription> 하드 코드 된 경로 이름에 대한 참조가 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 하드 코드 된 경로 이름을 사용하여 File 객체를 구축합니다 (예 <code> new File ( "/ home/dannyc/workspace/j2ee/src/share/com/sun/enterprise / deployment "); </ code>).
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_BAD_MONTH">
    <ShortDescription> 월에 대한 잘못된 상수 값 </ ShortDescription>
    <LongDescription> 잘못된 월의 값 {2}을 {3}에 전달합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 메소드에 0에서 11의 범위를 벗어난 월 상수 값을 전달합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_USELESS_SUBSTRING">
    <ShortDescription> substring (0)의 호출은 원래 값을 반환 </ ShortDescription>
    <LongDescription> {1}은 원래 값을 반환 substring (0)를 호출합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 문자열 <code> substring (0) </ code>을 호출 있지만 원래 값을 반환합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_CALLING_NEXT_FROM_HASNEXT">
    <ShortDescription> hasNext 메소드 next 메소드를 호출하는 </ ShortDescription>
    <LongDescription> {1} {2.givenClass}를 호출합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> hasNext </ code> 메서드는 <code> next </ code> 메소드를 호출합니다.
<code> hasNext </ code> 메서드는 반복자의 상태를 변경하기로되어 있지 않기 때문에, 거의 확실하게 잘못된 것입니다.
<code> next </ code> 메소드가 반복자의 상태를 변경하는 것입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="SWL_SLEEP_WITH_LOCK_HELD">
    <ShortDescription> 잠금을 보유하고 Thread.sleep ()을 호출하는 방법 </ ShortDescription>
    <LongDescription> {1}은 잠금을 보유하고 Thread.sleep ()을 호출합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 잠금을 유지하고 <code> Thread.sleep () </ code>을 호출합니다.
다른 스레드가 락을 획득하기 위해 대기하고 있을지도 모르기 때문에 심한 성능과 확장 성, 또는 교착 상태가 될지도 모릅니다.
잠금 <code> wait </ code> 메소드를 호출 것은 매우 좋은 생각, 잠금을 해제하고 다른 스레드를 실행하는 것을 허용합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DB_DUPLICATE_BRANCHES">
    <ShortDescription> 두 분기를 위해 동일한 코드를 사용하는 방법 </ ShortDescription>
    <LongDescription> {1}은 두 분기를 위해 동일한 코드를 사용하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 조건 분기 두 분기를 구현하기 위해 같은 코드를 사용하고 있습니다.
이것이 코딩 실수가 없는지 확인하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DB_DUPLICATE_SWITCH_CLAUSES">
    <ShortDescription> switch 문 두 case를 위해 동일한 코드를 사용하는 방법 </ ShortDescription>
    <LongDescription> {1}은 switch 문 두 case를 위해 동일한 코드를 사용하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 switch 문 두 case를 구현하기 위해 같은 코드를 사용하고 있습니다.
중복 코드 case지도 모르고 코딩 실수 할지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="IMA_INEFFICIENT_MEMBER_ACCESS">
    <ShortDescription> 소유 클래스의 private 멤버 변수에 액세스하는 방법 </ ShortDescription>
    <LongDescription> {1}은 소유 클래스의 private 멤버 변수에 액세스합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 내부 클래스의 메서드는 소유 클래스의 private 멤버 변수를 읽거나 또는 소유 클래스의 private 메소드를 호출합니다.
컴파일러는이 private 멤버에 액세스하기 위해 특별한 방법을 생성해야하고 없으므로 효율을 악화시키는 원인이됩니다.
멤버 변수 또는 메서드의 보호를 완화하는 것은 컴파일러가 일반적 접근으로 대우하는 것을 허용합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="XFB_XML_FACTORY_BYPASS">
    <ShortDescription> XML 인터페이스의 특정 구현의 인스턴스를 생성하는 방법 </ ShortDescription>
    <LongDescription> {1}는 XML 인터페이스의 특정 구현의 인스턴스를 생성합니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 XML 인터페이스의 특정 구현의 인스턴스를 생성합니다.
구현이 런타임에 변경할 수 있도록 이러한 개체를 만드는 데 제공되는 팩토리 클래스를 사용하는 것이 바람직합니다. <br>
자세한 내용은 다음을 참조하십시오.
</ p>
<ul>
  <li> javax.xml.parsers.DocumentBuilderFactory </ li>
  <li> javax.xml.parsers.SAXParserFactory </ li>
  <li> javax.xml.transform.TransformerFactory </ li>
  <li> org.w3c.dom.Document.create <i> XXXX </ i> </ li>
</ ul>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="USM_USELESS_SUBCLASS_METHOD">
    <ShortDescription> 부모 클래스의 메소드에 과도하게 위임하고있는 메소드 </ ShortDescription>
    <LongDescription> {1}는 부모 클래스의 메소드에 과도하게 위임하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 파생 메서드는 단순히 주어진 정확한 매개 변수를 전달하는 동일한 슈퍼 클래스의 메소드를 호출 할뿐입니다.
이 방법은 부가가치가 주어지지 않기 때문에 제거 할 수 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="USM_USELESS_ABSTRACT_METHOD">
    <ShortDescription> 구현 된 인터페이스에서 이미 정의 된 추상 메서드 </ ShortDescription>
    <LongDescription> 추상 메소드 {1}은 구현 된 인터페이스에서 이미 정의되어 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 추상 메서드는이 추상 클래스에 의해 구현되는 인터페이스에서 이미 정의되어 있습니다.
이 방법은 부가가치가 주어지지 않기 때문에 제거 할 수 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="CI_CONFUSED_INHERITANCE">
    <ShortDescription> final 클래스가 protected 필드를 선언하는 </ ShortDescription>
    <LongDescription> 클래스 {0}은 final인데 protected 필드 {1}이 선언되어 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 final로 선언되어 있지만 필드는 protected로 선언되어 있습니다.
클래스는 fainal이므로 파생 될 수 없습니다. , protected의 사용은 잘못된 것입니다.
필드에 대한 액세스 한정자는 필드의 진정한 용도를 나타내므로 private 또는 public으로 변경해야합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT">
    <ShortDescription> 논리식으로 boolean 리터럴 값을 할당하는 방법 </ ShortDescription>
    <LongDescription> {1}는 논리식으로 boolean 리터럴 값을 할당하고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 방법은 if​​ 또는 while의 식에서 boolean 변수 boolean 리터럴 값 (true 또는 false)를 지정합니다.
아마도 이것은 = 대입이 아니라 ==를 사용하여 논리 비교를하게했습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
<BugPattern type="VR_UNRESOLVABLE_REFERENCE">
    <ShortDescription> 해결할 수없는 클래스, 메소드에 대한 참조 </ ShortDescription>
    <LongDescription> {0}에 따르면 {1}에 해결할 수없는 참조. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 분석 된 라이브러리에 대해 해결되지 않는 클래스 나 메소드를 참조하고 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="GC_UNCHECKED_TYPE_IN_GENERIC_CALL">
    <ShortDescription> 검사되지 않는 유형의 총칭 호출 </ ShortDescription>
    <LongDescription> 형 {3.givenClass}이 기대되는 곳에 주어진 Object 형식의 검사되지 않은 인수. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
일반 유형 매개 변수에서 특정 형식이 예상된다 Object 형을 컴파일 할 때, 범용 형 컬렉션 메서드 호출 인수를 전달합니다.
따라서 표준 Java 형 시스템도 정적 분석도 매개 변수로 전달되는 객체가 적절한 형태 여부에 대한 유용한 정보를 제공 할 수 없습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="GC_UNRELATED_TYPES">
    <ShortDescription> 형식 매개 변수와 메소드 인수에 무관 </ ShortDescription>
    <LongDescription> {2.givenClass}는 예상 된 인수 형식 {3.givenClass}과 호환되지 않습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
범용 형 컬렉션 메서드 호출에 컬렉션의 매개 변수와 호환되지 않는 클래스의 인수가 있습니다 (즉, 인수의 형태는 일반 유형 인수에 대응하는 슈퍼 타입에서도 하위 유형도 없습니다).
따라서 컬렉션 여기에서 사용 된 메소드 인수와 동일하다 어떤 개체도 포함하지 않습니다.
아마 잘못된 값이 메서드에 전달합니다.
일반적으로 2 개의 독립적 인 클래스의 인스턴스는 동일하지 않습니다.
예를 들어, <code> Foo </ code>와 <code> Bar </ code> 클래스가 하위 유형에 관계가 없다면 <code> Foo </ code>의 인스턴스는 <code> Bar </ code>의 인스턴스 와 동등한 리가 없습니다.
다른 문제에서 대칭 적이 지 않은 <code> equals </ code> 메소드가 될 가능성이 높습니다.
예를 들어, <code> Foo </ code>가 <code> String </ code>와 동일하다 같이 <code> Foo </ code> 클래스를 정의한다면, <code> String </ code>는 <code > String </ code>와 동일하다 그래서 <code> equals </ code> 메소드는 대칭 적이 지 않습니다.
</ p>
<p>
드물게 비대칭 <code> equals </ code> 메소드를 정의하고, 아직 어떻게 든 그 코드가 작동하고 있습니다.
API의 모두 문서화하고 있지 않으며 보장도하지 않지만 일반적인 경우 <code> Col​​lection <String> </ code>에 <code> Foo </ code>가 있는지 확인하고 싶다면,
인수 <code> equals </ code> 메서드 (예 <code> Foo </ code> 클래스의 <code> equals </ code> 메소드)를 사용하여 일치 여부를 확인합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES">
    <ShortDescription> 컬렉션은 자신을 포함 안된다 </ ShortDescription>
    <LongDescription> 컬렉션은 {2.givenClass}에 대한 호출에서 자신을 포함 할 것은 아니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 범용 형 컬렉션 메서드 호출은 컬렉션에 자신이있는 (예를 들어, <code> s.contains (s) </ code>가 true 이라며) 경우에만 의미가 있습니다.
이것은 true 일 가능성이 낮고, 만약 true라면 문제의 원인이됩니다 (예를 들어, 무한 반복되고있는 해시 코드의 계산).
잘못된 매개 변수가 전달되는 가능성이 높습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_VACUOUS_SELF_COLLECTION_CALL">
    <ShortDescription> 컬렉션에 무의미한 호출 </ ShortDescription>
    <LongDescription> 컬렉션 c에 c {2.name} (c)를 호출하는 것은 의미가 없습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 호출은 의미가 없습니다.
어떤 컬렉션 <code> c </ code>도 <code> c.containsAll (c) </ code>를 호출 할 항상 true이어야합니다.
그리고 <code> c.retainAll (c) </ code>는 효과가있을 리가 없습니다.
</ p>
     ]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="PZ_DONT_REUSE_ENTRY_OBJECTS_IN_ITERATORS">
    <ShortDescription> 반복 항목 개체를 재사용하지 </ ShortDescription>
    <LongDescription> {0}는 Iterator와 Map.Entry 모두 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 클래스는 Iterator와 Map.Entry에서 기저 Map보기를 반환하게 된 두 entrySet 메소드가 있습니다.
이 성공적인 아이디어는 Map 구현으로 사용되었지만, 귀찮은 코딩 실수의 가능성을 캡처했습니다.
Map <code> m </ code>가 entrySet위한 그런 반복자를 반환한다면, <code> c.addAll (m.entrySet ()) </ code>는 심각하게 잘못된 갈 것입니다.
OpenJDK 1.7 모든 Map 구현은이 문제를 해결하기 위해 재 작성되었다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DMI_ENTRY_SETS_MAY_REUSE_ENTRY_OBJECTS">
    <ShortDescription> 항목 세트의 요소를 추가하는 것은, Entry 객체 재사용을 위해 실패 할지도 모른다 </ ShortDescription>
    <LongDescription> 항목 세트의 요소를 추가하는 것은 {2.simpleClass}의 재사용을 위해 실패 할지도 모릅니다. {1} Entry 객체 </ LongDescription>
    <Details>
<! [CDATA [
<p>
entrySet 메소드는 하나의 Entry 객체를 재사용하고 반복하는 동안 반환되는 기본 Map보기를 반환 할 권한이 있습니다.
Java 1.6의 시점에서 IdentityHashMap와 EnumMap 모두 그랬어요.
그런 Map을 통해 반복 할 때, 항목 값은 다음 반복으로 진행까지 유효합니다.
예를 들어, addAll 메소드 그런 entrySet을 전달하려고하면 상황이 심각하게 잘못된 갈 것입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>
  
  <BugPattern type="DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION">
    <ShortDescription> 컬렉션을 지우려면 removeAll 메소드를 사용하지 </ ShortDescription>
    <LongDescription> 컬렉션을 지우려면 removeAll 메소드를 사용하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
컬렉션 <code> c </ code>에서 모든 요소를​​ 제거하고 싶다면, <code> c.removeAll (c) </ code> 대신 <code> c.clear </ code>를 사용하십시오.
컬렉션을 삭제하는 <code> c.removeAll (c) </ code>를 호출하는 것은 그다지 명확하지 오타의 오류에 노출 될 위험, 효율적이지 않고, 일부 컬렉션은 <code> ConcurrentModificationException </ code>를 던질지도 모릅니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="STCAL_STATIC_CALENDAR_INSTANCE">
    <ShortDescription> static Calendar 필드 </ ShortDescription>
    <LongDescription> {1}는 java.util.Calendar 형의 static 필드입니다. 그것은 스레드 안전하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
비록 JavaDoc에 이에 대한 단서가 아니더라도 Calendar는 멀티 스레드에서의 사용은 본질적으로 안전하지 않습니다.
정확한 동기화를하지 스레드 경계 너머에서 하나의 인스턴스를 공유하는 것은 응용 프로그램의 오작동입니다.
JDK 5.0보다 JDK 1.4 쪽이 문제가 표면화하도록 생각 아마도 sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate ()의 ArrayIndexOutOfBoundsExceptions 나 IndexOutOfBoundsExceptions가 무작위로 발생합니다.
직렬화 문제도 경험할지도 모릅니다. 인스턴스 필드를 사용할 것을 권장합니다. <br>
자세한 내용은 <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579"> Sun Bug # 6231579 </ a>과 <a href = "http://bugs. sun.com / bugdatabase / view_bug.do? bug_id = 6178997 "> Sun Bug # 6178997 </ a>를 참조하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE">
    <ShortDescription> static Calendar 호출 </ ShortDescription>
    <LongDescription> static 인 java.util.Calendar의 메소드를 호출합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
비록 JavaDoc에 이에 대한 단서가 아니더라도 Calendar는 멀티 스레드에서의 사용은 본질적으로 안전하지 않습니다.
검출기는 static 필드에서 얻은 Calendar 인스턴스의 호출을 발견했습니다.
이것은 의심 보입니다.
자세한 내용은 <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579"> Sun Bug # 6231579 </ a>과 <a href = "http://bugs. sun.com / bugdatabase / view_bug.do? bug_id = 6178997 "> Sun Bug # 6178997 </ a>를 참조하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE">
    <ShortDescription> static DateFormat </ ShortDescription>
    <LongDescription> {1}는 java.text.DateFormat 형의 static 필드입니다. 그것은 스레드 안전하지 않습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
JavaDoc에 쓰여진대로, DateFormat은 멀티 스레드에서의 사용은 본질적으로 안전하지 않습니다.
정확한 동기화를하지 스레드 경계 너머에서 하나의 인스턴스를 공유하는 것은 응용 프로그램의 오작동입니다.
JDK 5.0보다 JDK 1.4 쪽이 문제가 표면화하도록 생각 아마도 sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate ()의 ArrayIndexOutOfBoundsExceptions 나 IndexOutOfBoundsExceptions가 무작위로 발생합니다.
직렬화 문제도 경험할지도 모릅니다. 인스턴스 필드를 사용할 것을 권장합니다. <br>
자세한 내용은 <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579"> Sun Bug # 6231579 </ a>과 <a href = "http://bugs. sun.com / bugdatabase / view_bug.do? bug_id = 6178997 "> Sun Bug # 6178997 </ a>를 참조하십시오.
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE">
    <ShortDescription> static DateFormat의 호출 </ ShortDescription>
    <LongDescription> static 한 java.text.DateFormat의 메소드를 호출합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
JavaDoc에 쓰여진대로, DateFormat은 멀티 스레드에서의 사용은 본질적으로 안전하지 않습니다.
검출기는 static 필드에서 얻은 DateFormat 인스턴스의 호출을 발견했습니다.
이것은 의심 보입니다.
자세한 내용은 <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579"> Sun Bug # 6231579 </ a>과 <a href = "http://bugs. sun.com / bugdatabase / view_bug.do? bug_id = 6178997 "> Sun Bug # 6178997 </ a>를 참조하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="TQ_COMPARING_VALUES_WITH_INCOMPATIBLE_TYPE_QUALIFIERS">
    <ShortDescription> 호환되지 않는 형식 한정자의 비교 값 </ ShortDescription>
    <LongDescription> 형식 한정자 {2.simpleName}로 어노테이션 된 값이 한정자가없는 값과 동등한 위해 비교되어 있습니다. </ LongDescription>
    <Details>
      <! [CDATA [
<p>
형식 한정자 주석을 지정한 값이 규정되지 않은 값과 비교합니다.
</ p>
<p>
더 정확하게, when = ALWAYS를 지정한 형식 한정자 어노테이션 된 값이 같은 형식 한정자 when = NEVER을 지정하는 값과 비교합니다.
</ p>
<p>
예를 들어, @ NonNegative가 형식 한정자 주석 @ N​​egative (when = When.NEVER)의 약칭이라고합니다.
다음 코드는 return 문이 @ NonNegative 값을 요구한다, @ Negative로 표시된 값을 받기 때문에이 경고를 생성합니다.
</ p>
<blockquote> <pre>
public boolean example (@ Negative Integer value1, @ NonNegative Integer value2) {
    return value1.equals (value2);
}
</ pre> </ blockquote>
      ]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="TQ_ALWAYS_VALUE_USED_WHERE_NEVER_REQUIRED">
    <ShortDescription> 형식 한정자로 주석 된 값이 한정자 안 값을 필요로하는 장소에서 사용되는 </ ShortDescription>
    <LongDescription> 형식 한정자 {2} 어노테이션 된 값이 한정자 안 값을 필요로하는 곳에서 사용되고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
형식 한정자 주석을 지정한 값이 한정자 안 값을 필요로하는 곳에서 사용되고 있습니다.
</ p>
<p>
더 정확하게, when = ALWAYS를 지정한 형식 한정자 어노테이션 된 값이 도달하는 것이 보증되고 있는지 동일한 형식 한정자 when = NEVER을 지정하는 장소에서 사용하고 있습니다.
</ p>
<p>
예를 들어, @ NonNegative가 형식 한정자 주석 @ N​​egative (when = When.NEVER)의 약칭이라고합니다.
다음 코드는 return 문이 @ NonNegative 값을 요구한다 @ Negative로 표시된 값을 받기 때문에이 경고를 생성합니다.
</ p>
<blockquote> <pre>
public @ NonNegative Integer example (@ Negative Integer value) {
    return value;
}
</ pre> </ blockquote>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="TQ_NEVER_VALUE_USED_WHERE_ALWAYS_REQUIRED">
    <ShortDescription> 형식 한정자로 주석되지 않는 값이 한정자가 붙은 값을 필요로하는 장소에서 사용되는 </ ShortDescription>
    <LongDescription> 형식 한정자 {2.simpleName}에서 어노테이션되지 않는 값이 한정자가 붙은 값을 필요로하는 곳에서 사용되고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
형식 한정자 주석을 지정하지 않은 값이 한정자가 붙은 값을 필요로하는 곳에서 사용되고 있습니다.
</ p>
<p>
더 정확하게, when = NEVER를 지정한 형식 한정자 어노테이션 된 값이 같은 형식 한정자 when = ALWAYS을 지정하는 장소에서 사용하고 있습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="TQ_MAYBE_SOURCE_VALUE_REACHES_ALWAYS_SINK">
    <ShortDescription> 형 한정자 있지 않을지도 모른다 값이 형식 한정자를 필요로하는 방법으로 항상 사용되는 </ ShortDescription>
    <LongDescription> {2.simpleName} 주석을 지정하지 않을지도 모른다 값이 형식 한정자를 필요로하는 방법으로 항상 사용되고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
형 수식어로 표시된 값의 인스턴스가 아닌 잠재적으로 어노테이션 된 값입니다.
값은 그 형태 수식어로 표시된 값을 필요로하는 방법으로 사용되는 것을 보장합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="TQ_MAYBE_SOURCE_VALUE_REACHES_NEVER_SINK">
    <ShortDescription> 형 한정자 있는지도 모른다 값이 형식 한정자를 금지하는 방법으로 항상 사용되는 </ ShortDescription>
    <LongDescription> {2.simpleName} 주석을 달고있는지도 모른다 값이 형식 한정자를 금지하는 방법으로 항상 사용되고 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
형 수식어로 표시된 값의 인스턴스 잠재적으로 어노테이션 된 값입니다.
값은 그 형태 수식어로 표시된 값을 금지하는 방법으로 사용되는 것을 보장합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_NEVER_SINK">
    <ShortDescription> 값은 형식 한정자를 필요로하지 않지만, 알 수 없음으로 표시되어있다 </ ShortDescription>
    <LongDescription> 값은 {2.simpleName}을 필요로하지 않지만, 명시 적으로 {2.simpleName}에 대해 궁금한 어노테이션되어 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
값은 형식 한정자에 의해 나타난 값이 아닌 것을 필요로하는 방법으로 사용되고 있습니다.
그러나 값은 어디에서 그 형식 한정자가 있는지 금지되어기도 모르는 고 말했다 명시적인 주석이 있습니다.
사용 또는 주석 중 하나가 잘못된 것입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK">
    <ShortDescription> 값은 형식 한정자를 필요로하고 있지만, 알 수 없음으로 표시되는 </ ShortDescription>
    <LongDescription> 값은 항상 {2.simpleName}을 필요로하고 있지만, 명시 적으로 {2.simpleName}에 대해 궁금한 어노테이션되어 있습니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
값은 항상 형식 한정자에 의해 나타난 값임을 필요로하는 방법으로 사용되고 있습니다.
그러나 값은 어디에서 그 형식 한정자가 필요한지 모르겠다 고 말했다 명시적인 주석이 있습니다.
사용 또는 주석 중 하나가 잘못된 것입니다.
      </ p>
      ]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="IO_APPENDING_TO_OBJECT_OUTPUT_STREAM">
    <ShortDescription> 객체 출력 스트림에 추가 무산 </ ShortDescription>
    <LongDescription> 객체 출력 스트림에 추가 실패합니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 파일을 추가 모드로 열려, 객체 출력 스트림에 결과를 랩합니다.
이것은 파일에 저장된 기존의 객체 출력 스트림에 추가 할 수없는 것이다.
객체 출력 스트림에 추가하고 싶다면, 객체 출력 스트림을 열어 두어야합니다.
</ p>
<p>
추가 모드에서 파일을 열고 개체 출력 스트림에서 쓸 수있는 유일한 상황은
파일을 읽을 때 랜덤 액세스 모드에서 열고 추가를 시작하는 데까지 바이트 오프셋을 검색하면 계획 한 경우입니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL">
    <ShortDescription> 클래스 리터럴 대신 getClass에서 동기화하는 </ ShortDescription>
    <LongDescription> 클래스 리터럴 대신 getClass에서 동기화하고 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 인스턴스 메서드는 <code> this.getClass () </ code>에 동기화합니다.
이 클래스가 상속되는 경우, 서브 클래스는 아마 의도 한 것은 아니다 서브 클래스를 위해 클래스 개체에서 동기화합니다.
예를 들어, java.awt.Label의 다음 코드를 고려하십시오.
</ p>
<blockquote> <pre>
private static final String base = "label";
private static int nameCounter = 0;

String constructComponentName () {
    synchronized (getClass ()) {
        return base + nameCounter + +;
    }
}
</ pre> </ blockquote>
<p>
<code> Label </ code>의 서브 클래스는 같은 서브 클래스에서 동기화하지 않습니다. 데이터 레이스를 일으 킵니다.
대신,이 코드는 <code> Label.class </ code>에 동기화해야합니다.
</ p>
<blockquote> <pre>
private static final String base = "label";
private static int nameCounter = 0;

String constructComponentName () {
    synchronized (Label.class) {
        return base + nameCounter + +;
    }
}
</ pre> </ blockquote>
<p>
Jason Mehrens 의해 기증 된 버그 패턴
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="OBL_UNSATISFIED_OBLIGATION">
    <ShortDescription> 스트림이나 리소스 정리에 실패 할지도 모른다 방법 </ ShortDescription>
    <LongDescription> {1} {2} 정리에 실패 할지도 모릅니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 스트림 데이터베이스 개체 또는 명시 적으로 정리 작업을 필요로하는 다른 리소스 정리 (청산하는 해결)에 실패 할지도 모릅니다.
</ p>
<p>
일반적으로 메소드가 스트립 및 기타 리소스를 열었다면, 메소드는 스트림이나 자원이 메소드가 리턴되기 전에 정리되는 것을 확인하기 위해 try / finally 블록을 사용해야합니다.
</ p>
<p>
이 버그 패턴은 OS_OPEN_STREAM하면 ODR_OPEN_DATABASE_RESOURCE과 기본적으로 동일하지만 다른 (그리고 잘하면 더 좋은) 정적 분석 기술을 기반으로합니다.
우리는이 버그 패턴의 유용성에 대한 피드백을 얻는 데 관심이 있습니다.
두 가지 방법으로 의견을 보내주세요.
</ p>
<ul>
<li> send email to findbugs@cs.umd.edu </ li>
<li> file a bug report : <a href="http://findbugs.sourceforge.net/reportingBugs.html"> http://findbugs.sourceforge.net/reportingBugs.html </ a> </ li>
</ ul>
<p>
특히,이 버그 패턴의 오류 검출 억제 탐색 법은 상세하게 조정되지 않기 때문에 잘못된 판단에 대한 보고서는 우리의 도움이됩니다.
</ p>
<p>
분석 기술의 설명은 Weimer와 Necula에 따르면 <i> Finding and Preventing Run-Time Error Handling Mistakes </ i>을 참조하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE">
    <ShortDescription> 체크 예외 스트림이나 리소스 정리에 실패 할지도 모른다 방법 </ ShortDescription>
    <LongDescription> {1}는 체크 예외 {2} 정리에 실패 할지도 모릅니다. </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 메서드는 스트림 데이터베이스 개체 또는 명시 적으로 정리 작업을 필요로하는 다른 리소스 정리 (청산하는 해결)에 실패 할지도 모릅니다.
</ p>
<p>
일반적으로 메소드가 스트립 및 기타 리소스를 열었다면, 메소드는 스트림이나 자원이 메소드가 리턴되기 전에 정리되는 것을 확인하기 위해 try / finally 블록을 사용해야합니다.
</ p>
<p>
이 버그 패턴은 OS_OPEN_STREAM하면 ODR_OPEN_DATABASE_RESOURCE과 기본적으로 동일하지만 다른 (그리고 잘하면 더 좋은) 정적 분석 기술을 기반으로합니다.
우리는이 버그 패턴의 유용성에 대한 피드백을 얻는 데 관심이 있습니다.
두 가지 방법으로 의견을 보내주세요.
</ p>
<ul>
<li> send email to findbugs@cs.umd.edu </ li>
<li> file a bug report : <a href="http://findbugs.sourceforge.net/reportingBugs.html"> http://findbugs.sourceforge.net/reportingBugs.html </ a> </ li>
</ ul>
<p>
특히,이 버그 패턴의 오류 검출 억제 탐색 법은 상세하게 조정되지 않기 때문에 잘못된 판단에 대한 보고서는 우리의 도움이됩니다.
</ p>
<p>
분석 기술의 설명은 Weimer와 Necula에 따르면 <i> Finding and Preventing Run-Time Error Handling Mistakes </ i>을 참조하십시오.
</ p>
]]>
      </ Details>
  </ BugPattern>
  
  <BugPattern type="FB_UNEXPECTED_WARNING">
    <ShortDescription> FindBugs에서 예기치 않은 / 원치 않는 경고 </ ShortDescription>
    <LongDescription> 예기치 않은 / 원치 않는 {2} FindBugs 경고. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
FindBugs는 @ NoWarning에서 어노테이션 된하여 예기치 않은 / 원치 않는 경고를 생성했습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="FB_MISSING_EXPECTED_WARNING">
    <ShortDescription> 잃어버린 FindBugs에서 예상 / 바람직 경고 </ ShortDescription>
    <LongDescription> 잃어버린 예상 / 바람직 {2} FindBugs 경고. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
FindBugs는 @ ExpectedWarning에서 어노테이션 된 것으로, 예상 / 바람직 경고가 생성되지 않았습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED">
    <ShortDescription> putIfAbsent의 반환 값은 무시되어 putIfAbsent에 전달 된 값은 재사용 된 </ ShortDescription>
    <LongDescription> putIfAbsent의 반환 값은 무시되었지만, {4}는 재사용되었습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
<code> putIfAbsent </ code> 메서드는 일반적으로 하나의 값이 주어진 키 (존재가 성공 여부의 첫번째 값)와 관련된 것을 확인하기 위해 사용됩니다.
반환 값을 무시하고 중 전달되는 값에 대한 참조를 유지한다면, 맵의 키와 관련된 하나가 아닌 값을 유지하는 위험을 무릅 있습니다.
어느 것을 사용 하느냐가 중요하며, 맵에 포함 할 수없는 것을 사용하면 프로그램은 잘못된 행동을합니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE">
    <ShortDescription> 로거 변경은 OpenJDK의 약 참조로 인해 잠재적으로 손실 </ ShortDescription>
    <LongDescription> 로거 변경 사항이 손실 될 수 있습니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
OpenJDK는 잠재적 비 호환성을 도입했습니다. 특히 java.util.logging.Logger는 동작이 변경되고 있습니다.
강 참조를 사용하는 대신, 현재 내부적으로 약한 참조를 사용하고 있습니다.
그것은 말이 사항이지만, 불행히도 일부 코드는 이전 동작에 의존하고 있습니다.
로거 구성을 변경하면 로거에 대한 참조를 버립니다.
즉, 가비지 컬렉터는 메모리를 회수 할 수 있습니다. 그것은 로거 구성이 손실되는 것을 의미합니다.
예를 들어, 다음 사항을 고려하십시오.
</ p>
<blockquote> <pre>
public static void initLogging () throws Exception {
    Logger logger = Logger.getLogger ( "edu.umd.cs");
    logger.addHandler (new FileHandler ()); / / 로거 구성 변경
    logger.setUseParentHandlers (false); / / 다른 로거 구성 변경
}
</ pre> </ blockquote>
<p>
로거의 참조는 메소드의 끝 (메소드는 탈출하지 않습니다)에서 손실되기 때문에
<code> initLogging </ code>의 호출 후에 가비지 컬렉션의 순환이 있다면 로거 구성을 잃게됩니다 (왜냐하면 Logger는 약 참조를 유지하는 것이므로).
</ p>
<blockquote> <pre>
public static void main (String [] args) throws Exception {
    initLogging (); / / 파일 핸들러를 로거에 추가
    System.gc (); / / 로거 구성 손실
    Logger.getLogger ( "edu.umd.cs") info ( "Some message"); / / 기대 한대로 파일에 기록되지 않습니다
}
</ pre> </ blockquote>
<p>
Ulf Ochsenfahrt와 Eric Fellheimer
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="AT_OPERATION_SEQUENCE_ON_CONCURRENT_ABSTRACTION">
    <ShortDescription> 병행 추상 호출 시퀀스는 원자는 않을지도 모른다 </ ShortDescription>
    <LongDescription> {2}의 호출 순서는 원자는 아닐지도 모릅니다. {1} </ LongDescription>
    <Details>
<! [CDATA [
<p>
이 코드는 병행 추상화 (예를 들어, 병렬 해시 맵)의 호출 순서가 있습니다.
이 호출은 원자 적으로 실행되지 않습니다.
</ p>
]]>
    </ Details>
  </ BugPattern>

  <BugPattern type="DM_DEFAULT_ENCODING">
    <ShortDescription> 기본 인코딩에 따라 </ ShortDescription>
    <LongDescription> 기본 인코딩에 대한 의존도를 발견했습니다. {1} {2} </ LongDescription>
    <Details>
<! [CDATA [
<p>
바이트에서 String (또는 String로부터 바이트)로 변환 기본 플랫폼 인코딩이 적절하다고 가정 메서드 호출을 발견했습니다.
이것은 응용 프로그램의 동작이 플랫폼 사이에서 다른 원인이됩니다. 대체 API를 사용하여 명시 적으로 문자 집합 이름 또는 Charset 객체를 지정하십시오.
</ p>
]]>
    </ Details>
  </ BugPattern>
  
  <! -
  ************************************************** ********************
  BugCodes
  ************************************************** ********************
  ->
  <BugCode abbrev="FS"> 형식 문자열 문제 </ BugCode>
  <BugCode abbrev="SKIPPED"> 스킵 한 분석 </ BugCode>
  <BugCode abbrev="IL"> 무한 루프 </ BugCode>
  <BugCode abbrev="VO"> volatile의 사용 </ BugCode>
  <BugCode abbrev="UI"> 안전하지 않은 상속 </ BugCode>
  <BugCode abbrev="FL"> 부동 소수점 정밀도의 사용 </ BugCode>
  <BugCode abbrev="TEST"> 프로토 타입과 미완성 버그 패턴 테스트 </ BugCode>
  <BugCode abbrev="IMSE"> 의심 IllegalMonitorStateException 잡기 </ BugCode>
  <BugCode abbrev="CN"> 복제 가능 관용구의 잘못된 구현 </ BugCode>
  <BugCode abbrev="AT"> 자성 위반 가능성 </ BugCode>
  <BugCode abbrev="FI"> 종료 자에 대한 잘못된 사용 </ BugCode>
  <BugCode abbrev="ES"> ==와! =를 사용하는 문자열 일치 검사 </ BugCode>
  <BugCode abbrev="ML"> 업데이트되는 필드에서 동기화 (가변 잠금) </ BugCode>
  <BugCode abbrev="UG"> 동기화하지 get 메소드 동기화하는 set 메소드 </ BugCode>
  <BugCode abbrev="IO"> 입출력 문제 </ BugCode>
  <BugCode abbrev="IC"> 초기화 순환 </ BugCode>
  <BugCode abbrev="SI"> 의심 정적 이니셜 라이저 - </ BugCode>
  <BugCode abbrev="MSF"> 가변 서블릿 필드 </ BugCode>
  <BugCode abbrev="IS"> 일관성없는 동기화 </ BugCode>
  <BugCode abbrev="Eq"> equals () 구현 문제 </ BugCode>
  <BugCode abbrev="Co"> compareTo ()의 구현 문제 </ BugCode>
  <BugCode abbrev="HE"> 등가 인 오브젝트는 등가 인 해시 코드를 가져야한다 </ BugCode>
  <BugCode abbrev="AM"> API의 오용 </ BugCode>
  <BugCode abbrev="Dm"> 의심 메소드의 사용 </ BugCode>
  <BugCode abbrev="Bx"> 의심 원시 값 권투 </ BugCode>
  <BugCode abbrev="UR"> 생성자에서 초기화되지 않은 필드의 읽기 </ BugCode>
  <BugCode abbrev="RR"> InputStream.read ()의 반환 무시 </ BugCode>
  <BugCode abbrev="NN"> 알몸 notify () </ BugCode>
  <BugCode abbrev="UW"> 무조건 wait () </ BugCode>
  <BugCode abbrev="SP"> 스핀 잠금 </ BugCode>
  <BugCode abbrev="DC"> 필드의 더블 체크 가능성 </ BugCode>
  <BugCode abbrev="Wa"> 루프없는 wait () </ BugCode>
  <BugCode abbrev="No"> notifyAll () 대신 notify ()를 사용하는 </ BugCode>
  <BugCode abbrev="DE"> 버려진 또는 무시 된 예외 </ BugCode>
  <BugCode abbrev="Ru"> run ()의 호출 </ BugCode>
  <BugCode abbrev="It"> 반복자의 잘못된 정의 </ BugCode>
  <BugCode abbrev="SnVI"> Version ID가없는 직렬화 가능 클래스 </ BugCode>
  <BugCode abbrev="Se"> 직렬화 가능 클래스의 잘못된 정의 </ BugCode>
  <BugCode abbrev="WS"> writeObject ()는 동기화하고 있지만, 다른 방법은 동기화하지 </ BugCode>
  <BugCode abbrev="RS"> readObject ()를 동기화하는 </ BugCode>
  <BugCode abbrev="SC"> Thread.start ()를 호출 생성자 </ BugCode>
  <BugCode abbrev="MS"> 가변 static 필드 </ BugCode>
  <BugCode abbrev="EI"> 내부 표현을 폭로 할지도 모른다 배열을 반환하는 방법 </ BugCode>
  <BugCode abbrev="Nm"> 혼란 메서드 이름 </ BugCode>
  <BugCode abbrev="SS"> 읽어 않는 필드는 static으로해야 </ BugCode>
  <BugCode abbrev="UuF"> 미사용 필드 </ BugCode>
  <BugCode abbrev="UrF"> 읽어 않는 필드 </ BugCode>
  <BugCode abbrev="UwF"> 기록되지 않는 필드 </ BugCode>
  <BugCode abbrev="SIC"> static에있는 내부 클래스 </ BugCode>
  <BugCode abbrev="TLW"> 2 개의 잠금을 wait () </ BugCode>
  <BugCode abbrev="RV"> 메소드의 반환 값의 잘못된 사용 </ BugCode>
  <BugCode abbrev="LG"> Logger 문제 </ BugCode>
  <BugCode abbrev="IA"> 모호한 호출 </ BugCode>
  <BugCode abbrev="HSC"> 거대한 문자열 상수 </ BugCode>
  <BugCode abbrev="HRS"> HRS 취약성 </ BugCode>
  <BugCode abbrev="PT"> 경로 탐색 </ BugCode>
  <BugCode abbrev="XSS"> XSS 취약점 </ BugCode>
  <BugCode abbrev="NP"> null 값의 이용 </ BugCode>
  <BugCode abbrev="NOISE"> 가짜 무작위 경고 </ BugCode>
  <BugCode abbrev="RpC"> 조건 검사를 반복 </ BugCode>
  <BugCode abbrev="OS"> 모든 경로에서 클로우즈되지 않는 스트림 </ BugCode>
  <BugCode abbrev="PZLA"> 결과가 없다는 위해 null보다 길이 0의 배열을 선택 </ BugCode>
  <BugCode abbrev="UCF"> 쓸모없는 제어 흐름 </ BugCode>
  <BugCode abbrev="RCN"> null에 중복 비교 </ BugCode>
  <BugCode abbrev="UL"> 모든 경로에서 해제되지 않는 잠금 </ BugCode>
  <BugCode abbrev="RC"> 의심 참조 등가성의 사용 </ BugCode>
  <BugCode abbrev="EC"> 호환되지 않는 형식의 동등성 비교 </ BugCode>
  <BugCode abbrev="MWN"> 불일치 wait () 또는 notify () </ BugCode>
  <BugCode abbrev="SA"> 쓸모없는 자기 연산 </ BugCode>
  <BugCode abbrev="INT"> 의심 정수 식 </ BugCode>
  <BugCode abbrev="BIT"> 의심 비트 연산 식 </ BugCode>
  <BugCode abbrev="LI"> 비 동기화 지연 초기화 </ BugCode>
  <BugCode abbrev="JLM"> java.util.concurrent 개체의 동기화 </ BugCode>
  <BugCode abbrev="UPM"> 호출되지 않는 private 메소드 </ BugCode>
  <BugCode abbrev="UMAC"> 무명 클래스의 호출 할 수없는 메서드 </ BugCode>
  <BugCode abbrev="EI2"> 가변 개체에 대한 참조를 저장 </ BugCode>
  <BugCode abbrev="NS"> 의심 비 단락 논리 연산자 사용 </ BugCode>
  <BugCode abbrev="ODR"> 모든 경로에서 청산되지 않은 데이터베이스 리소스 </ BugCode>
  <BugCode abbrev="SBSC"> 루프에서 + 연산자를 사용하여 문자열 연결 </ BugCode>
  <BugCode abbrev="ITA"> 비효율적 collection.toArray (new Foo [0])의 사용 </ BugCode>
  <BugCode abbrev="SW"> Swing 코딩 </ BugCode>
  <BugCode abbrev="IJU"> 잘못 구현 된 JUnit TestCase </ BugCode>
  <BugCode abbrev="BOA"> 잘못 재정의 된 Adapter </ BugCode>
  <BugCode abbrev="SF"> switch 문장 폴 스루 </ BugCode>
  <BugCode abbrev="SIO"> 불필요한 instanceof </ BugCode>
  <BugCode abbrev="BAC"> 잘못된 애플릿의 생성자 </ BugCode>
  <BugCode abbrev="UOE"> Object.equals ()를 사용하는 </ BugCode>
  <BugCode abbrev="STI"> 의심 Thread.interrupted () </ BugCode>
  <BugCode abbrev="DLS"> 로컬 변수에 잘못된 할당 </ BugCode>
  <BugCode abbrev="IP"> 무시 된 매개 변수 </ BugCode>
  <BugCode abbrev="MF"> 숨겨진 필드 </ BugCode>
  <BugCode abbrev="WMI"> 비효율적 Map 반복자 </ BugCode>
  <BugCode abbrev="ISC"> 인스턴스화 된 static 클래스 </ BugCode>
  <BugCode abbrev="REC"> RuntimeException 포착 </ BugCode>
  <BugCode abbrev="FE"> 부동 소수점 동등성 테스트 </ BugCode>
  <BugCode abbrev="UM"> 상수에 대한 불필요한 Math </ BugCode>
  <BugCode abbrev="CD"> 순환 종속성 </ BugCode>
  <BugCode abbrev="RI"> 중복 인터페이스 </ BugCode>
  <BugCode abbrev="MTIA"> 멀티 스레드에서 인스턴스 액세스 </ BugCode>
  <BugCode abbrev="PS"> 공개 세마포어 </ BugCode>
  <BugCode abbrev="BSHIFT"> 잘못된 이동 </ BugCode>
  <BugCode abbrev="ICAST"> 정수에서 캐스트 </ BugCode>
  <BugCode abbrev="RE"> 정규식 </ BugCode>
  <BugCode abbrev="SQL"> 잠재적 SQL 문제 </ BugCode>
  <BugCode abbrev="WL"> 잘못된 개체 잠근 수있는 </ BugCode>
  <BugCode abbrev="ESync"> 빈 synchronized 블록 </ BugCode>
  <BugCode abbrev="QF"> 의심 for 루프 </ BugCode>
  <BugCode abbrev="VA"> 가변 인자의 문제 </ BugCode>
  <BugCode abbrev="BC"> 객체 참조의 잘못된 캐스트 </ BugCode>
  <BugCode abbrev="IM"> 의심 정수 계산 </ BugCode>
  <BugCode abbrev="ST"> static 필드의 오용 </ BugCode>
  <BugCode abbrev="JCIP"> net.jcip 주석 위반 </ BugCode>
  <BugCode abbrev="USELESS_STRING"> 쓸모없는 / 쓸모없는 문자열 생성 </ BugCode>
  <BugCode abbrev="DMI"> 의심 메서드 호출 </ BugCode>
  <BugCode abbrev="PZ"> Joshua Bloch와 Neal Gafter에 따르면 "Java Puzzlers"에 영향을받은 경고 </ BugCode>
  <BugCode abbrev="SWL"> 잠금을 sleep </ BugCode>
  <BugCode abbrev="J2EE"> Java EE의 오류 </ BugCode>
  <BugCode abbrev="DB"> 복제 된 분기 </ BugCode>
  <BugCode abbrev="IMA"> 비효율적 멤버 액세스 </ BugCode>
  <BugCode abbrev="XFB"> XML 팩토리의 우회 </ BugCode>
  <BugCode abbrev="USM"> 쓸모없는 하위 클래스 메서드 </ BugCode>
  <BugCode abbrev="CI"> 혼란 상속 </ BugCode>
  <BugCode abbrev="QBA"> 의심 Boolean 대입 </ BugCode>
  <BugCode abbrev="VR"> 버전 호환성 문제 </ BugCode>
  <BugCode abbrev="DP"> doPrivileged의 사용 </ BugCode>
  <BugCode abbrev="GC"> 의심 총칭 형 컬렉션 메서드 호출 </ BugCode>
  <BugCode abbrev="STCAL"> Calendar, DateFormat의 static 사용 </ BugCode>
  <BugCode abbrev="TQ"> 형식 한정자 주석 일관성없는 사용 </ BugCode>
  <BugCode abbrev="OBL"> 스트림 또는 리소스를 정리하는 책임이 충족되지 않은 </ BugCode>
  <BugCode abbrev="FB"> FindBugs는 메서드 예상 한 경고를 발행하지 못했습니다 </ BugCode>
  <BugCode abbrev="DL"> 공유 객체를 의도적 아니라 록해서 잠재적 교착 상태 </ BugCode>
</ MessageCollection>